ZVSE2
; Author:   Archer30
; Engine:   ERM 2.0+
; Requires: ERA 3.3+, Era Erm Framework

; Third Upgrade Mod: Reborn is a side project launched by Archer30, the script author of Third Upgrade Mod


// Constants
; ===============  MONSTERS  ===============
!#DC(MON_CHERUB)                   = 202;
!#DC(MON_DWARF_DESTROYER)          = 203;
!#DC(MON_GOLD_GARGOYLE)            = 208;
!#DC(MON_VAMPIRE_ELDER)            = 221;

!#DC(MON_CARPET_WHISPERER)         = 239;

!#DC(MON_VENOMSPIKE_WYVERN)        = 243;
!#DC(MON_SNOW_ELEMENTAL)           = 248;
!#DC(MON_ELVEN_RANGER)             = 256;
!#DC(MON_MIRACLE_MAGE)             = 259;
!#DC(MON_MAD_MUMMY)                = 273;

!#DC(MON_ENTOMBED_SPHINX)          = 304;
!#DC(MON_ASHEN_SPHINX)             = 305;

!#DC(MON_SPIRIT_SHAMAN)            = 307;
!#DC(MON_WENDIGO)                  = 308;
!#DC(MON_PLAGUE_DOCTOR)            = 309;
!#DC(MON_GNOME)                    = 310;

!#DC(MON_LOST_SOUL)                = 319;
!#DC(MON_SHADOW_LORD)              = 324;

!#DC(MON_NETHERBAT)                = 326;
!#DC(MON_RAT)                      = 327;
!#DC(MON_BATTLE_RAT)               = 328;

!#DC(MON_EVERLASTING_DRAGON)       = 330;

!#DC(MON_RATMAN)                   = 331;
!#DC(MON_RATMAN_GRENADIER)         = 332;
!#DC(MON_CULTIST)                  = 333;
!#DC(MON_CULTIST_LEADER)           = 334;
!#DC(MON_OOZE)                     = 335;
!#DC(MON_GEL_OOZE)                 = 336;
!#DC(MON_ROOK)                     = 337;
!#DC(MON_RAVEN)                    = 338;
; =============  END MONSTERS  =============

; ==============  DWELLINGS  ===============
// Type 17
!#DC(OBJ_CARPET_SELLER)            = 133; 

; Tok
!#DC(OBJ_CAVERN_OF_SORROW)         = 143;
!#DC(OBJ_CORRBOREE_SPOT)           = 144;
!#DC(OBJ_BLIGHT_LAB)               = 145;
!#DC(OBJ_GRASS_CABIN)              = 147;

; The Rat Mod
!#DC(OBJ_FACELESS_IDOL)            = 150;
!#DC(OBJ_ALCHEMIC_PLANT)           = 151;
!#DC(OBJ_RAVEN_SUMMIT)             = 152;
!#DC(OBJ_NETHER_GATE)              = 102;

// Type 20
!#DC(OBJ_SEWER_ENTRANCE)           = 5;
; ============  END DWELLINGS  =============


; ==============  ARTIFACTS  ===============
!#DC(ART_BUCKLER_OF_THE_BEELZEBUB)       = 258;

!#DC(ART_MAGIC_CLOAK)                    = 261;
!#DC(ART_GARB_OF_THE_FOREST_LORD)        = 279;
!#DC(ART_THIRD_EYE)                      = 280;
!#DC(ART_ARMOR_OF_THE_ANCIENT_LIZARDMAN) = 281;
!#DC(ART_BINOCULARS)                     = 282;
!#DC(ART_SLEEPKEEPER)                    = 283;
!#DC(ART_SWORD_OF_FROST)                 = 284;
!#DC(ART_TRI_COLOUR_SCEPTER)             = 285;
!#DC(ART_TRI_COLOUR_SCEPTER_NON_LIVING)  = 285;
!#DC(ART_TRI_COLOUR_SCEPTER_LIVING)      = 286;
!#DC(ART_TRI_COLOUR_SCEPTER_UNDEAD)      = 287;
; ============  END ARTIFACTS  =============


; ==========  CUSTOM SPELL BUFFS  ==========
!#DC(SPELL_UNDEAD)                       = 0;
!#DC(SPELL_DRAGON)                       = 1;
!#DC(SPELL_INFERNO_REINFORCEMENTS)       = 2;
!#DC(SPELL_DEAFEN)                       = 3;
; 4 for Henchmen
!#DC(SPELL_SPELL_JAMMER)                 = 5;
!#DC(SPELL_FLAMMABLE_COAT)               = 6;
!#DC(SPELL_VENDETTA)                     = 7;
; 8 and 9 for Second Henchmen
; Elemental marks should be replaced as they corrupt stack exp ability names
!#DC(SPELL_AIR_MARK)                     = 83;
!#DC(SPELL_WATER_MARK)                   = 84;
!#DC(SPELL_FIRE_MARK)                    = 85;
!#DC(SPELL_EARTH_MARK)                   = 86;
; ========  END CUSTOM SPELL BUFFS  ========


// Enable the signature variable of Third Upgrade Mod: Reborn
!#VRi^tum_reborn_on^:S(TRUE);

// Compatibility check
!?FU(tum_CheckCompatibility);
!!FU(FileExists):P^data\WF_Objects.pac^/?(result:y);

!!if&(result)=(FALSE);
  !!VR(art:y):S(ART_SWORD_OF_FROST);
  !!SN:H^art^/(art)/0/?(artName:z) H^art^/(art)/0/^^;
  !!IF:Q1/(PIC_TYPE_ART)/(art)/(PIC_TYPE_ART)/(art)/(PIC_TYPE_ART)/(art)/(MSG_TYPE_MES)/^%T(tumr.str.wf)^;
  !!SN:H^art^/(art)/0/(artName);

  !!UN:R6/(INT_MAX);
!!en;

!#FU(tum_CheckCompatibility):P;

// Disable Diff Mod TUM rebalance option new creature descrptions
!?FU(Set_Monster_Special_Text);
!!SN:Q;

// Replace ToW Werewolves with Sphinx
!?FU(OnAfterErmInited);
!!if&i^eighth_on^;
  !!SN:Vi^eighth_dwellReqDwellsList^/0/34/34/35/33/34/33/33/32/34; [id of required buildings for each factions]
  !!SN:Vi^eighth_dwellCostsList_%(TOWN_RAMPART)^/0/5/0/5/0/0/3/5000;
  !!SN:Vi^eighth_dwellCostsList_%(TOWN_INFERNO)^/0/5/0/5/0/0/5/5000;
  !!SN:Vi^eighth_dwellCostsList_%(TOWN_NECROPOLIS)^/0/5/0/0/0/5/0/5000;
  !!SN:Vi^eighth_dwellCostsList_%(TOWN_CONFLUX)^/0/5/0/5/0/0/0/5000;
!!en;

!!SN:Vi^eighth_8thMonsList^/8/(MON_ENTOMBED_SPHINX)/(MON_ASHEN_SPHINX);
!!MA:U(MON_ENTOMBED_SPHINX)/(MON_ASHEN_SPHINX);
!!MA:O(MON_ASHEN_SPHINX)/(TOWN_NECROPOLIS);

***************************************************
**** Fix ACM Monster Spell Count Compatibility ****
***************************************************
; XEricSin's script doesn't work correctly with erm emulated spells. Here we have to use a script to preserve the compatibility
; This script should be removed if the next version of ACM is released
!?FU(tum_FixXEMonsterSpellCountCompatibility)&i^Advanced_Classes_Mod_Active^; [ACM Compatibility]
!!BMi^battle_current_stack^:E?(spells:y);
!!VRi^tum_monSpellCountPlus10000^:S(spells) +10000;

!?FU(OnBattleActionEnd)&i^tum_monSpellCountPlus10000^;
!!VR(spells:y):Si^tum_monSpellCountPlus10000^ -10000;
!!BMi^battle_current_stack^:E(spells);
!!VRi^tum_monSpellCountPlus10000^:S0;

*********************************************************
**** Fix ACM blocking all the specialty mouse clicks ****
*********************************************************
; Evil ACM, why do you have to use mouse click trigger to show specialties?
!?FU(OnHeroScreenMouseClick)&i^mouse_item^=118/i^Advanced_Classes_Mod_Active^;
!!FU&i^mouse_action^<>(MOUSE_LMB_PRESSED)/i^mouse_action^<>(MOUSE_RMB_PRESSED):E;

!!HE(CURRENT_HERO):N?(hero:y);

!!if&(hero)=(HERO_MUTARE_DRAKE);
  !!SN:Q;
!!en;

************************************************
**** Related creature upgrades and factions ****
************************************************

!?FU(OnEveryDay)&i^timerOnce^/i^timerDay^=1;
; Mummy
!!MA:O(MON_MUMMY)/?(faction:y);
!!MA:O(MON_MAD_MUMMY)/(faction);

!!MA:U(MON_MUMMY)/(MON_MAD_MUMMY);
!!MA:U(MON_MAD_MUMMY)/(MON_MUMMY);

**********************************************************************
**** Cosmetic changes - Commanders and Werewolves, Coloured Beams ****
**********************************************************************
// New Commander sound and Werewolves full moon sprites
!?FU(OnGameEnter);
; Temple Guardian
!!FU(arch_SetShooterProjectile):P(MON_TEMPLE_GUARDIAN_A)/12 P(MON_TEMPLE_GUARDIAN_D)/12;

; Soul Eater
!!FU(arch_SetMonsterSound):P(MON_SOUL_EATER_A)/^wrth^ P(MON_SOUL_EATER_D)/^wrth^; [Wraith's sound since the creature has no feet]
!!SN:R^wrthshot^/^gnolshot^;    [Add missing shot's sound for Wraith]

!!FU(arch_ChangeWerewolfGraphics):P;
!!FU(arch_ChangeHalloweenGraphics):P;

!?FU(OnEveryDay)&i^timerOnce^;
!!FU(arch_ChangeWerewolfGraphics):P;

!?FU(arch_ChangeWerewolfGraphics);
; Set the graphics to the primal version
!!if&i^timerMonthDay^=14;
  !!SN:R^cprsmall.def:0_196.png^/^data\defs\cprsmall.def\0_196s.png^;
  !!SN:R^twcrport.def:0_196.png^/^data\defs\twcrport.def\0_196b.png^;
  !!FU(arch_Battle_SetMonsterAnimation):P(MON_WEREWOLF)/^zm194b.def^;
  !!FU(arch_AdvMap_SetMonsterAnimation):P(MON_WEREWOLF)/^zmm194m.def^;
  !!SN:R^zm194z.def^/^data\defs\cprsmall.def\0_196s.png^;
  !!SN:R^zmm194z.def^/^data\defs\twcrport.def\0_196b.png^;
; Set the graphcis to the original version
!!el&i^timerMonthDay^=17;
  !!SN:R^cprsmall.def:0_196.png^/^^;
  !!SN:R^twcrport.def:0_196.png^/^^;
  !!FU(arch_Battle_SetMonsterAnimation):P(MON_WEREWOLF)/^zm194z.def^;
  !!FU(arch_AdvMap_SetMonsterAnimation):P(MON_WEREWOLF)/^zmm194z.def^;
  !!SN:R^zm194z.def^/^^;
  !!SN:R^zmm194z.def^/^^;
!!en;

!?FU(arch_Battle_SetMonsterAnimation);
!#VA(mon:x) (filename:x);

!!UN:C4697553/4/?(monInfoTable:y);
!!VR(animPtr:y):S116 *(mon) +(monInfoTable) +12;
!!UN:C(animPtr)/4/?(value:y);
!!SN:K10/z(filename)/(value)/1;

; Functions
!?FU(arch_SetShooterProjectile);
!#VA(mon:x);                            [ID of creature]
!#VA(projInd:x);                        [0~15]
; 0 Monk
; 1 Archer
; 2 Wood Elf
; 3 Master Gremlin
; 4 Mage
; 5 Titan (Storm Elemental)
; 6 Gog
; 7 Lich
; 8 Medusa
; 9 Orc
; 10 Cyclops
; 11 Lizardman
; 12 Ice Elemental
; 13 Halfling
; 14 Catapult
; 15 Ballista

!!VR(address:y):S(mon) +7994814;
!!UN:C(address)/(UNC_INT8)/(projInd);

!?FU(arch_SetMonsterSound);
!#VA(mon:x);                            [Integer. ID of the creature]
!#VA(prefix:x);                         [String. 4 characters prefix of the sound effect]

!!UN:C4697553/4/?(monInfoTable:y);
!!VR(soundPtr:y):S116 *(mon) +(monInfoTable) +8;
!!UN:C(soundPtr)/4/?(value:y);
!!SN:K4/z(prefix)/(value)/1;

!?FU(arch_AdvMap_SetMonsterAnimation);
!#VA(mon:x) (filenamePtr:x);

; loop through all the werewolves
!!VR(x:y):S-1;

!!re i;
  !!UN:U(OBJ_MONSTER)/(mon)/-1/(x)/(y:y)/(z:y);
  !!br&(x)<0;

  !!FU(arch_ChangeAdvMapMonsterDef):P(x)/(y)/(z)/z(filenamePtr);
!!en;

!?FU(arch_ChangeAdvMapMonsterDef);                                 [by daemon_n]
!#VA(x:x) (y:x) (z:x) (defName:x);

!!OB(x:x)/(y:x)/(z:x):T?t U?s;

!!if&t=(OBJ_MONSTER);
  !!UN:C(ADV_MANAGER)/(UNC_UINT32)/?(advMgr:y);
  !!UN:C(advMgr)/92/(UNC_UINT32)/?(list:y);
  !!SN:E4228816/2/(list)/(x)/(y)/(z);                              [Get map item]
  !!VR(mapItem:y):Sv1;
  !!UN:C(GAME_MANAGER)/4/?(gameMgr:y);                             [get Game * obj;]

  !!VR(objectAttributesList:y):S(gameMgr) +129904;                 [get MainStructList * obj;]
  !!SN:E5268720/(CALLCONV_THISCALL)/(objectAttributesList)/t/s;    [get standard ObjectAttributes* by type/subtype  list;]
  !!UN:Cv1/4/4/?(namePtr:y);                                       [get def name ptr;]
  !!SN:B(namePtr:y)/d/?(oldDefName:z) B(namePtr:y)/d/z(defName:x); [set new def name]
  !!SN:E5019216/(CALLCONV_THISCALL)/(gameMgr)/(mapItem);           [call "SetMapItemDef" function to set view with new def name]
  !!SN:B(namePtr:y)/d/(oldDefName:z);                              [restore original name at same ptr]
!!en;


// Holiday graphics
!?FU(OnAfterErmInstructions);
!!FU(tum_GetLocalTime):Pd/?(month:y)/d/?(day:y);
!!VRi^tum_isHalloween^&(month)=4/(day)=17:S(TRUE);
!!VRi^tum_isChristmas^&(month)=12/(day)>=24/(day)<=25:S(TRUE);

!?FU(OnStartOrLoad);
!!if&i^tum_isHalloween^;
  !!SN:R^cprsmall.def:0_58.png^/^data\defs\cprsmall.def\0_58a.png^;
  !!SN:R^twcrport.def:0_58.png^/^data\defs\twcrport.def\0_58a.png^;
  !!SN:R^CSKELE.def^/^CSKELa.def^;
  !!SN:R^AVWskel0.def^/^AVWskela.def^;
!!en;


// Change the shape of beam of Supreme Arch Mages and the colour of Monstrous Eyes - thanks to OxFEA
!?FU(tum_CreateERMHook);
!#VA(hook:x);

!!SN:E(hook)/1/4452977/(arch_OnBeforeRayShooting);

!?FU(arch_OnBeforeRayShooting);
!#VA(hook:x);

; Restore values
!!UN:C4453058/1/0 C4453056/1/0;
!!UN:C4453008/4/304;

; Get the type of monster ray shooting
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBX)/4/?(mon:y);

; Change the shape of Arch Mages
!!if|(mon)=(MON_SUPREME_ARCH_MAGE);
  !!UN:C4453058/1/32 C4453056/1/176;

  !!SN:X?y99/0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4453000;

; Change the Colour of Beholders
!!el|(mon)=(MON_MONSTROUS_EYE);
  !!VR(random:y):R0/0/13;
  !!UN&(random)=0:C4453008/4/63488;     [Red]
  !!UN&(random)=1:C4453008/4/64512;     [Orange]
  !!UN&(random)=2:C4453008/4/65504;     [Yellow]
  !!UN&(random)=3:C4453008/4/2016;      [Green]
  !!UN&(random)=4:C4453008/4/2047;      [Aqua]
  !!UN&(random)=5:C4453008/4/31;        [Blue]
  !!UN&(random)=6:C4453008/4/32784;     [Purple]

  !!SN:X?y99/0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4453007;
!!en;

; Restore values
!?FU(OnBeforeBattleUniversal);
!!UN:C4453058/1/0 C4453056/1/0;
!!UN:C4453008/4/304;

!?FU(OnAfterBattleUniversal);
!!UN:C4453058/1/0 C4453056/1/0;
!!UN:C4453008/4/304;

!?FU(OnGameLeave);
!!UN:C4453058/1/0 C4453056/1/0;
!!UN:C4453008/4/304;

***********************************************************************************
**** Precise creature description for Golems, Elementals and other Non-livings ****
***********************************************************************************
; Must be OnAfterErmInited to be compatible with Elemental Balance (Era Scripts)
!?FU(OnAfterErmInited);
!!FU(GetMaxMonsterId):P?(lastMon:y);

!!re i/(MON_FIRST)/(lastMon);
  ; Skip special creatures
  !!co&i>=(MON_COMMANDER_FIRST_A)/i<=(MON_COMMANDER_LAST_D);
  !!co&i>=(MON_CATAPULT)/i<=(MON_ARROW_TOWERS);
  *!co&i>=(MON_EMISSARY_OF_WAR)/i<=(MON_EMISSARY_OF_LORE);

  ; Get the living type of creature and set description if they are non-living
  !!FU(tum_GetStackOrMonLivingType):Pi/(TRUE)/?(result:y);

  !!if&(result)>=2/(result)<=4;
    !!SN:H^monname^/i/2/?(desc:z);

    !!if&(result)=2;
      !!VR(newDesc:z):S^%T(tumr.str.golem)%(desc)^;
    !!el&(result)=3;
      !!VR(newDesc):S^%T(tumr.str.elemental)%(desc)^;
    !!el&(result)=4;
      !!VR(newDesc):S^%T(tumr.str.nonLiving)%(desc)^;
    !!en;

    !!SN:H^monname^/i/2/(newDesc);
  !!en;
!!en;

**********************************
**** Disable Amethyst feature ****
**********************************
; Restore Amethyst patched code to wog default
; Thanks to Hawaiing
!?FU(OnGameEnter);
!!SN:F^PluginExists^/^amethyst2_4^;
!!FU&v1=0:E;

; Reduce Defense
; The original Reduced Defense feature of Amethyst is disabled due to a lot of bugs
!!UN:C7722144/(UNC_INT)/1627159939;
!!UN:C7722148/(UNC_INT16)/2164;

!!UN:C4465379/(UNC_INT)/1969289347;
!!UN:C4465383/(UNC_INT8)/17;

; Rebirth
; The original Rebirth feature of Amethyst is disabled as it blocks Stack Exp rebirth feature
!!UN:C7725320/4/2201255553;
!!UN:C4624568/4/1465;
!!UN:C4624591/4/375193;

***********************************
**** Set up custom spell buffs ****
***********************************
// On Resetting a custom buff
!?FU(tum_OnResetSpellFromStack);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/(UNC_INT)/?(spell:y);

// Prevent a few custom buffs to be removed
!!if&(spell)>=(SPELL_UNDEAD)/(spell)<=(SPELL_INFERNO_REINFORCEMENTS);
  !!SN:X?t/0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/(UNC_INT)/4474299;

!!el|(spell)=(SPELL_SPELL_JAMMER)/(spell)=(SPELL_VENDETTA);
  ; Get stack Id
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(esi:y);
  !!UN:C(esi)/244/(UNC_INT)/?(side:y) C(esi)/248/(UNC_INT)/?(stackOfSide:y);
  !!VR(stack:y):S(side) *(BATTLE_STACKS_PER_SIDE) +(stackOfSide);

  // Restore spells if Spell Jammer
  !!if&(spell)=(SPELL_SPELL_JAMMER);
    !!BM(stack):Ei^tum_spellJammerSpells_%(stack)^;
    !!VRi^tum_spellJammerSpells_%(stack)^:S0;

  // Reduce stats if it is Vendetta
  !!el&(spell)=(SPELL_VENDETTA);
    !!if|i^tum_vendettaAtk_%(stack)^>0/i^tum_vendettaMaxDmg_%(stack)^>0;
      !!BM(stack):A?(atk:y) U2/?(maxDmg:y);
      !!VR(atk):-i^tum_vendettaAtk_%(stack)^ F0/(INT_MAX);
      !!VR(maxDmg:y):-i^tum_vendettaMaxDmg_%(stack)^ F0/(INT_MAX);
      !!BM(stack):A(atk) U2/(maxDmg);
    !!en;
  !!en;
!!en;

// Set up custom spell buff text and icons
!?FU(OnAfterErmInstructions);
; Dynamic Changes - restore at needed timing of the battle
; Store the original descriptions of adventure spells
!!re (spell:y)/(SPELL_UNDEAD)/(SPELL_VENDETTA);
  !!co&(spell)>=3/(spell)<=4;

  !!SN:H^spell^/(spell)/(SPELL_TEXT_NAME)/?s^tum_customBuffName%(spell)^;
  !!SN:H^spell^/(spell)/(SPELL_TEXT_DESCR)/?s^tum_customBuffDesc%(spell)^;
!!en;

; Static changes- spell names and descriptinos would be preserved for the whole game
; Change the spell name and descroptions of after hit abilities, they won't be shown anywhere in the game except for buff icons in this mod
; Don't use Spell 80 (Acid Breath) as the name of the spell would be displayed in battle log
; Disable as we don't want to mess up stack exp ability names
!!re (spell)/(SPELL_AIR_MARK)/(SPELL_EARTH_MARK);
  !!SN:T^tumr.str.spellName%(spell)^/?(name:z);
  !!SN:H^spell^/(spell)/(SPELL_TEXT_NAME)/^%(name)^;
  !!SN:T^tumr.str.spellDesc%(spell)^/?(desc:z);
  !!SN:H^spell^/(spell)/(SPELL_TEXT_DESCR)/^%(desc)^;
!!en;

; Set the spell target for them to be displayed as positve/negative buff. This won't affect the actual effect of it
!!SS(SPELL_DEAFEN):O-1;
!!SS(SPELL_SPELL_JAMMER):O-1;
!!SS(SPELL_FLAMMABLE_COAT):O-1;
!!SS(SPELL_VENDETTA):O1;
*!SS(SPELL_AIR_MARK):O-1;

!?FU(OnSetupBattlefield)&i^battle_isVisible^;
!!FU(tum_ManageCustomBuffs):P1;

; Warning: It is possible to have i^battle_isVisible^ become FALSE during the battle if finishing the battle with Q
; Must be at OnBeforeBattleResult to be compatible with Eagle Eye I (learn spell)
!?FU(tum_OnBeforeBattleResult)&i^tum_customBuffActive^;
!!FU(tum_ManageCustomBuffs):P0;

!?FU(tum_ManageCustomBuffs);
!#VA(mode:x);                           [0 for restoring, 1 for setting]

!!re (spell:y)/(SPELL_UNDEAD)/(SPELL_VENDETTA);
  !!co&(spell)>=3/(spell)<=4;

  !!if&(mode)=0;
    !!SN:H^spell^/(spell)/(SPELL_TEXT_NAME)/s^tum_customBuffName%(spell)^;
    !!SN:H^spell^/(spell)/(SPELL_TEXT_DESCR)/s^tum_customBuffDesc%(spell)^;
    !!VR(frameInd:y):S(spell) +1;
    !!SN:R^Spellint.def:0_%(frameInd).png^/^^;
    !!VRi^tum_customBuffActive^:S(FALSE);
  !!el;
    !!SN:T^tumr.str.spellName%(spell)^/?(name:z);
    !!SN:H^spell^/(spell)/(SPELL_TEXT_NAME)/^%(name)^;
    !!SN:T^tumr.str.spellDesc%(spell)^/?(desc:z);
    !!SN:H^spell^/(spell)/(SPELL_TEXT_DESCR)/^{%(name)}%T(tumr.str.endl)%T(tumr.str.endl)%(desc)^;
    !!VR(frameInd):S(spell) +1;
    !!SN:R^SpellInt.def:0_%(frameInd).png^/^Data\defs\customBuffs\0_%(frameInd).png^;
    !!VRi^tum_customBuffActive^:S(TRUE);
  !!en;
!!en;

!?FU(tum_OnBeforeSpellBookDlgCreate);
!!FU(tum_ManageCustomBuffs):P0;

!?FU(tum_OnAfterSpellBookDlgDestroy);
!!FU(tum_ManageCustomBuffs):P1;

*****************************
**** Object Replacements ****
*****************************
; Generate Andruids's The Rat Mod dwellings and Carpet Seller
; This script works in non-random maps only
!?FU(tum_OnIterateAllMapObjects)&i^tum_isRandMap^<>(TRUE);
!#VA(x:x) (y:x) (z:x);
!#VA(objType:x);
!#VA(objSubtype:x);
!#VA(isYellowSquare:x); boolean.
!#VA(isPassable:x);     boolean.

; check: is entry to the object
!!FU&(isYellowSquare)<>(TRUE):E;

; init var replacement
!!VR(replace:y):S(FALSE);

; Check object type
; Dwellings - type 1
!!if|(objType)=(OBJ_ALTAR_OF_SACRIFICE)/(objType)=(OBJ_DEN_OF_THIEVES)/(objType)=(OBJ_RALLY_FLAG)/(objType)=(OBJ_SANCTUARY);
  !!VR(random:y):R0/0/99;

  !!if&(random)<12;
    !!VR(replace):S(TRUE);

    !!VR(objType):S(OBJ_CREATURE_GENERATOR_1);

    !!if&(random)<3;
      !!VR(objSubtype):S(OBJ_NETHER_GATE);
    !!el&(random)>=3/(random)<6;
      !!VR(objSubtype):S(OBJ_FACELESS_IDOL);
    !!el&(random)>=6/(random)<9;
      !!VR(objSubtype):S(OBJ_ALCHEMIC_PLANT);
    !!el&(random)>=9/(random)<12;
      !!VR(objSubtype):S(OBJ_RAVEN_SUMMIT);
    !!en;
  !!en;

; Dwellings - type 4
!!el|(objType)=(OBJ_TAVERN); (objType)=(OBJ_FAERIE_RING)/(objType)=(OBJ_SWAN_POND)/(objType)=(OBJ_TEMPLE);
  !!VR(random):R0/0/99;

  !!if&(random)<15;
    !!VR(replace):S(TRUE);
    !!VR(x):+1;

    !!VR(objType):S(OBJ_CREATURE_GENERATOR_4);
    !!VR(objSubtype):S(OBJ_SEWER_ENTRANCE);
  !!el&(random)>=15/(random)<30;
    !!VR(replace):S(TRUE);
    !!VR(x):+1;

    !!VR(objType):S(OBJ_CREATURE_GENERATOR_1);
    !!VR(objSubtype):S(OBJ_CARPET_SELLER);
  !!en;
!!en;

; exit if not searchable types
!!FU&(replace)<>(TRUE):E;

; Make sure x is not out of boundary
!!UN:X?(size:y)/?(isDoubleLevel:y);
!!FU&(x)>(size):E;

; delete current and create a new object
!!UN:O(x)/(y)/(z)/1/0; 
!!UN:I(x)/(y)/(z)/(objType)/(objSubtype)/0;

; Temporarily change the level of Rats so they won't results in glitches (and also costs gold to be recruited)
!?OB(OBJ_CREATURE_GENERATOR_4)/5;
!!MA:L(MON_RAT)/1;
!!MA:L(MON_BATTLE_RAT)/1;

!$OB(OBJ_CREATURE_GENERATOR_4)/5;
!!MA:L(MON_RAT)/0;
!!MA:L(MON_BATTLE_RAT)/0;

******************************
**** New Hero Specialties ****
******************************
; Only some of campaign/special heroes have new specs
; Ensure creature specialists are type 4 to avoid ACM/TUM lines
!?FU(OnAfterErmInited);
; Monster specs
; Warning: Forgot why Roland was on ! # ... some wog/era scripts? Or was it for ACM?
!!HE(HERO_KILGOR):X4/(MON_BEHEMOTH);
!!HE(HERO_ROLAND):X1/(MON_PIKEMAN);
!!HE(HERO_XERON):X4/(MON_DEVIL);

; Roland specialty picture
!!UN:G2/(HERO_ROLAND)/3/159;

; Updated text descriptions
!!UN:P300/?(fourthUpg:y);

; Kilgor
!!SN:H^monname^/(MON_BEHEMOTH)/1/?(monName1:z);
!!SN:H^monname^/(MON_ANCIENT_BEHEMOTH)/1/?(monName2:z);
!!SN:H^monname^/(MON_GHOST_BEHEMOTH)/1/?(monName3:z);

!!if&(fourthUpg)=0;
  !!SN:T^tumr.str.specMon0^/?(monDesc:z)/^mon1^/(monName1)/^mon2^/(monName2)/^mon3^/(monName3);
!!el;
  !!SN&(fourthUpg):H^monname^/(MON_SPECTRAL_BEHEMOTH)/1/?(monName4:z);
  !!SN:T^tumr.str.specMon1^/?(monDesc)/^mon1^/(monName1)/^mon2^/(monName2)/^mon3^/(monName3)/^mon4^/(monName4);
!!en;

!!SN:T^tumr.str.specEnd0^/?(endDesc:z)/^stat^/10;
!!SN:T^tumr.str.specDesc^/?(desc:z)/^mon^/(monDesc)/^atk^/5/^def^/5;
!!VR(desc):+(endDesc);
!!SN:H^spec^/(HERO_KILGOR)/2/(desc);

; Xeron
!!SN:H^monname^/(MON_DEVIL)/1/?(monName1);
!!SN:H^monname^/(MON_ARCH_DEVIL)/1/?(monName2);
!!SN:H^monname^/(MON_HELL_BARON)/1/?(monName3);

!!if&(fourthUpg)=0;
  !!SN:T^tumr.str.specMon0^/?(monDesc)/^mon1^/(monName1)/^mon2^/(monName2)/^mon3^/(monName3);
!!el;
  !!SN&(fourthUpg):H^monname^/(MON_ANTICHRIST)/1/?(monName4:z);
  !!SN:T^tumr.str.specMon1^/?(monDesc)/^mon1^/(monName1)/^mon2^/(monName2)/^mon3^/(monName3)/^mon4^/(monName4);
!!en;

!!SN:T^tumr.str.specEnd1^/?(endDesc)/^stat^/1;
!!SN:T^tumr.str.specDesc^/?(desc)/^mon^/(monDesc)/^atk^/4/^def^/2;
!!VR(desc):+(endDesc);
!!SN:H^spec^/(HERO_XERON)/2/(desc);

; Special specs for Lord Haart and Mutare Drake
!!HE(HERO_LORD_HAART_2):X7/0/0/0/0/0/0;
!!HE(HERO_MUTARE_DRAKE):X7/0/0/0/0/0/0;

!!UN:G2/(HERO_LORD_HAART_2)/3/353;
!!SN:T^tumr.str.spec%(HERO_LORD_HAART_2)^/?(desc:z);
!!SN:H^spec^/(HERO_LORD_HAART_2)/2/(desc);

!!UN:G2/(HERO_MUTARE_DRAKE)/3/353;
!!SN:T^tumr.str.spec%(HERO_MUTARE_DRAKE)^/?(desc);
!!SN:H^spec^/(HERO_MUTARE_DRAKE)/2/(desc);

; Set up new specialties on the battlefield
!?FU(OnBeforeBattleUniversal);
!!VRi^tum_specMonUpdateRequired^:S(FALSE);

; Warning: i^battle_isVisible^ can be false positive OnAfterTacticsPhase
; Just never show battle log in OnAfterTacticsPhase, same as other cosmetics
!?FU(OnBattleRound)&i^battle_round^=0;
!!re i/(BATTLE_LEFT)/i^battle_hero_vs_hero^;
  !!if|i^battle_hero_%i^=(HERO_LORD_HAART_2)/i^battle_hero_%i^=(HERO_MUTARE_DRAKE);
    ; Next if the specialty has been changed for some reason (Mortal Heores)
    !!HEi^battle_hero_%i^:X?(param1:y)/?(param2:y)/?(param3:y);
    !!co|(param1)<>7/(param2)<>0/(param3)<>0;

    !!FU(NewIntArray)&i^battle_isVisible^:P?(affectedStacksList:y);

    !!VRi^tum_specMonUpdateRequired^:S(TRUE);
    !!VR(hero:y):Si^battle_hero_%i^;

    !!if&(hero)=(HERO_LORD_HAART_2);
      !!VR(combinedFlags:y):S(MON_FLAG_UNDEAD) +(MON_FLAG_NO_MORALE);
    !!el&(hero)=(HERO_MUTARE_DRAKE);
      !!VR(combinedFlags):S(MON_FLAG_DRAGON) +(MON_FLAG_WIDE_ATTACK);
    !!en;

    !!if&i=(BATTLE_LEFT);
      !!VR(startStack:y):S(BATTLE_ATTACKER_STACK_FIRST);
    !!el;
      !!VR(startStack):S(BATTLE_DEFENDER_STACK_FIRST);
    !!en;

    !!VR(endStack:y):S(startStack) +20;

    !!re j/(startStack)/(endStack);
      ; Skip if no monster
      !!BMj:T?(type:y) N?(num:y);
      !!co|(type)<=(NO_MON)/(num)<=0;

      ; Skip if monster is not valid
      !!FU(tum_CheckIfMonsterIsValid):P(type)/?(result:y);

      ; Skip if not living for Mutare Drake
      !!BMj:F?(flags:y);
      !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);
      !!co&(hero)=(HERO_MUTARE_DRAKE)/(isAlive)=0;

      ; Skip if not living nor undead for Lord Haart
      !!if&(hero)=(HERO_LORD_HAART_2)/(isAlive)=0;
        !!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);
        !!co&(isUndead)=0;
      !!en;

      ; Get monster level
      !!MA:L(type)/?(level:y);

      ; Lord Haart: All the living, non-undead monsters become Undead, damage +1, health +10%, and speed +1
      !!if&(hero)=(HERO_LORD_HAART_2)/(level)>3;
        ; Turn to Undead if not
        !!if&(isAlive);
          !!BMj:Fd|(combinedFlags) Fd~(MON_FLAG_ALIVE) G(BMG_FIELD_MORALE)/0/d;

          !!if&i^battle_isVisible^;
            !!BMj:M(SPELL_UNDEAD)/1000/(SKILL_NOT_LEARNED);
            !!FU(Array_Push):P(affectedStacksList)/j;
          !!en;
        !!en;

        ; Additional stats for Undead
        !!BMj:U1/d1 U2/d1;

        ; Hp
        !!BMj:H?(hp:y);
        !!VR(newHp:y):S(hp) :20 +(hp);
        !!BMj&(newHp)>(hp):H(newHp);
        ; Speed is added in FU(tum_BattleStack_InitParams)

      ; Mutare Drake: all the living, non-dragon, non-Attack all around monsters become dragons, learns breath
      !!el&(hero)=(HERO_MUTARE_DRAKE)/(level)<=3;
        !!VR(isDragon:y):S(flags) &(MON_FLAG_DRAGON);

        !!if&(isDragon)=0;
          !!VR(hasAttacksAllAround:y):S(flags) &(MON_FLAG_ATTACKS_ALL_AROUND);

          !!if&(hasAttacksAllAround)=0;
            !!BMj:Fd|(combinedFlags);

            !!if&i^battle_isVisible^;
              !!BMj:M(SPELL_DRAGON)/1000/(SKILL_NOT_LEARNED);
              !!FU(Array_Push):P(affectedStacksList)/j;
            !!en;
          !!en;
        !!en;
      !!en;
    !!en;

    !!if&i^battle_isVisible^;
      !!SN:M(affectedStacksList)/?(size:y);

      !!if&(size)>0;
        ; Text
        !!HE(hero):B0/?(heroName:z);
        !!SN:T^tumr.str.specBattle%(hero)^/?(battleLog:z)/^hero^/(heroName);
        !!MM:S(battleLog);

        ; Set up animation
        !!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(cmbMgr:y);
        !!UN:C(cmbMgr)/78572/(UNC_INT)/-1;
        ; Play the sound and animation
        !!if&(hero)=(HERO_LORD_HAART_2);
          !!SN:P^MET^;
          !!SN:B6835288/d/^met.def^;
          !!FU(tum_PlayAnimationOnMultipleStacks):P(affectedStacksList)/82;
          !!SN:B6835288/d/^Poof.def^;
        !!el&(hero)=(HERO_MUTARE_DRAKE);
          !!SN:P^dragonS^;
          !!SN:B6837180/d/^dragonS.def^;
          !!FU(tum_PlayAnimationOnMultipleStacks):P(affectedStacksList)/9;
          !!SN:B6837180/d/^C04SPF0.def^;
        !!en;
        ; Reset changes
        !!UN:C(cmbMgr)/78572/(UNC_INT)/-1;
      !!en;
    !!en;
  !!en;
!!en;

; i^tum_specMonUpdateRequired^ is for making sure this take place after FU(OnBattlefieldVisible)
; Currently this script works for Lord Haart only
; It has two effects:
; 1. Give +1 speed to all the Uundead/Living creatures with level greater than 5
; 2. Enhancing all the Undead summons (level greater than 5) after OnSetupBattlefield. Does not turn living units to undead in this phase.
!?FU(tum_BattleStack_InitParams);
!#VA(stackId:x) (side:x);

; Exit if not leading by Lord Haart
!!FU&i^battle_hero_%(side)^<>(HERO_LORD_HAART_2):E;

!!HEi^battle_hero_%(side)^:X?(param1:y)/?(param2:y)/?(param3:y);
!!FU|(param1)<>7/(param2)<>0/(param3)<>0:E;

; Skip if monster is not valid
!!BM(stackId):T?(type:y);
!!FU(tum_CheckIfMonsterIsValid):P(type)/?(result:y);
!!FU&(result)<>(TRUE):E;

; Get the level of the monster
!!MA:L(type)/?(level:y);
!!FU&(level)<=3:E;

; Check the flags
!!BM(stackId):F?(flags:y);
!!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);
!!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);

; For any Undead/Living stack initialization (even before OnSetupBattlefield)
!!if|(isUndead)/(isAlive);
  !!BM(stackId):Sd1;
!!en;

; For Undead only, after the initialization of battle
!!if&(isUndead)/i^tum_specMonUpdateRequired^;
  ; Additional stats for Undead
  !!BM(stackId):U1/d1 U2/d1;

  ; Hp
  !!BM(stackId):H?(hp:y);
  !!VR(newHp:y):S(hp) :20 +(hp);
  !!BM(stackId)&(newHp)>(hp):H(newHp);
!!en;

; Unused script
*!FU&(hero)=(HERO_MUTARE_DRAKE)/(isAlive)=0:E;

; Skip if not living nor undead for Lord Haart
*!if&(hero)=(HERO_LORD_HAART_2)/(isAlive)=0;
  *!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);
  *!FU&(isUndead)=0:E;
*!en;

; Get the level of the monster
*!MA:L(type)/?(level:y);

; Lord Haart: All the living, non-undead monsters become Undead, damage +1, health +5%, and speed +1
*!if&i^battle_hero_%(side)^=(HERO_LORD_HAART_2)/(level)>3;
  *!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);

  ; Turn to Undead if not
  *!if&(isUndead)=0;
    *!VR(combinedFlags:y):S(MON_FLAG_UNDEAD) +(MON_FLAG_NO_MORALE);
    *!BM(stackId):Fd|(combinedFlags) Fd~(MON_FLAG_ALIVE)  G(BMG_FIELD_MORALE)/0/d;

    *!BM(stackId)&i^battle_isVisible^:M(SPELL_UNDEAD)/1000/(SKILL_NOT_LEARNED);
  *!en;

  *!if&(isUndead);
    ; Additional stats for Undead
    *!BM(stackId):U1/d1 U2/d1;

    ; Hp
    *!BM(stackId):H?(hp:y);
    *!VR(newHp:y):S(hp) :20 +(hp);
    *!BM(stackId)&(newHp)>(hp):H(newHp);
  *!en;
; Mutare Drake: all the living, non-dragon, non-Attack all around monsters become dragons, learns breath
*!el&i^battle_hero_%(side)^=(HERO_MUTARE_DRAKE)/(level)<=3;
  *!FU:E;                               [no longer use]

  *!VR(isDragon:y):S(flags) &(MON_FLAG_DRAGON);

  *!if&(isDragon)=0;
    *!VR(hasAttacksAllAround:y):S(flags) &(MON_FLAG_ATTACKS_ALL_AROUND);

    *!if&(hasAttacksAllAround)=0;
      *!VR(combinedFlags:y):S(MON_FLAG_DRAGON) +(MON_FLAG_WIDE_ATTACK);
      *!BM(stackId):Fd|(combinedFlags);

      *!BM(stackId)&i^battle_isVisible^:M(SPELL_DRAGON)/1000/(SKILL_NOT_LEARNED);
    *!en;
  *!en;
*!en;

!?FU(OnBattleReplay);
!!VRi^tum_specMonUpdateRequired^:S(FALSE);

!?FU(OnAfterBattleUniversal);
!!VRi^tum_specMonUpdateRequired^:S(FALSE);

***************************
**** Nerfed Necromancy ****
***************************
; Divide all the necromany value by 2
; Works only when Advanced Classes Mod is disabled
; Currently disabled for securing the compatibility with WoG Scripts Enhanced Artifacts I/II (text)
; We assume that if any Necromancy value is changed, it would be changed in the full catagory (like all the necro SS, all the necro arts desc are changed)
!?FU(OnEveryDay)&i^timerOnce^/i^timerDay^=1/i^Advanced_Classes_Mod_Active^<>(TRUE);
// The script is currently globally disabled
!!VRi^tum_nerfedNecromancy_Disabled^:S(TRUE);
!!FU:E;

; Check if Necromancy option (ERA Scripts) is enabled. If it does, cancel the nerf
!!UN:P881/?(wogOption:y);

!!if&(wogOption);
  !!VRi^tum_nerfedNecromancy_Disabled^:S(TRUE);
  !!FU:E;
!!en;

; Secondary Skill
!!re i/(SKILL_BASIC)/(SKILL_EXPERT);
  !!SN:H^secskill^/(SKILL_NECROMANCY)/i/?(desc:z);
  !!VR(rate:y):Si *10;
  !!FU(tum_SetDividedNecromancyDesc):P(desc)/(rate)/?(newDesc:z);

  !!if&(newDesc)<>^^;
    !!SN:H^secskill^/(SKILL_NECROMANCY)/i/(newDesc);
  !!el;
    !!VRi^tum_nerfedNecromancy_Disabled^:S(TRUE);

    !!FU:E;
  !!en;
!!en;

; Artifacts
!!re i/(ART_AMULET_OF_THE_UNDERTAKER)/(ART_DEAD_MANS_BOOTS);
  !!SN:H^art^/i/1/?(desc);
  !!VR(rate):Si -(ART_AMULET_OF_THE_UNDERTAKER) +1 *5;
  !!FU(tum_SetDividedNecromancyDesc):P(desc)/(rate)/?(newDesc);

  !!if&(newDesc)<>^^;
    !!SN:H^art^/i/1/(newDesc);
  !!el;
    !!VRi^tum_nerfedNecromancy_Disabled^:S(TRUE);
  !!en;
!!en;

!?FU(OnGameEnter)&i^Advanced_Classes_Mod_Active^<>(TRUE)/i^tum_nerfedNecromancy_Disabled^<>(TRUE);
; Change the Necromancy rate of Soul Prism to 0.4 (as it would be divided by 2 later)
!!UN:C5128477/2/1/176;

; Building - Necromancy Amplifier
!!UN:C6977844/4/?(ptr:y);
!!SN:B(ptr)/d/?(desc:z);
!!FU(tum_SetDividedNecromancyDesc):P(desc)/10/?(newDesc:z);
!!SN&(newDesc)<>^^:B(ptr)/d/(newDesc);

; Here we assume all the percentage is belowe 100% (max at 2 characters for the number)
; We also assume that there is the first % we found is next to the number we needed
!?FU(tum_SetDividedNecromancyDesc);
!#VA(descPtr:x) (number:x) (newDescPtr:x);

!!VR(newDescPtr):Z^^;
!!VR(numberStr:z):S^%(number)^;
!!SN:K(numberStr)/?(numberSize:y);
!!SN:Kz(descPtr)/?(size:y);

!!re i/0/(size)/1/-1;
  !!SN:Kz(descPtr)/i/?(character:z);

  !!if&(character)=^%^;
    !!VR(numbersInSentence[2]:y):C0/0;
    !!VR(index:y):Si -1;

    !!SN:Kz(descPtr)/(index)/?(character);
    !!FU(tum_CheckIfCharacterIsNumber):P(character)/?(result:y);

    !!if&(result);
      !!VR(numbersInSentence[1]):V(character);

      !!if&(numberSize)>1;
        !!VR(index): -1;
        !!SN:Kz(descPtr)/(index)/?(character);
        !!FU(tum_CheckIfCharacterIsNumber):P(character)/?(result:y);
        !!VR(numbersInSentence[0])&(result):V(character);
      !!en;

      ; Two character number
      !!if&(numberSize)>1/(result);
        !!VR(numbersInSentenceStr:z):S^%(numbersInSentence[0])%(numbersInSentence[1])^;
      ; One character number
      !!el;
        !!VR(numbersInSentenceStr):S^%(numbersInSentence[1])^;
      !!en;

      !!VR(numbersInSentenceFinal:y):V(numbersInSentenceStr);
      
      ; If the number before % is the same with the number provided, divide it by 2
      !!if&(number)=(numbersInSentenceFinal);
        !!VR(numberFloat:e):S(number);
        !!VR(numberFloat)::2;
        !!VR(numberStr):S^%(numberFloat)^;
        !!FU(tum_OptimiseFloatNumberString):P(numberStr)/?(numberStr);

        *!VR(index:y):-1;

        !!FU(Substr):Pz(descPtr)/0/(index)/?(str1:z);
        !!VR(lastInd:y):S(size) -1;
        !!FU(Substr):Pz(descPtr)/i/(lastInd)/?(str2:z);

        !!VR(newDesc:z):S^%(str1)%(numberStr)%(str2)^;
        !!VR(newDescPtr):Z(newDesc);

      ; Exit if the number before % is differnt from the number provided (this means Necromancy has already been customised)
      !!el;
        !!FU:E;
      !!en;

    ; Exit the function if the character before % is not even a number (something's seriously wrong)
    !!el;
      !!FU:E;
    !!en;

    !!br;
  !!en;
!!en;

!?FU(tum_CheckIfCharacterIsNumber);
!#VA(charPtr:x) (result:x);

!!VR(result):S(FALSE);

!!re i/0/9;
  !!br&z(charPtr)=^%i^;
!!en;

!!VR(result)&i<=9:S(TRUE);

!?FU(tum_OptimiseFloatNumberString);
!#VA(strPtr:x) (result:x);

!!VR(result):Z^^;
!!SN:Kz(strPtr)/?(size:y);
!!VR(pointPos:y):S0;

!!re i/0/(size)/1/-1;
  !!SN:Kz(strPtr)/i/?(character:z);

  !!VR(pointPos)&(character)=^.^:Si;

  ; If 0 is found, check if it is the first character after decimal point
  !!if&(pointPos)>0/(character)=^0^;
    !!VR(difference:y):Si -(pointPos);
    !!VRi&(difference)=1:-1;

    !!br;
  !!en;
!!en;

!!if&i<(size);
  !!FU(Substr):Pz(strPtr)/0/i/?(newStr:z);
  !!VR(result):Z(newStr);
!!en;

; Divide the power of Necromancy by 2
!?FU(tum_OnCalcNecromancyPower)&i^Advanced_Classes_Mod_Active^<>(TRUE)/i^tum_nerfedNecromancy_Disabled^<>(TRUE);
!#VA(hook:x);

; Get current power
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/-4/4/?(power:y);

; Get the latest power in float
!!SN:X?t X(power) X?(powerFloat:e) Xt;  [get fct parameters]
!!VR(powerFloat)::2;
!!SN:X?t X(powerFloat) X?(power) Xt;    [get fct parameters]

; Set
!!UN:C(ebp)/-4/4/(power);

***************************************
**** Set Up additional battle hint ****
***************************************
; For both new monsters and artifacts
!?FU(OnStackToStackDamage)&i^battle_isVisible^/i^battle_localHuman_%i(battle_current_side)^;
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU&(isTheoretical)<>(TRUE):E;

!!VRs^tum_extraBattleMonMouseHint^:S^^;
!!VRs^tum_extraBattleArtMouseHint^:S^^;

!?FU(OnBattleMouseHint)|s^tum_extraBattleMonMouseHint^/s^tum_extraBattleArtMouseHint^;
!!if&i^mouse_battleHex^>=1/i^mouse_battleHex^<=185/i^battle_localHuman_%i(battle_current_side)^;
  !!BU:Ei^mouse_battleHex^/?(stack:y);

  !!if&(stack)>(NO_STACK);
    !!MM:M?(hint:z);
    !!VR(hint)&s^tum_extraBattleMonMouseHint^:+^  {~Chartreuse}%s(tum_extraBattleMonMouseHint){~}^;
    !!VR(hint)&s^tum_extraBattleArtMouseHint^:+^  {~Yellow}%s(tum_extraBattleArtMouseHint){~}^;
    !!MM:M(hint);
  !!en;
!!en;

!!VRs^tum_extraBattleMonMouseHint^:S^^;
!!VRs^tum_extraBattleArtMouseHint^:S^^;

********************************************
**** Set Up custom spell mouse variable ****
********************************************
; For new monsters
; Disable new monster spell casting if either ctrl or shift or Altis pressed
!?FU(OnBattleMouseHint);
!!FU(tum_SetUpCustomSpellMouseVariable):P1;

!?FU(OnBattleScreenMouseClick);
!!FU(tum_SetUpCustomSpellMouseVariable):P2;

!?FU(tum_SetUpCustomSpellMouseVariable);
!#VA(mode:x);

!!VRi^tum_customSpellActive^:S(FALSE);

; Do not check &999 here, it means OW:C?y1/?y2 y1=y2
!!if&i^mouse_battleHex^>=1/i^mouse_battleHex^<=185/i^key_ctrl^<>(TRUE)/i^key_shift^<>(TRUE)/i^battle_localHuman_%i(battle_current_side)^;
  !!OW:C?(player:y)/?(interactPlayer:y);
  !!VRi^tum_customSpellActive^:S(TRUE);
!!en;

; Restore mouse cursor to default if Ctrl or Shift is pressed
; This is for restoring mouse cursor to default
; Note that alt should not be universal as it could conflict with igrik's battle action switcher
!?FU(OnKeyPressed_Battle)|i^key^=(KEY_CONTROL)/i^key^=(KEY_SHIFT);
!!FU&i^key_down^<>(TRUE):E;

!!if&i^battle_localHuman_%i(battle_current_side)^;
  !!UN:C(COMBAT_MANAGER)/4/?(cmbMgr:y);
  !!SN:E4684800/(CALLCONV_THISCALL)/(cmbMgr); [(recalc all stack properies ) -makes all the game needs]
  !!SN:E4797616/(CALLCONV_THISCALL)/(cmbMgr)/0/1; [redraw grid]
!!en;

!?FU(OnKeyReleased_Battle)|i^key^=(KEY_CONTROL)/i^key^=(KEY_SHIFT);
!!FU(OnBattleMouseHint):P;

***************************************************************************************
**** New Creatures * New Creatures * New Creatures * New Creatures * New Creatures ****
***************************************************************************************
// Regeneration
; Requires ERA 3.9.12 to work
!?FU(OnBattleStackRegeneration);
!#VA(stackId:x) (finalValue:x) (stdValue:x);

!!BM(stackId):T?(type:y);

!!if|(type)=(MON_SPECTRE)/(type)=(MON_NIGHTMARE_HYDRA);
  !!VR(finalValue):S(stdValue);
!!el|(type)=(MON_TROLL_HAG)/(type)=(MON_TROLL_WITCH)/(type)=(MON_RAVENOUS_CORTATRICE);
  !!VR(finalValue):F30/(INT_MAX);
!!el|(type)=(MON_DENDROID_ELDER)/(type)=(MON_DRYAD)/(type)=(MON_DRYAD);
  !!VR(random:y):R0/0/99;
  !!VR(finalValue)&(random)<50:S(stdValue);
!!en;


// Creature spell powers
// Warning: This scirpt assumes that there won't be a second monster spell activaed after a monster spell is casted in action (BG:A)
// All the spell definition here is either friendly spell or damaging spell. Power of other spells are undefined. 
!?FU(tum_CreateERMHook);
!#VA(setHook:x);

!!SN:E(setHook)/1/5898565/(tum_OnCastBattleSpell); 5A0145

!?FU(tum_OnCastBattleSpell)&i^tum_isOnAction^;
!#VA(hook:x);

; Deal with active spell casting by a monster only
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_MONSTER_CAST):E;

; Double check
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/16/4/?(casterKind:y);
!!FU&(casterKind)<>1:E;

; Exit if it is a commander or Santa
!!BMi^battle_acting_stack^:T?(type:y); [Here we assume the caster is the current creature]
!!FU&(type)>=(MON_COMMANDER_FIRST_A)/(type)<=(MON_COMMANDER_LAST_D):E;
!!FU&(type)=(MON_SANTA_GREMLIN):E;

; Get the spell
!!UN:C(ebp)/8/4/?(spell:y);

; Check the detials of the spell, exit if not a spell with duration and not a damaging spell
!!SS(spell):F?(flags:y);
!!VR(hasDuration:y):S(flags) &4;
!!VR(isDmgSpell:y):S(flags) &512;

!!if|(hasDuration)/(isDmgSpell)/(spell)=(SPELL_CURE); [Cure: Currently for Dryads and Plague Doctors]
  ; If it is a buff spell, it should only be a friendly spell
  !!if&(hasDuration);
    !!SS(spell):O?(targetType:y);
    !!UN&(targetType)=1:C(ebp)/28/4/6;  [6 turns for friendly spell with duration]

  ; If it is a damaging spell, check the spell power
  !!el&(isDmgSpell);
    !!FU(tum_GetMonDamageSpellPower):P(type)/?(power:y); [power based on type/number of the caster]
    !!BMi^battle_acting_stack^:N?(num:y);
    !!VR(totalPower:y):S(power) *(num);
    !!UN:C(ebp)/28/4/(totalPower);

  ; If it is cure, check spell power as well
  !!el&(spell)=(SPELL_CURE);            [2 times of power for Cure (10 HP regen per unit)]
    !!FU(tum_GetMonCurePower):P(type)/?(power:y);
    !!UN:C(ebp)/28/4/d*(power);
  !!en;
!!en;

!?FU(tum_GetMonDamageSpellPower);
!#VA(mon:x) (result:x);

!!VR(result):S1;
!!VR(result)&(mon)=(MON_PRIMAL_FAERIE_DRAGON):S10;

!?FU(tum_GetMonCurePower);
!#VA(mon:x) (result:x);

!!VR(result):S2;
!!VR(result)&(mon)=(MON_OAK_DRYAD):S3;


// Custom hatred
!?FU(OnStackToStackDamage);
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!BM(atkStack):T?(atkMon:y);
!!BM(defStack):T?(defMon:y);
!!FU(tum_CheckCustomHatredBonus):P(atkMon)/(defMon)/?(bonus:y);

!!if&(bonus)>0;
  !!VR(hatredDmg:y):S(basicDmg) *(bonus) :100;

  !!if&(hatredDmg)>0;                   [overflow check]
    !!VR(newfinalDmg:y):S(finalDmg) +(hatredDmg);

    !!if&(newfinalDmg)>(finalDmg);      [overflow check]
      !!VR(finalDmg):S(newfinalDmg);
    !!en;
  !!en;

  ; Display battle log (even if the damage wan't applied due to overflow)
  !!if&(isTheoretical)<>(TRUE);
    !!BM(defStack):N?(defNum:y);
    !!VR(isPlural:y):S(defNum) -1 B;
    !!SN:H^monname^/(defMon)/(isPlural)/?(defMonName:z);
    !!BM(atkStack):N?(atkNum:y);
    !!VR(isPlural):S(atkNum) -1 B;
    !!SN:H^monname^/(atkMon)/(isPlural)/?(atkMonName:z);
    !!SN:T^tumr.str.hatred%(isPlural)^/?(battleLog:z)/^atkMon^/(atkMonName)/^defMon^/(defMonName);
    !!MM:S(battleLog);
  !!en;
!!en;

; Define Hatred here
!?FU(tum_CheckCustomHatredBonus);
!#VA(mon1:x) (mon2:x) (bonus:x);

!!VR(bonus):S0;

!!if|(mon1)=(MON_MONK)/(mon1)=(MON_ZEALOT)/(mon1)=(MON_HIGH_PRIEST);
  !!if|(mon2)=(MON_CULTIST)/(mon2)=(MON_CULTIST_LEADER);
    !!VR(bonus):S50;
  !!en;

!!el|(mon1)=(MON_CULTIST)/(mon1)=(MON_CULTIST_LEADER);
  !!if|(mon2)=(MON_MONK)/(mon2)=(MON_ZEALOT)/(mon2)=(MON_HIGH_PRIEST);
    !!VR(bonus):S50;
  !!en;
!!en;


// Ghosts' loss after battle - for human only
; Attract Dead Souls users lose 50% of quantity increase (if they got any) at the end of battle
!?FU(OnSetupBattlefield)&(ERM_FLAG_IS_HUMAN);
!!SN:Mi^tum_soulAttractersList^;
!!FU(NewIntArray):P42/?i^tum_soulAttractersList^/(M_TEMP);

!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!BMi:N?(num:y);

  !!if&(num)>0;
    !!BMi:T?(type:y);
    !!FU(tum_CheckIfMonAttractsDeadSouls):P(type)/?(result:y);

    !!SN&(result):Mi^tum_soulAttractersList^/i/(num);
  !!en;
!!en;

; Release the array if no ghost found
!!SN:Mi^tum_soulAttractersList^/?(size:y);

!!if&(size)=0;
  !!SN:Mi^tum_soulAttractersList^;
  !!VRi^tum_soulAttractersList^:S0;
!!en;

!?FU(tum_OnBeforeBattleResult)&i^tum_soulAttractersList^/(ERM_FLAG_IS_HUMAN);
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!BMi:N?(num:y);

  !!if&(num)>0;
    !!BMi:T?(type:y);
    ; Check mon type, in case they were converted to Lycan, etc. Assuming that no monster should become Soul Attractor during the battel
    !!FU(tum_CheckIfMonAttractsDeadSouls):P(type)/?(result:y);

    !!if&(result);
      !!SN:Mi^tum_soulAttractersList^/i/?(initNum:y);

      ; General fix for Attract Dead Souls - set the initial number after battle, make it the same as before battle
      ; Is it?
      !!BMi:B(initNum);

      !!if&(num)>(initNum);      
        !!VR(maxNum:y):S(num) -(initNum) :2 +(initNum);
        !!BMi:N(maxNum);
      !!en;
    !!en;
  !!en;
!!en;

; Release the array
!!SN:Mi^tum_soulAttractersList^;
!!VRi^tum_soulAttractersList^:S0;

!?FU(tum_CheckIfMonAttractsDeadSouls);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_GHOST):S(TRUE);
!!VR(result)&(mon)=(MON_SHADOW_DRAGON):S(TRUE);


// Werewolves' Lycanthropy and Sphinx's Transmutation
; Transmute the victim, a living creature stack into a mad mummy after attack!
; Disable Werewolves' ability and recreate here, as my script is better
; Warning: This ability currenlt works in non-quick combat only. For some reason, the summoned stack (with BU:S) doens't count as part of exp gain for some reason
!?FU(OnGameEnter);
!!UN:C7762908/(UNC_INT)/9999;

!?FU(tum_OnAfterMelee)&i^battle_isVisible^;
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkNum)>0/(defNum)>0;
  !!BM(atkStack):T?(atkMon:y);
  !!BM(defStack):T?(defMon:y);

  ; Deal with Werewolf's Berserk on Full Moon - this part does not summon stacks
  !!if&(atkMon)=(MON_WEREWOLF)/i^battle_acting_stack^=(atkStack)/i^timerMonthDay^>=14/i^timerMonthDay^<=16;
    !!FU(tum_Battle_CanStackReceiveSpell):P(atkStack)/(SPELL_BERSERK)/i^battle_acting_side^/?(canReceive:y);
    !!BM(atkStack)&(canReceive):P?(pos:y) C(SPELL_BERSERK)/(pos)/(SKILL_NOT_LEARNED)/2/(TRUE);
  !!en;

  ; Check if the attacker has a chance of Transmutation/defender is not immune
  !!FU(tum_CheckMonTransmutationDetails):P(atkMon)/?(chance:y)/?(victimType:y)/?(victimHp:y)/?(victimMaxLv:y);

  !!if&(chance)>0;
    ; Fix victim type and victim HP in case they are wrong
    !!if&(victimType)=(NO_MON);
      !!FU(tum_GetRandomMonster):P?(victimType);
      !!MA:P(victimType)/?(victimHp);
      !!VR(victimHp): *4 :5 F1/(INT_MAX);[80% HP]
    !!en;

    ; Exit if it is not possible to summon more stacks for the defender
    ; This is not needed as we wiped the victim's stack completely, there is always a vacancy
    *!BM(defStack):I?(defSide:y);
    *!FU(tum_CheckIfPossibleToSummonMoreStacks):P(defSide)/?(result:y);
    *!FU&(result)<>(TRUE):E;

    ; Exit if the attacker and the defender is the same type
    !!FU&(atkMon)=(defMon):E;
    !!FU&(atkMon)=(MON_ENTOMBED_SPHINX)/(defMon)=(MON_ASHEN_SPHINX):E;
    !!FU&(atkMon)=(MON_ASHEN_SPHINX)/(defMon)=(MON_ENTOMBED_SPHINX):E;

    ; Exit if the defender is special
    !!FU&(defMon)>=(MON_EMISSARY_OF_WAR)/(defMon)<=(MON_EMISSARY_OF_LORE):E;
    !!FU&(defMon)>=(MON_COMMANDER_FIRST_A)/(defMon)<=(MON_COMMANDER_LAST_D):E;
    !!FU&(defMon)>=(MON_CATAPULT)/(defMon)<=(MON_ARROW_TOWERS):E;

    ; Get a random number and see if lucky
    !!VR(random:y):R0/0/99;

    !!if&(random)<(chance);
      ; Exit if the victim is not a living creature
      !!BM(defStack):F?(flags:y);
      !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);
      !!FU&(isAlive)=(FALSE):E;

      ; Exit if the victim's creature level is too high or is a level 8+ creature
      !!MA:L(defMon)/?(victimLv:y);
      !!FU&(victimLv)>(victimMaxLv):E;

      !!if&(victimLv)=(MON_MAX_LEVEL);
        !!MA:F(MON_BLOOD_DRAGON)/?(bloodDragonFv:y);
        !!MA:F(defMon)/?(defFv:y);
        !!FU&(defFv)>(bloodDragonFv):E;
      !!en;

      ; Exit if the victim has excessive HP
      !!BM(defStack):H?(hp:y) L(lostHp:y);
      !!VR(totalHp:y):S(hp) *(defNum) -(lostHp);
      !!FU&(totalHp)>2000000000:E;

      ; Calculate the creature number after turning
      !!VR(victimNum:y):S(totalHp) :(victimHp) F1/(INT_MAX);

      ; Gather info
      !!BM(defStack):P?(pos:y) I?(defSide:y) O?(slot:y);
      !!VR(isActed:y):S(flags) &(MON_FLAG_ACTED);
      !!FU(NewIntArray):P?(buffsList:y);

      !!re i/(SPELL_FIRST)/(SPELL_LAST_WOG);
        !!BM(defStack):Gi/?(spellDuration:y)/?(spellLevel:y);
        !!FU(Array_Push)&(spellDuration)>0:P(buffsList)/i/(spellDuration)/(spellLevel);
      !!en;

      ; Kill the victim (without a trace)
      !!VR(combiFlags:y):S(MON_FLAG_CLONE) +(MON_FLAG_NO_COLORING) +(MON_FLAG_SUMMONED);
      *!BM(defStack):T(victimType);
      !!BM(defStack):Fd|(combiFlags);
      !!BM(defStack):E0 K1;             [E0 prevent revival]
      !!SN&i^battle_isVisible^:D;

      ; Exit if the victim hasn't been killed for some reason
      !!BM(defStack):N?(defNumNew:y);
      !!FU&(defNumNew)>0:E;

      !!if&i^battle_isVisible^;
        !!VR(atkIsPlural:y):S(atkNum) -1 B;
        !!SN:H^monname^/(atkMon)/(atkIsPlural)/?(atkMonName:z);
        !!VR(defIsPlural:y):S(defNum) -1 B;
        !!SN:H^monname^/(defMon)/(defIsPlural)/?(defMonName:z);
        !!SN:H^monname^/(victimType)/(TRUE)/?(victimName:z);
        !!SN:T^tumr.str.transmutation%(atkIsPlural)^/?(battleLog:z)/^atkMon^/(atkMonName)/^defMon^/(defMonName)/^victim^/(victimName);
        !!MM:S(battleLog);

        !!SN:P^FNGRSUMM^;

        !!if&(atkMon)=(MON_WEREWOLF);
          !!FU(tum_PlayCustomAnimationOnPosition):P(pos)/^C12SPF0^;
        !!el;
          !!FU(tum_PlayCustomAnimationOnPosition):P(pos)/^curse^;
        !!en;
      !!en;

      ; Summon the victim (after transmutation)
      !!VRi^tum_transmuteIsActive^:S(TRUE); [Compatibility with neutral experience option]
      !!BU:S(victimType)/(victimNum)/(pos)/(defSide)/(slot)/(TRUE);

      ; Manage stuff after summoning mummies
      !!BU:E(pos)/?(victimStack:y);

      !!if&(victimStack)>(NO_STACK);
        ; Set the stack exp ability properly
        ; Warning: Just don't! This hack is not comaptible with Battle Replay for some reason, as the stack will keep the stats of transformation creature after replay
        *!UN:P(WOG_OPT_STACK_EXPERIENCE)/?(stackExp:y);

        *!if&(stackExp);
          *!VR(eaStack:y):S(victimStack) +1 *-1;
          *!EA(eaStack):O(victimType);  [Copy the original stack exp of the victim's creature type to the victim's stack]
        *!en;

        ; Cancel retaliation
        !!FU(tum_CancelRetaliation):P(atkStack)/(defStack);

        ; Restore acted flag
        !!BM(victimStack):Fd|(isActed);

        ; Add morale flag to prevent triggering morale event
        !!BM(victimStack):Fd|(MON_FLAG_MORALE);

        ; For Sphinxes only
        !!if|(atkMon)=(MON_ENTOMBED_SPHINX)/(atkMon)=(MON_ASHEN_SPHINX);
          ; For some reason, BM:M/F/R results in broken sound here. Thus we set the volume to 0 temporarily
          !!if&i^battle_isVisible^;
            !!UN:C6916020/4/?(volume:y);
            !!UN:C6916020/4/0;
          !!en;

          ; Additional spell
          !!BM(victimStack):M(SPELL_FRENZY)/2/(SKILL_NOT_LEARNED);

          ; Stun the target if it is <= level 3

          !!if&(victimLv)<=2;
            !!BM(victimStack):Fd|(MON_FLAG_ACTED) R0;
            
            !!if&i^battle_isVisible^;
              !!SN:T^tumr.str.stun%(defIsPlural)^/?(battleLog:z)/^mon^/(victimName);
              !!MM:S(battleLog);

              !!UN:C6916020/4/(volume);

              !!SN:P^SPELLSTUN^;
              !!FU(tum_PlayCustomAnimationOnStack):P(victimStack)/^Stun^;
            !!en;
          !!en;
        !!en;

        ; Restore spell buffs
        !!SN:M(buffsList)/?(size:y);

        !!if&(size)>0;
          !!re i/0/(size)/1/-1;
            !!SN:M(buffsList)/i/?(spell:y);
            !!VRi:+1;
            !!SN:M(buffsList)/i/?(spellDuration);
            !!VRi:+1;
            !!SN:M(buffsList)/i/?(spellLevel);

            !!BM(victimStack):M(spell)/(spellDuration)/(spellLevel);
          !!en;

          !!SN&i^battle_isVisible^:D;
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonTransmutationDetails);
!#VA(mon:x) (chance:x) (victimType:x) (victimHp:x) (victimMaxLv:x);

!!VR(chance):S0;
!!VR(victimType):S(NO_MON);
!!VR(victimHp):S0;

!!if|(mon)=(MON_ENTOMBED_SPHINX)/(mon)=(MON_ASHEN_SPHINX);
  !!VR(chance)&(mon)=(MON_ENTOMBED_SPHINX):S10;
  !!VR(chance)&(mon)=(MON_ASHEN_SPHINX):S20;
  !!VR(victimType):S(MON_MAD_MUMMY);
  !!VR(victimHp):S30;                   [Here we give a little reduction to the original HP so the victim's number would be greater]
  !!VR(victimMaxLv):S5;

!!el&(mon)=(MON_WEREWOLF);
  !!VR(chance):S20;
  !!VR(chance)&i^timerMonthDay^>=14/i^timerMonthDay^<=16:*2;
  !!VR(victimType):S(MON_WEREWOLF);
  !!VR(victimHp):S35;
  !!VR(victimMaxLv):S(MON_MAX_LEVEL);
!!en;

; Compatibility with Neutral Experience option
; For some reason, if you set EA with negative stack Id, the stats of transmuted creture will be the same as before transmuted
; Basically if EA are set after BM, it treats BM values as permanant and will carry over through battle replay
; Any scipt possibly change EA when a stack respawns should be disabled
!?FU5401&i^tum_transmuteIsActive^;
!!VRi^tum_transmuteIsActive^:S(FALSE);
!!SN:Q;


// Mad Mummies' Curse of Delirium
; Pass the Frenzy buff to the enemy after attack with a chance
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkNum)>0/(defNum)>0;
  !!BM(atkStack):T?(type:y);
  !!FU(tum_GetMonCurseOfDeliriumChance):P(type)/?(chance:y);

  !!if&(chance)>0;
    ; Check if the stack still have Frenzy
    !!BM(atkStack):G(SPELL_FRENZY)/?(duration:y)/?(power:y);

    !!if&(duration)>0;
      !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/(chance)/(SPELL_FRENZY)/(power)/?(result:y);
      !!FU(tum_RemoveSpellFromStack)&(result):P(atkStack)/(SPELL_FRENZY);
    !!en;
  !!en;
!!en;

!?FU(tum_GetMonCurseOfDeliriumChance);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_MAD_MUMMY):S25;


// Dracolich and Necross Dragon's Block
; 20% to block (evade) a physical attack
; Disable Dracoliches' Block and recreate here, as my script works better
!?FU(OnGameEnter);
!!UN:C7760528/(UNC_INT)/9999;

!?FU(OnStackToStackDamage);
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

; Skip theoretical (mouse hover)
!!FU&(isTheoretical)=(TRUE):E;

!!BM(defStack):T?(mon:y);
!!FU(tum_GetMonBlockChance):P(mon)/?(chance:y);

!!if&(chance)>0;
  !!VR(random:y):R0/0/99;

  !!if&(random)<(chance);
    !!VR(finalDmg):S0;

    !!if&i^battle_isVisible^;
      !!FU(tum_ShowBlockCosmetics):P(defStack)/(mon);
    !!en;
  !!en;
!!en;

; Restore defence flag if set for animation
!?FU(tum_OnAfterAttack)&i^battle_isVisible^/i^tum_blockingStack^>0;
!!VR(stack:y):Si^tum_blockingStack^ -1;
!!BM(stack):Fd~(MON_FLAG_DEFENDING);
!!VRi^tum_blockingStack^:S0;

; Show cosmetic 
!?FU(tum_ShowBlockCosmetics);
!#VA(defStack:x) (mon:x);

; Show animation and battle log
!!BM(defStack):N?(num:y);
!!VR(isPlural:y):S(num) -1 B;
!!SN:H^monname^/(mon)/(isPlural)/?(monName:z);
!!SN:T^tumr.str.block^/?(battleLog:z)/^mon^/(monName);
!!MM:S(battleLog);

; Set up defence animation (by setting defence flag)
!!BM(defStack):V85 F?(flags:y);
!!VR(isDefending:y):S(flags) &(MON_FLAG_DEFENDING) B;

!!if&(isDefending)<>(TRUE);
  !!VRi^tum_blockingStack^:S(defStack) +1;
  !!BM(defStack):Fd|(MON_FLAG_DEFENDING);
!!en;

; Funciton to check if the targeted monster is eligible for block
!?FU(tum_GetMonBlockChance);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_DRACOLICH):S20;
!!VR(result)&(mon)=(MON_NECROSS_DRAGON):S20;


// Spell after Melee
// Light Templars and Dark Templars, Fire Paladins, Vermillion Birds, Plague Doctors
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):T?(type:y);

!!if&(type)=(MON_CHAOTIC_DRAGON_FLY);
  !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/100/(SPELL_WEAKNESS)/(SKILL_ADVANCED);
!!el|(type)=(MON_PLAGUE_DOCTOR);
  !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/20/(SPELL_DEATH_RIPPLE)/10;
!!el&(type)=(MON_FIRE_PALADIN);
  !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/40/(SPELL_FIREBALL)/10;
!!el&(type)=(MON_VERMILLION_BIRD);
  !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/100/(SPELL_FIREBALL)/10;
*!el&(type)=(MON_FIRE_DRAGON);
  *!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/100/(SPELL_INFERNO)/200/2;
!!el&(type)=(MON_ICE_DRAGON);
  !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/100/(SPELL_ICE_BOLT)/100/1;
!!en;


// Spell after Shooting
// Elite Lizards
!?FU(tum_OnAfterShoot);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):T?(type:y);

!!if&(type)=(MON_ELITE_LIZARD);
  !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/15/71/(SKILL_NOT_LEARNED);
!!el|(type)=(MON_TROLL_WITCH);
  !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/100/(SPELL_SLOW)/(SKILL_ADVANCED);
!!el&(type)=(MON_RATMAN_GRENADIER);
  !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/20/(SPELL_FIREBALL)/10;
!!en;


// Special magic damage resistance (Golem type)
// Everlasting Dragons
!?FU(OnMagicCorrectedResistance);
!!MR:M?(type:y);

; Everlasting Dragons' Dragon Scale
!!if&(type)=(MON_EVERLASTING_DRAGON);
  !!MR:S?(spell:y);

  !!SS(spell):S?(schoolBits:y);
  !!VR(isAirSchool:y):S(schoolBits) &1; [1 - air school]

  !!if&(isAirSchool)=0;
    !!MR:D?(basicDmg:y) F?(fixedDmg:y);
    !!VR(newDmg:y):S(basicDmg) *3 :4;
    !!MR&(newDmg)<(fixedDmg):F(newDmg);
  !!en;
!!en;


// Special Magic resistance (Dwarf type)
!?FU(OnDwarfMagicResistance)&i^tum_%(ART_ORB_OF_VULNERABILITY)_equipped^<>(TRUE);
!!MR:M?(type:y) S?(spell:y);

; Plague Doctor's Death Ripple Immunity
!!if&(type)=(MON_PLAGUE_DOCTOR)/(spell)=(SPELL_DEATH_RIPPLE);
  !!MR:F100;
; Netherbats - immune to Blind
; Andruids: Netherbats, they still use their eyes, so they are vulnerable to petrification.
!!el&(type)=(MON_NETHERBAT)/(spell)=(SPELL_BLIND);
  !!MR:F100;
; Ratman and Ratman Grenadier - immune to Weakness and Disease
!!el|(type)=(MON_RATMAN)/(type)=(MON_RATMAN_GRENADIER);
  !!if|(spell)=(SPELL_WEAKNESS)/(spell)=73; [Disease]
    !!MR:F100;
  !!en;
; Primal Faerie Dragon - Immune to damaging spells
!!el&(type)=(MON_PRIMAL_FAERIE_DRAGON);
  !!SS(spell):F?(flags:y);
  !!VR(isDmgSpell:y):S(flags) &512;
  !!MR&(isDmgSpell):F100;
!!en;


// Holy Champions' Holy Charge
; Damage all the hostile creatures passed by with a percentage of attack damage
; Set up an array at the start of moving
!?FU(OnBeforeBattleAction);
!!BG:A?(action:y);

!!if|(action)=(BATTLE_ACTION_WALK)/(action)=(BATTLE_ACTION_WALK_AND_ATTACK);
  !!BMi^battle_acting_stack^:T?(type:y);
  !!FU(tum_CheckMonHolyChargeDamageRate):P(type)/?(rate:y);

  !!if&(rate)>0;
    !!FU(NewIntArray):P?i^tum_holyChargePosList^/(M_TEMP);
  !!en;
!!en;

; Store every hex the caster passes by
!?FU(tum_OnStackMakesStep)&i^tum_holyChargePosList^;
!#VA(hook:x);

!!UN:C(hook:x)/(STRUCT_HOOK_CONTEXT_EAX)/4/?(hexToGo:y);
!!UN:C(COMBAT_MANAGER)/4/?(cmbMgr:y);

; Disable for now, since it's not used
*!re i/0/5;
  *!VR(offset:y):S6 *(hexToGo) +i *2 +78952;
  *!UN:C(cmbMgr)/(offset)/2/?(adjhex:y);
*!en;

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(stackStruct:y);
!!UN:C(stackStruct)/244/4/?(side:y) C(stackStruct)/248/4/?(sId:y);
!!VR(stackId:y):S(side) *(BATTLE_STACKS_PER_SIDE) +(sId);
!!BM(stackId):P?(pos:y);

!!FU(Array_Push):Pi^tum_holyChargePosList^/(pos);

; Deal with wide units
!!FU(tum_GetStackHeadPosition):P(stackId)/?(pos);
!!FU(Array_Push):Pi^tum_holyChargePosList^/(pos);

; Walk and attack
!?FU(tum_BeforeStackMeleeAttack)&i^tum_holyChargePosList^; [This hook doesn't trigger for retaliation]
!#VA(hook:x);

!!BMi^battle_acting_stack^:N?(num:y);

!!if&(num)>0;
  !!BMi^battle_acting_stack^:P?(pos:y);
  !!FU(Array_Push):Pi^tum_holyChargePosList^/(pos);

  ; Deal with wide units
  !!FU(tum_GetStackHeadPosition):Pi^battle_acting_stack^/?(pos);
  !!FU(Array_Push):Pi^tum_holyChargePosList^/(pos);

  !!FU(Array_SortedUnique):Pi^tum_holyChargePosList^;
  !!SN:Mi^tum_holyChargePosList^/?(size:y);

  !!if&(size)>0;
    !!FU(NewIntArray):P?(affectedStacksList:y);
    !#VA(poses[6]:y);

    !!re i/0/(size)/1/-1;
      ; Check the adjacent hexes of every hexes the caster walked through
      !!SN:Mi^tum_holyChargePosList^/i/?(pos:y);
      !!VR(isOddRow:y):S(pos) :17 %2;

      !!VR(firstPos:y)&(isOddRow):S(pos) -17;
      !!VR(firstPos)&(isOddRow)<>(TRUE):S(pos) -16;

      !!re j/0/5;
        !!if&j=0;
          !!VR(poses[j]):S(firstPos);
        !!el&j=1;
          !!VR(poses[j]):S(pos) +1;
        !!el&j=2;
          !!VR(poses[j]):S(firstPos) +34;
        !!el&j=3;
          !!VR(poses[j]):S(firstPos) +33;
        !!el&j=4;
          !!VR(poses[j]):S(pos) -1;
        !!el;
          !!VR(poses[j]):S(firstPos) -1;
        !!en;

        ; If a unit's found, add to the array
        !!if&(poses[j])>(BATTLE_HEX_FIRST)/(poses[j])<(BATTLE_HEX_LAST);
          !!BU:E(poses[j])/?(stack:y);
          !!FU(Array_Push)&(stack)>(NO_STACK):P(affectedStacksList)/(stack);
        !!en;
      !!en;
    !!en;

    !!FU(Array_SortedUnique):P(affectedStacksList);
    !!SN:M(affectedStacksList)/?(size:y);

    !!if&(size)>0;
      !!VR(inflictedDamage:y):S(FALSE);
      ; Get the damage would be done by the damaging movement unit
      !!BMi^battle_acting_stack^:T?(type:y) N?(actNum:y);
      !!FU(tum_CheckMonHolyChargeDamageRate):P(type)/?(rate:y);
      ; Get acting side. Here we don't use BM:I as it may be hypnotized
      !!FU(tum_GetActualStackSide):Pi^battle_acting_stack^/?(actSide:y);

      !!re i/0/(size)/1/-1;
        !!SN:M(affectedStacksList)/i/?(affectedStack:y);

        ; Skip if the target is the same side with the acting side
        !!BM(affectedStack):I?(targetSide:y);
        !!co&(targetSide)=(actSide);

        !!BM(affectedStack):F?(flags:y);
        !!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);

        ; Calculate damage
        !!FU(tum_CalcStackToStackDamage):Pi^battle_acting_stack^/(affectedStack)/?(damage:y)/(FALSE)/(TRUE);
        !!VR(damage):*(rate) :100;
        !!VR(damage)&(isUndead):*3 :2;  [50% bonus to Undead]

        !!if&(damage)>0;
          ; Inflict damage
          !!BM(affectedStack):K(damage);

          !!VR(inflictedDamage):S(TRUE);
        !!en;
      !!en;

      !!if&i^battle_isVisible^/(inflictedDamage);
        !!FU(tum_UpdateStackAnimation):P;

        ; Battle log
        !!VR(isPlural:y):S(num) -1 B;
        !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
        !!SN:T^tumr.str.holyCharge%(isPlural)^/?(battleLog:z)/^mon^/(monName)/^dmg^/(rate);
        !!MM:S(battleLog);
      !!en;

      !!FU(tum_ExecutePhoenixResurrection):P;

      ; Skip the normal attack process if the target is killed by holy charge
      !!BG:E?(targetStack:y);

      !!if&(targetStack)=(NO_STACK);
        !!SN:X?t/0;
        !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4463338;
      !!en;
    !!en;
  !!en;
!!en;

; Release the array
!!SN:Mi^tum_holyChargePosList^;
!!VRi^tum_holyChargePosList^:S0;

!?FU(tum_CheckMonHolyChargeDamageRate);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_HOLY_CHAMPION):S5;


// Cherub's resurrection
; increased healing power to 120 per unit
!?FU(tum_OnCalcAngelResurrectionPower);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(stackStruct:y);
!!UN:C(stackStruct)/52/4/?(type:y);

!!FU(tum_CheckAngelResurrectionPower):P(type)/?(resPower:y);

!!if&(resPower)>0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/?(resHp:y);
  !!VR(newResHp:y):S(resHp) :100 *(resPower);
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/(newResHp);
!!en;

!?FU(tum_CheckAngelResurrectionPower);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_CHERUB):S120;


// Cherubs' Wings of Renewal
; Whenever casting an active monster spell, friendly stacks adjacent to the position of spell would be revived
; This means an AOE revival for Cherubs
!?FU(OnBattleActionEnd)&i^battle_acting_stack^>(NO_STACK);
!!BG:A?(action:y);

!!if&(action)=(BATTLE_ACTION_MONSTER_CAST);
  !!BMi^battle_acting_stack^:T?(actType:y);
  !!FU(tum_CheckMonWingsOfRenewalPower):P(actType)/?(resPower:y);

  !!if&(resPower)>0;
    !!BG:D?(pos:y);
    !!FU(tum_GetAdjacentStacksOfPosition):P(pos)/?(adjacentStacksList:y)/1/(TRUE); [x3 = friendly units only, x4 = allow dead units]

    ; Get the units applicable to be revived from the adjacent list
    !!SN:M(adjacentStacksList)/?(size:y);

    !!if&(size)>0;
      !!BMi^battle_acting_stack^:N?(actNum:y);
      !!VR(totalResPower:y):S(resPower) *(actNum);
      !!FU(NewIntArray)&i^battle_isVisible^:P?(resurrectionList:y);

      !!re i/0/(size)/1/-1;
        !!SN:M(adjacentStacksList)/i/?(targetStack:y);

        ; Skip if the target has no casulty
        !!BM(targetStack):N?(targetNum:y) B?(targetInitNum:y) ;
        !!co&(targetNum)>=(targetInitNum);

        ; Skip if the target doesn't have the living flag
        !!BM(targetStack):F?(flags:y);
        !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);
        !!co&(isAlive)=(FALSE);

        !!FU(tum_HealAndReviveStack):P(targetStack)/(totalResPower)/?(numRevived:y)/?(actualRegenHp:y)/(TRUE);
        !!FU(Array_Push)&i^battle_isVisible^/(numRevived)>0:P(resurrectionList)/(targetStack);
      !!en;

      ; If there is at least one unit to be revived
      !!FU&i^battle_isVisible^<>(TRUE):E;

      !!SN:M(resurrectionList)/?(size);

      !!if&(size)>0;
        ; Battle log
        !!VR(isPlural:y):S(actNum) -1 B;
        !!SN:H^monname^/(actType)/(isPlural)/?(monName:z);
        !!SN:T^tumr.str.wingsOfRenewal%(isPlural)^/?(battleLog:z)/^mon^/(monName);
        !!MM:S(battleLog);

        ; Animation
        !!FU(tum_PlayAnimationOnMultipleStacks):P(resurrectionList)/50/(FALSE);
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonWingsOfRenewalPower);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_CHERUB):S50;


// Dwarf Destroyers' Hammer Crush
; Increase 12% of damage every time attacking (exclusing retaliation) the same target
; The increased damage is not shown on the stats. It happens only on the calculation
; If attacking another target, the accumulating damage to the first target would be lost
!?FU(OnStackToStackDamage);
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU&(isDistant):E;
; Exit if the attacker isn't the acting stack (a.k.a retaliation doesn't stack Hammer Crush bonus)
!!FU&i^battle_current_stack^<>(atkStack):E;

; Check the attacker's rate of Hammer Crush
!!BM(atkStack):T?(type:y);
!!FU(tum_CheckMonHammerCrushRate):P(type)/?(rate:y);

!!if&(rate)>0;
  ; Check if it is the first time attacking the same target
  !!FU(UnpackUnion):Pi^tum_abilityCounter2_%(atkStack)^/?(targetStack:y)/16/?(attackTimes:y)/16;

  ; If it is the second time or more attacking the same target, raise the damage based on how many times attacked
  !!if&(targetStack)=(defStack)/(attackTimes)>=1;   
    !!VR(totalBonusRate:y):S(attackTimes) *(rate) F0/60; [Max at 60% bonus damage]

    !!VR(finalDmgNew:y):S(finalDmgConst) *(totalBonusRate) :100 +(finalDmg);

    !!if&(finalDmgNew)>(finalDmg);
      !!VR(finalDmg):S(finalDmgNew);    [Fix overflow]

      !!if&(isTheoretical);
        !!SN&i^battle_isVisible^:T^tumr.str.hammerCrush^/?s^tum_extraBattleMonMouseHint^/^bonus^/(totalBonusRate);
      !!el;
        !!VR(attackTimes)&(isTheoretical)<>(TRUE):+1;
      !!en;
    !!en;

  ; If it is the first time, reset the target stack variable and set the counter as 1
  !!el;
    !!VR(targetStack):S(defStack);
    !!VR(attackTimes)&(isTheoretical)<>(TRUE):S1;
  !!en;

  !!FU(PackUnion)&(isTheoretical)<>(TRUE):P(targetStack)/16/(attackTimes)/16/?i^tum_abilityCounter2_%(atkStack)^;
!!en;

!?FU(tum_CheckMonHammerCrushRate);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_DWARF_DESTROYER):S12;


// Legendary Unicorns' Blinding Light
; Cast on self: Blind all the adjacent hostile units for 1 turn
!?FU(OnBattleMouseHint)&i^tum_customSpellActive^;
; Check monster position, exit if not current stack
!!BU:Ei^mouse_battleHex^/?(stack:y);
!!FU&(stack)<>i^battle_current_stack^:E;

!!VR(side:y):Si^battle_current_side^;

; Get type and check if the stack has Blinding Light
!!BMi^battle_current_stack^:T?(currType:y);
!!FU(tum_CheckIfMonHasBlindingLight):P(currType)/?(result:y);
!!FU&(result)<>(TRUE):E;

!!BMi^battle_current_stack^:N?(currNum:y);

; Show no spell hint if needed
!!BMi^battle_current_stack^:E?(spells:y);

!!if&(spells)<=0;
  !!VR(isPlural:y):S(currNum) -1 B;
  !!SN:H^monname^/(currType)/(isPlural)/?(monName:z);
  !!SN:T^tumr.str.noSpell%(isPlural)^/?(hint:z)/^mon^/(monName);
  !!MM:M^%(hint)^;
  !!FU:E;
!!en;

; Exit if not possible to cast
!!FU(tum_CheckIfPossibleToCast):P(SPELL_BLIND)/?(result:y)/?(hint:z);

!!if&(result)<>(TRUE);
  !!MM&(hint)<>^^:M(hint);
  !!FU:E;
!!en;

; Exit if all the adjacent hostile stacks cannot be Blind
!!VR(hasValidTarget:y):S(FALSE);
!!FU(tum_GetAdjacentStacksOfStack):Pi^battle_current_stack^/?(adjacentStacksList:y)/-1/(FALSE);

!!SN:M(adjacentStacksList)/?(size:y);
  
!!if&(size)>0;
  !!re i/0/(size)/1/-1;
    !!SN:M(adjacentStacksList)/i/?(targetStack:y);
    !!FU(tum_Battle_CanStackReceiveSpell):P(targetStack)/(SPELL_BLIND)/(side)/?(result);

    !!if&(result);
      !!VR(hasValidTarget):S(TRUE);

      !!br;
    !!en;
  !!en;
!!en;  

!!if&(hasValidTarget)=(FALSE);
  *!SN:T^tumr.str.blindingLightNoTarget^/?(hint);
  *!MM:M^%(hint)^;
  !!FU:E;
!!en;

; Change the cursor and show hint
!!UN:R5/3/0;

!!SN:T^tumr.str.blindingLightMain^/?(hint);
!!MM:M(hint);

!?FU(OnBattleScreenMouseClick)&i^mouse_action^=(MOUSE_LMB_PRESSED)/i^tum_customSpellActive^;
; Check monster position, exit if not current stack
!!BU:Ei^mouse_battleHex^/?(stack:y);
!!FU&(stack)<>i^battle_current_stack^:E;

!!FU(tum_CastBlindingLight):P0/?(result:y);
!!CM&(result):R0;

!?FU(OnKeyPressed_Battle)&i^key^=(KEY_F);
!#VA(key:x) (preventDefault:x);

!!FU(tum_CastBlindingLight):P1/?(result:y);
!!VR(preventDefault)&(result):S(TRUE);

!?FU(tum_CastBlindingLight);
!#VA(mode:x) (hasSucceed:x);

!!VR(hasSucceed):S(FALSE);

!!VR(side:y):Si^battle_current_side^;

; Get type and check if the stack has Blinding Light
!!BMi^battle_current_stack^:T?(currType:y);
!!FU(tum_CheckIfMonHasBlindingLight):P(currType)/?(result:y);
!!FU&(result)<>(TRUE):E;

!!BMi^battle_current_stack^:N?(currNum:y);

; Exit if no spell
!!BMi^battle_current_stack^:E?(spells:y);
!!FU&(spells)<=0:E;

; Exit if not possible to cast
!!FU(tum_CheckIfPossibleToCast):P(SPELL_BLIND)/?(result:y);
!!FU&(result)<>(TRUE):E;

!!FU(tum_ExecuteBlindingLight):Pi^battle_current_stack^/(currNum)/(currType)/(side)/?(hasSucceed);

!!VR(oppSide:y):S(side) X(TRUE);
!!IP:Di^battle_owner_%(oppSide)^;
!!FU(tum_ExecuteBlindingLight):Di^battle_current_stack^/(currNum)/(currType)/(side)/?(hasSucceed);

!?FU(tum_ExecuteBlindingLight);
!#VA(stack:x) (currNum:x) (currType:x) (side:x) (hasSucceed:x);

!!VR(isAi:y):S(FALSE);
!!FU:A?(numArgs:y);
!!VR(isAi)&(numArgs)<5:S(TRUE);

; Exit if all the adjacent hostile stacks cannot be Blind
!!FU(NewIntArray):P?(affectedStacksList:y);
!!FU(tum_GetAdjacentStacksOfStack):P(stack)/?(adjacentStacksList:y)/-1/(FALSE);
!!SN:M(adjacentStacksList)/?(size:y);
  
!!if&(size)>0;
  !!re i/0/(size)/1/-1;
    !!SN:M(adjacentStacksList)/i/?(targetStack:y);
    !!FU(tum_Battle_CanStackBeAffectedBySpell):P(targetStack)/(SPELL_BLIND)/(side)/?(result:y);

    !!if&(result);
      ; For AI - skip stunned stack, don't treat them as available
      !!if&(isAi);
        !!BM(targetStack):F?(flags:y);
        !!VR(hasActed:y):S(flags) &(MON_FLAG_ACTED);
        !!co&(hasActed);

        !!BM(targetStack):G(SPELL_BLIND)/?(duration1:y)/?(power:y) G70/?(duration2:y)/?(power:y) G74/?(duration3:y)/?(power:y);
        !!co|(duration1)>0/(duration2)>0/(duration3)>0;
      !!en;

      !!FU(Array_Push):P(affectedStacksList)/(targetStack);
    !!en;
  !!en;
!!en;  

!!SN:M(affectedStacksList)/?(size);
!!FU&(size)=0:E;

; For human
!!if&(isAi)<>(TRUE);
  !!VR(hasSucceed):S(TRUE);
; For AI
; Skip if no more than 2 stacks are affected
!!el;
  !!FU&(size)<2:E;
!!en;

; Get data
!!BM(stack):Z?(stackStruct:y);
; Play animation of the caster
!!FU(tum_BattleStack_PlayAnimation):P(stackStruct)/15/(FALSE);

; Restore the cursor to default - for the current acting player only
!!OW:C?(currPlayer:y)/?(interactPlayer:y);

!!re i/0/1;
  !!if&i^battle_owner_%i^=(interactPlayer);
    !!UN:R5/0/0;

    !!br;
  !!en;
!!en;

; Battle log
!!VR(isPlural:y):S(currNum) -1 B;
!!SN:H^monname^/(currType)/(isPlural)/?(monName:z);
!!SN:T^tumr.str.blindingLightCast%(isPlural)^/?(battleLog:z)/^mon^/(monName);
!!MM:S(battleLog);

; Sound
!!SN:P^blind^;
; Animation on the targets
!!FU(tum_PlayAnimationOnMultipleStacks):P(affectedStacksList)/6;

; Cast
!!re i/0/(size)/1/-1;
  !!SN:M(affectedStacksList)/i/?(realTargetStack:y);
  !!BM(realTargetStack):M(SPELL_BLIND)/1/(SKILL_EXPERT);
!!en;

!!SN:D;

; Reduce 1 spell
!!BM(stack):Ed-1;
!!FU(tum_FixXEMonsterSpellCountCompatibility):P; [ACM Compatiblity]

; Pass the turn
!!BG:A(BATTLE_ACTION_SKIP);

!?FU(tum_CheckIfMonHasBlindingLight);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_LEGENDARY_UNICORN):S(TRUE);

; AI Blinding Light
!?FU(OnBeforeBattleAction)&i^tum_isBattleStackAction^/i^battle_ai_%i(battle_acting_side)^;
; Get type and check if the stack has Blinding Light
!!BMi^battle_acting_stack^:T?(currType:y);
!!FU(tum_CheckIfMonHasBlindingLight):P(currType)/?(result:y);
!!FU&(result)<>(TRUE):E;

!!BMi^battle_acting_stack^:N?(currNum:y);

; Exit if no spell
!!BMi^battle_acting_stack^:E?(spells:y);
!!FU&(spells)<=0:E;

; Exit if not possible to cast
!!FU(tum_CheckIfPossibleToCast):P(SPELL_BLIND)/?(result:y);
!!FU&(result)<>(TRUE):E;

!!FU(tum_ExecuteBlindingLight):Pi^battle_acting_stack^/(currNum)/(currType)/i^battle_acting_side^;


// Pure Diamond Dragons' Radiant Breath
; Breath for multiple hexes, no frienldy fire on secondary targets
; Since no friendly fire is allow, this script works perfectly on AI behaviour
!?FU(tum_OnBeforeBreathAttack);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ECX)/(UNC_INT)/?(atkStruct:y); [Attacker struct]

!!UN:C(atkStruct)/52/4/?(type:y);
; Get the length of radiant breath
!!FU(tum_CheckMonRadiantBreathLength):P(type)/?(length:y);

!!if&(length)>2;
  !!VRi^tum_radiantBreathAtkStruct^:S(atkStruct);
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/(UNC_INT)/?i^tum_radiantBreathFirstHex^; [Attack pos]
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBX)/(UNC_INT)/?i^tum_radiantBreathAtkDirection^; [Attack direction]
!!en;

!?FU(OnMonsterPhysicalDamage)&i^tum_radiantBreathAtkStruct^;
; Exit if not normal melee damage
!!UN:C42149568/(UNC_INT)/?(dmgType:y);
!!FU&(dmgType)<>4462398:E;

; Exit if not the target of the breath attack
!!BU:Ei^tum_radiantBreathFirstHex^/?(stackOnPos:y);
!!MF:N?(defStack:y);
!!FU&(defStack)<>(stackOnPos):E;

; Get the length of the radiant breath
!!UN:Ci^tum_radiantBreathAtkStruct^/52/(UNC_INT)/?(type:y);
!!FU(tum_CheckMonRadiantBreathLength):P(type)/?(length:y);

!!if&(length)>2;
  ; Set up array for casting Blind OnAfterMelee
  !!FU(NewIntArray):P?i^tum_radiantBreathBlindList^/(M_TEMP);

  ; Check if the breath on the second position is successful (or not, since we want the breath to continue even if hitting nothing)
  !!SN:E5390976/(CALLCONV_THISCALL)/i^tum_radiantBreathAtkStruct^/i^tum_radiantBreathFirstHex^/i^tum_radiantBreathAtkDirection^;
  !!VR(targetPos:y):Sv1;

  !!if&(targetPos)>=1/(targetPos)<=185;
    !!BU:E(targetPos)/?(secStack:y);

    ; Push the second stack to the array if it is valid
    !!FU(Array_Push)&(secStack)>(NO_STACK):Pi^tum_radiantBreathBlindList^/(secStack);

    ; Get info of the attacker
    !!UN:Ci^tum_radiantBreathAtkStruct^/244/(UNC_INT)/?(atkSide:y) Ci^tum_radiantBreathAtkStruct^/248/(UNC_INT)/?(stackOfSide:y);
    !!VR(atkStack:y):S(atkSide) *(BATTLE_STACKS_PER_SIDE) +(stackOfSide);
    !!FU(tum_GetActualStackSide):P(atkStack)/?(actualAtkSide:y);

    ; Set the loop for the line of breath attack
    !!FU(NewIntArray):P?(stacksToDamageList:y);
    !!VR(lastInd:y):S(length) -3;

    !!re i/0/(lastInd);
      !!SN:E5390976/(CALLCONV_THISCALL)/i^tum_radiantBreathAtkStruct^/(targetPos)/i^tum_radiantBreathAtkDirection^;
      !!VR(targetPos:y):Sv1;

      ; Get the next hex based on attacker struct, position and attack direction
      !!if&(targetPos)>=1/(targetPos)<=185;
        !!BU:E(targetPos)/?(defStack:y);

        ; Next if no unit found, or next if the found unit is the second unit
        !!co&(defStack)<=(NO_STACK);
        !!co&(defStack)=(secStack);

        ; Disable friendly fire on external targets
        ; Check if the stack belongs to the same side with the attacker. Exit if on the same side
        !!BM(defStack):I?(defSide:y);
        !!co&(defSide)=(actualAtkSide);

        ; Store the target on the line, starting from the second in the loop (third for the whole attack)
        !!FU(Array_Push):P(stacksToDamageList)/(defStack);
      !!en;
    !!en;

    ; Check if the array has at least 2 items (1 for the second breath target) after sorting
    !!FU(Array_SortedUnique):P(stacksToDamageList);
    !!SN:M(stacksToDamageList)/?(size:y);

    !!if&(size)>0;
      ; Loop through all the stacks to be damaged and inflict damage
      !!re i/0/(size)/1/-1;
        !!SN:M(stacksToDamageList)/i/?(defStack);
        !!FU(tum_CalcStackToStackDamage):P(atkStack)/(defStack)/?(damage:y)/(FALSE)/(TRUE);

        !!if&(damage)>0;
          !!BM(defStack):K(damage);
          ; Push the target to cast Blind OnAfterMelee
          !!FU(Array_Push):Pi^tum_radiantBreathBlindList^/(defStack);
        !!en;
      !!en;
    !!en;
  !!en;

  ; Release the array for Blind if nothing in it
  !!SN:Mi^tum_radiantBreathBlindList^/?(size:y);

  !!if&(size)=0;
    !!SN:Mi^tum_radiantBreathBlindList^;
    !!VRi^tum_radiantBreathBlindList^:S0;
  !!en;
!!en;

; Release vars
*!VRi^tum_radiantBreathAtkStruct^:S0;   [moved to FU(tum_OnAfterMelee) in case it's not released for some reason]
!!VRi^tum_radiantBreathFirstHex^:S0;
!!VRi^tum_radiantBreathAtkDirection^:S0;

; Disable friendly fire for the secondary target (native one)
!?FU(tum_OnAfterGetBreathSecondaryTarget)&i^tum_radiantBreathAtkStruct^;
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/(UNC_INT)/?(secTargetStuct:y);

!!if&(secTargetStuct);
  !!UN:Ci^tum_radiantBreathAtkStruct^/244/4/?(atkSide:y) Ci^tum_radiantBreathAtkStruct^/248/4/?(stackOfSide:y);
  !!VR(atkStack:y):S(atkSide) *(BATTLE_STACKS_PER_SIDE) +(stackOfSide);
  !!FU(tum_GetActualStackSide):P(atkStack)/?(actualAtkSide:y);

  !!UN:C(secTargetStuct)/244/4/?(defSide:y);

  !!if&(actualAtkSide)=(defSide);
    !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/(UNC_INT)/0;
  !!en;
!!en;

; Cast Blind on the secondary targets
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!if&i^tum_radiantBreathBlindList^;
  !!SN:Mi^tum_radiantBreathBlindList^/?(size:y);

  !!if&(size)>0;
    !!FU(tum_GetActualStackSide):P(atkStack)/?(actualAtkSide:y);

    !!re i/0/(size)/1/-1;
      !!SN:Mi^tum_radiantBreathBlindList^/i/?(stack:y);
      !!BM(stack):I?(defSide:y);

      !!FU(tum_CastSpellAfterAttack)&(actualAtkSide)<>(defSide):P(atkStack)/(stack)/20/(SPELL_BLIND)/(SKILL_NOT_LEARNED);
    !!en;
  !!en;

  ; Release the array
  !!SN:Mi^tum_radiantBreathBlindList^;
  !!VRi^tum_radiantBreathBlindList^:S0;
!!en;

; Release var
!!VRi^tum_radiantBreathAtkStruct^:S0;

!?FU(tum_CheckMonRadiantBreathLength);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_PURE_DIAMOND_DRAGON):S3;


// Grandmaster Gremlins' Mend
; Resurrect constructs like Archangels resurrecting fallen allies
; Change the cursor to casting when a target is not full comparing with its initial status
!?FU(OnBattleMouseHint)&i^tum_customSpellActive^;
; Check monster position
!!BU:Ei^mouse_battleHex^/?(targetStack:y);
; Check again for bodies if there is no living stack at the position
!!BU&(targetStack)=(NO_STACK):Di^mouse_battleHex^/?(targetStack);
; Exit if no monster
!!FU&(targetStack)=(NO_STACK):E;

!!VR(currSide:y):Si^battle_current_side^;
!!BM(targetStack):I?(targetSide:y);
!!FU&(currSide)<>(targetSide):E;

; Get type and check the mending power of the current stack
!!BMi^battle_current_stack^:T?(currType:y);
!!FU(tum_GetMonMendingPower):P(currType)/?(mendPower:y);
!!FU&(mendPower)<=0:E;

!!BMi^battle_current_stack^:N?(currNum:y);

; Show no spell hint if needed
!!BMi^battle_current_stack^:E?(spells:y);

!!if&(spells)<=0;
  !!VR(isPlural:y):S(currNum) -1 B;
  !!SN:H^monname^/(currType)/(isPlural)/?(monName:z);
  !!SN:T^tumr.str.noSpell%(isPlural)^/?(hint:z)/^mon^/(monName);
  !!MM:M^%(hint)^;
  !!FU:E;
!!en;

; Exit if stack is the same
!!FU&(targetStack)=i^battle_current_stack^:E;

; Exit if the current number is bigger than initial (can be equal to)
!!BM(targetStack):N?(targetNum:y) B?(targetInitNum:y);
!!FU&(targetNum)>(targetInitNum):E;

; Exit if not possible to cast
!!FU(tum_CheckIfPossibleToCast):P3/?(result:y)/?(hint:z);

!!if&(result)<>(TRUE);
  !!MM&(hint)<>^^:M(hint);
  !!FU:E;
!!en;

; Check if the target is a construct
!!FU(tum_GetStackOrMonLivingType):P(targetStack)/(FALSE)/?(livingType:y);

; If not a construct, exit
!!if&(livingType)<>2;
  !!MM:M^%T(tumr.str.mendNotConstruct)^;
  !!FU:E;
!!en;

; Check if the target is wide only when it's dead (assuming that's the only case two stacks in the some hex)
!!if&(targetNum)<=0;
  !!BM(targetStack):Z?(targetStuct:y) P?(pos:y) F?(flags:y);
  !!VR(isWide:y):S(flags) &(MON_FLAG_WIDE);

  !!if&(isWide);
    !!UN:C(targetStuct)/68/4/?(secPosOrientation:y);

    !!if&(secPosOrientation)>=0;
      !!if&(secPosOrientation)=0;
        !!VR(secPos:y):S(pos) -1;
      !!el&(secPosOrientation)=1;
        !!VR(secPos:y):S(pos) +1;
      !!en;

      !!BU:E(secPos)/?(stackAbove:y);
      !!FU&(stackAbove)>(NO_STACK):E;
    !!en;
  !!en;
!!en;

; Check if the stack can receive spell - not working when the target is dead
*!FU(tum_CheckIfStackCanReceiveCustomSpell):P(targetStack)/(currSide)/(SPELL_RESURRECTION)/3/0/?(result);
*!FU&(result)<>(TRUE):E;

; Get the total mending power
!!VR(totalMendPower:y):S(currNum) *(mendPower);
!!BM(targetStack):H?(hp:y);

!!VR(targetIsPlural:y):S(targetInitNum) -1 B;
!!BM(targetStack):T?(targetType:y);
!!SN:H^monname^/(targetType)/(targetIsPlural)/?(targetMonName:z);

!!if&(totalMendPower)>=(hp);
  !!UN:R5/3/0;

  !!BM(targetStack):L?(lostHp:y);
  !!VR(leftMendPower:y):S(totalMendPower) -(lostHp);
  !!VR(maxRevive:y):S(targetInitNum) -(targetNum);
  !!VR(numRevived:y):S(leftMendPower) :(hp) +1 F1/(maxRevive);
  !!SN:T^tumr.str.mendMain^/?(hint:z)/^num^/(numRevived)/^mon^/(targetMonName);
!!el;
  !!VR(currIsPlural:y):S(currNum) -1 B;
  !!SN:H^monname^/(currType)/(currIsPlural)/?(currMonName:z);
  !!VR(targetIsPlural:y):S(targetInitNum) -1 B;
  !!SN:H^monname^/(targetType)/(targetIsPlural)/?(targetMonName:z);
  !!SN:T^tumr.str.mendNotEnough%(currIsPlural)^/?(hint)/^currMon^/(currMonName)/^targetMon^/(targetMonName);
!!en;

!!MM:M(hint);

; Mouse click
!?FU(OnBattleScreenMouseClick)&i^mouse_action^=(MOUSE_LMB_PRESSED)/i^tum_customSpellActive^;
; Check monster position
!!BU:Ei^mouse_battleHex^/?(targetStack:y);
; Check again for bodies if there is no living stack at the position
!!BU&(targetStack)=(NO_STACK):Di^mouse_battleHex^/?(targetStack);
; Exit if no monster
!!FU&(targetStack)=(NO_STACK):E;

!!VR(currSide:y):Si^battle_current_side^;
!!BM(targetStack):I?(targetSide:y);
!!FU&(currSide)<>(targetSide):E;

; Get type and check the mending power of the current stack
!!BMi^battle_current_stack^:T?(currType:y);
!!FU(tum_GetMonMendingPower):P(currType)/?(mendPower:y);
!!FU&(mendPower)<=0:E;

!!BMi^battle_current_stack^:N?(currNum:y);

!!BMi^battle_current_stack^:E?(spells:y);
!!FU&(spells)<=0:E;

; Exit if stack is the same
!!FU&(targetStack)=i^battle_current_stack^:E;

; Exit if the current number is bigger than initial (can be equal to)
!!BM(targetStack):N?(targetNum:y) B?(targetInitNum:y);
!!FU&(targetNum)>(targetInitNum):E;

; Exit if not possible to cast
!!FU(tum_CheckIfPossibleToCast):P3/?(result:y);
!!FU&(result)<>(TRUE):E;

; Check if the target is a construct
!!FU(tum_GetStackOrMonLivingType):P(targetStack)/(FALSE)/?(livingType:y);
!!FU&(livingType)<>2:E;

; Check if the target is wide only when it's dead (assuming that's the only case two stacks in the some hex)
!!if&(targetNum)<=0;
  !!BM(targetStack):Z?(targetStuct:y) P?(pos:y) F?(flags:y);
  !!VR(isWide:y):S(flags) &(MON_FLAG_WIDE);

  !!if&(isWide);
    !!UN:C(targetStuct)/68/4/?(secPosOrientation:y);

    !!if&(secPosOrientation)>=0;
      !!if&(secPosOrientation)=0;
        !!VR(secPos:y):S(pos) -1;
      !!el&(secPosOrientation)=1;
        !!VR(secPos:y):S(pos) +1;
      !!en;

      !!BU:E(secPos)/?(stackAbove:y);
      !!FU&(stackAbove)>(NO_STACK):E;
    !!en;
  !!en;
!!en;

; Check if the stack can receive spell - not working when the target is dead
*!FU(tum_CheckIfStackCanReceiveCustomSpell):P(targetStack)/(currSide)/(SPELL_RESURRECTION)/3/0/?(result);
*!FU&(result)<>(TRUE):E;

; Get the total mending power
!!VR(totalMendPower:y):S(currNum) *(mendPower);
!!BM(targetStack):H?(hp:y);
!!FU&(totalMendPower)<(hp):E;

!!FU(tum_ExecuteMend):P(targetNum)/(targetStack)/(totalMendPower);
!!VR(oppSide:y):S(currSide) X(TRUE);
!!IP:Di^battle_owner_%(oppSide)^;
!!FU(tum_ExecuteMend):D(targetNum)/(targetStack)/(totalMendPower);

!?FU(tum_ExecuteMend);
!#VA(targetNum:x) (targetStack:x) (totalMendPower:x);

; Play the casting animation manually
!!BMi^battle_current_stack^:P?(currPos:y);

; Get real coordinates of hexes
!!FU(tum_GetCoordsOfHex):P(currPos)/?(currX:y)/?(currY:y) Pi^mouse_battleHex^/?(targetX:y)/?(targetY:y);

; Check if it is required to turn around
!!VR(mustTurnAround:y):S(FALSE);
!!BMi^battle_current_stack^:I?(realSide:y);

!!if&(currX)<(targetX);
  !!VR(mustTurnAround)&(realSide)=(BATTLE_RIGHT):S(TRUE);
!!el&(currX)>(targetX);
  !!VR(mustTurnAround)&(realSide)=(BATTLE_LEFT):S(TRUE);
!!en;

; Get the group of frame for animation
!!if&(currY)<(targetY);
  !!VR(group:y):S11;
!!el&(currY)=(targetY);
  !!VR(group):S12;
!!el;
  !!VR(group):S13;
!!en;

; Get data
!!BMi^battle_current_stack^:Z?(stackStruct:y);

; Turn around
!!SN&(mustTurnAround):E4482112/(CALLCONV_THISCALL)/(stackStruct)/1; 446440
; Play animation
!!FU(tum_BattleStack_PlayAnimation):P(stackStruct)/(group)/(FALSE);

; Restore the cursor to default - for the current acting player only
!!OW:C?(currPlayer:y)/?(interactPlayer:y);

!!re i/0/1;
  !!if&i^battle_owner_%i^=(interactPlayer);
    !!CM:R0;
    !!UN:R5/0/0;

    !!br;
  !!en;
!!en;

; If the stack has been killed completely
!!if&(targetNum)<=0;
  !!FU(tum_ResurrectDeadStack):P(targetStack)/(totalMendPower);
  !!BM(targetStack):N?(numRevived:y);
; If the stack is still alive
!!el;
  !!FU(tum_HealAndReviveStack):P(targetStack)/(totalMendPower)/?(numRevived:y)/?(actualRegenHp:y);
!!en;

; Battle log
!!VR(isPlural:y):S(numRevived) -1 B;
!!BM(targetStack):T?(targetType:y);
!!SN:H^monname^/(targetType)/(isPlural)/?(monName:z);
!!SN:T^tumr.str.res%(isPlural)^/?(battleLog:z)/^num^/(numRevived)/^mon^/(monName);
!!MM:S(battleLog);

; Sound
!!SN:P^resurect^;
; Animation
!!FU(tum_PlayCustomAnimationOnStack):P(targetStack)/^mend^/1;

; Turn back
!!SN&(mustTurnAround):E4482112/(CALLCONV_THISCALL)/(stackStruct)/1;
!!SN:D;

; Reduce 1 spell
!!BMi^battle_current_stack^:Ed-1;
!!FU(tum_FixXEMonsterSpellCountCompatibility):P; [ACM Compatiblity]

; Pass the turn
!!BG:A(BATTLE_ACTION_SKIP);

!?FU(tum_GetMonMendingPower);
; Mending power = hp to revive of each unit.
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_GRANDMASTER_GREMLIN):S4;


// Gold Gargoyles' Hardened Shelter
; Turn the caster into a stone on battle action end, if the action was walking or defending
!?FU(OnBattleActionEnd)&i^battle_round^>=0/i^battle_acting_stack^>(NO_STACK);
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_WALK)
    /(action)<>(BATTLE_ACTION_DEFEND):E;

!!BMi^battle_acting_stack^:N?(num:y);

!!if&(num)>0;
  ; Acted only - could be negative if the stack has active morale
  !!BMi^battle_acting_stack^:F?(flags:y);
  !!VR(hasActed:y):S(flags) &(MON_FLAG_ACTED);

  !!if&(hasActed);
    !!BMi^battle_acting_stack^:T?(type:y);
    !!FU(tum_CheckIfMonHasHardenedShelter):P(type)/?(chance:y);

    !!if&(chance)>0;
      !!BMi^battle_acting_stack^:G70/?(duration:y)/?(level:y);

      !!if&(duration)<=0;
        ; Check if there is any adjacent friendly Gold Gargoyles in stone form. Exit the funtion if positive
        !!FU(tum_GetAdjacentStacksOfStack):Pi^battle_acting_stack^/?(adjacentStacksList:y)/0/(FALSE)/(TRUE);
        !!SN:M(adjacentStacksList)/?(size:y);

        !!if&(size)>0;
          !!re i/0/(size)/1/-1;
            !!SN:M(adjacentStacksList)/i/?(adjacentStack:y);
            !!BM(adjacentStack):G70/?(duration)/?(level);

            !!FU&(duration)>0:E;
          !!en;
        !!en;

        ; If there isn't any adjacent Gold Gargoyles in stone, turn the current one to stone
        !!if&i^battle_isVisible^;
          !!BMi^battle_acting_stack^:N?(num:y);
          !!VR(isPlural:y):S(num) -1 B;
          !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
          !!SN:T^tumr.str.hardenedShelter%(isPlural)^/?(battleLog:z)/^mon^/(monName);
          !!MM:S(battleLog);

          !!SN:P^paralyze^;
        !!en;

        !!BMi^battle_acting_stack^:M70/1/(SKILL_NOT_LEARNED); [for 1 turn]
      !!en;
    !!en;
  !!en;
!!en;

// Remove stone debuff at the start of every turn
!?FU(OnBattleRound)&i^battle_round^>=0;
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!BMi:N?(num:y);

  !!if&(num)>=0;
    !!BMi:T?(type:y);
    !!FU(tum_CheckIfMonHasHardenedShelter):P(type)/?(result:y);

    !!if&(result);
      !!BMi:G70/?(duration:y)/?(level:y);
      !!FU(tum_RemoveSpellFromStack)&(duration)>0:Pi/70;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckIfMonHasHardenedShelter);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_GOLD_GARGOYLE):S(TRUE);


// Naga Empress' Disarm
; chance to reduce the attacked stacks' retaliation by 1
; Works for every single target of 3-head attacks
!?FU(tum_OnBeforeMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):T?(type:y);
!!FU(tum_GetMonDisarmChance):P(type)/?(hasDisarm:y);

!!if&(hasDisarm);
  !!FU(NewIntArray):P?i^tum_disarmList^/(M_TEMP);
  !!FU(Array_Push):Pi^tum_disarmList^/(atkStack);
!!en;

!?FU(OnStackToStackDamage)&i^tum_disarmList^;
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU|(isDistant)/(isTheoretical):E;

!!SN:Mi^tum_disarmList^/0/?(savedStack:y);
!!FU(Array_Push)&(atkStack)=(savedStack):Pi^tum_disarmList^/(defStack);

!?FU(tum_OnAfterMelee)&i^tum_disarmList^;
!#VA(atkStack:x) (defStack:x);

; Set up array to store affected stacks list
!!FU(NewIntArray)&i^battle_isVisible^:P?(affectedStacksList:y);

; Get the chance of Disarm
!!BM(atkStack):T?(atkMon:y);
!!FU(tum_GetMonDisarmChance):P(atkMon)/?(chance:y);

; Loop through all the attacked targets
!!SN:Mi^tum_disarmList^/?(size:y);

!!re i/1/(size)/1/-1;
  !!SN:Mi^tum_disarmList^/i/?(targetStack:y);
  ; Execute Disarm only when target is alive
  !!BM(targetStack):N?(num:y);

  !!if&(num)>0;
    !!BM(targetStack):R?(retals:y);

    !!if&(retals)>0;
      !!VR(random:y):R0/0/99;

      !!if&(random)<(chance);
        !!BM(targetStack):Rd-1;

        !!FU(Array_Push)&i^battle_isVisible^:P(affectedStacksList)/(targetStack);
      !!en;
    !!en;
  !!en;
!!en;

!!SN:Mi^tum_disarmList^;
!!VRi^tum_disarmList^:S0;

!!if&i^battle_isVisible^;
  !!SN:M(affectedStacksList)/?(size:y);

  !!if&(size)>0;
    ; Sound
    !!SN:P^Chainlte^;
    ; Animation
    !!FU(tum_PlayAnimationOnMultipleStacks):P(affectedStacksList)/28;
    ; Text
    !!BM(atkStack):N?(atkNum:y);
    !!VR(atkIsPlural:y):S(atkNum) -1 B;
    !!SN:H^monname^/(atkMon)/(atkIsPlural)/?(atkMonName:z);
    !!SN:T^tumr.str.disarm%(atkIsPlural)^/?(battleLog:z)/^mon^/(atkMonName);
    !!MM:S(battleLog);
  !!en;
!!en;

!?FU(tum_GetMonDisarmChance);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_NAGA_EMPRESS):S20;


// Zeus' Team Shooting
; Shoot the same target an ally is shooting once each turn. Shooting twice would be temp disabled for this attack.
!?FU(OnBattleActionEnd);
; Check if it is shooting and also the target isn't killed
!!BG:A?(action:y) E?(targetStack:y) N?(actStack:y);
!!FU|(action)<>(BATTLE_ACTION_SHOOT)/(targetStack)<=(NO_STACK)/(actStack)<=(NO_STACK):E;

; Get the position of the target and the real side of the current stack (considering it may be changed by Hypnotize)
!!BM(targetStack):P?(pos:y);
!!BG:Q?(actSide:y);

; Look for team shooting creatures
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  ; Break if the target just got killed (by previous shooting from team shooter)
  !!BM(targetStack):N?(targetNum:y);
  !!br&(targetNum)<=0;

  ; Skip the stack just attacked
  !!co&i=(actStack);

  ; Skip if the stack has activated team shooting this turn
  !!co&i^tum_abilityCounter_%i^<>0;

  ; Check if the stack is alive
  !!BMi:N?(guardNum:y);
  !!co&(guardNum)<=0;

  ; Check if the stack has team shooting
  !!BMi:T?(type:y);
  !!FU(tum_GetMonTeamShootingRange):P(type)/?(range:y);
  !!co&(range)=0;

  ; Check if the stack belongs to the current acting side (would be reversed if the stack is hypnotized)
  !!FU(tum_GetActualStackSide):Pi/?(actualSide:y);
  !!co&(actualSide)<>(actSide);

  ; Check if the stack is within a proper range
  ; Disable as AI won't be aware of this feature
  *!BMi:P?(pos:y);                      [Here we assume all the unit with Team Shooting is single hex]

  *#VA(actPoses[2]:y);
  *!BM(actStack):P?(actPoses[0]);
  *!FU(tum_GetStackHeadPosition):P(actStack)/?(actPoses[1]);

  *!re j/0/1;
    *!FU(tum_CalcHexesDistance):P(pos)/(actPoses[j])/?(distance:y);

    *!br&(distance)<=(range);
  *!en;

  *!co&j>1;

  ; Check if the stack can move
  !!BMi:G(SPELL_BLIND)/?(blindTurns:y)/d G70/?(stoneTurns:y)/d G74/?(paralyzeTurns:y)/d;
  !!co|(blindTurns)>0/(stoneTurns)>0/(paralyzeTurns)>0;

  ; Check if it is possible to shoot
  !!BMi:Z?(stackStruct:y);
  !!SN:E4466192/(CALLCONV_THISCALL)/(stackStruct)/0;
  !!co&v1=(FALSE);

  ; Check if the target can move - shoot only when it can
  !!BM(targetStack):G(SPELL_BLIND)/?(blindTurns:y)/d G70/?(stoneTurns:y)/d G74/?(paralyzeTurns:y)/d;
  !!co|(blindTurns)>0/(stoneTurns)>0/(paralyzeTurns)>0;

  ; Execute team shooting
  ; Save and change data
  !!BMi:F?(flags:y) Fd~(MON_FLAG_ATTACKS_TWICE);
  !!BMi:G-95/?(savedPos1:y)/d G-95/(pos)/d;
  ; Shoot
  !!FU(BattleStack_Shoot):Pi/(targetStack);
  ; Restore
  !!BMi:F(flags);
  !!BMi:G-95/(savedPos1)/d;

  ; Mark as triggered
  !!VRi^tum_abilityCounter_%i^:+1;

  ; Show msg
  !!if&i^battle_isVisible^;
    !!VR(isPlural:y):S(guardNum) -1 B;
    !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
    !!SN:T^tumr.str.teamAttack%(isPlural)^/?(battleLog:z)/^mon^/(monName);
    !!MM:S(battleLog);
  !!en;
!!en;

; For single hex unit only
!?FU(tum_GetMonTeamShootingRange);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_GUARDIAN_OF_ZEUS):S3;


// Vermins' Infernal Reinforcements
; Summon allies from Hell. When stacks obtain their turns the first time, the number of creatures is increased by 20% (non-resurrectable). 
; i^tum_tacticsIsEnded^ is important for not skipping OnBattleStackObtainsTurn on the first round
!?FU(OnBattleStackObtainsTurn)&i^tum_abilityCounter_%i(battle_current_stack)^=0/i^tum_tacticsIsEnded^;
!!BMi^battle_current_stack^:T?(type:y);

!!FU(tum_CheckMonInfernoReinforcementsRate):P(type)/?(rate:y);

!!if&(rate);
  !!BMi^battle_current_stack^:N?(num:y);
  !!VR(newNum:y):S(rate) *(num) :100 +(num);

  !!if&(newNum)>(num);
    !!BMi^battle_current_stack^:N(newNum);
    !!VRi^tum_abilityCounter_%i(battle_current_stack)^:S(INT_MAX);

    !!if&i^battle_isVisible^;
      !!VR(isPlural:y):S(num) -1 B;
      !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
      !!SN:T^tumr.str.infernoReinforcements%(isPlural)^/?(battleLog:z)/^mon^/(monName);
      !!MM:S(battleLog);

      !!SN:P^fireblst^;
      !!FU(tum_PlayCustomAnimationOnStack):Pi^battle_current_stack^/^fireball^/1; [3rd parametre as 1 so that the flame has correct position]
      !!BMi^battle_current_stack^:M(SPELL_INFERNO_REINFORCEMENTS)/1000/(SKILL_NOT_LEARNED);
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonInfernoReinforcementsRate);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_VERMIN):S20;

; Remove additional Inferno troops after battle
!?FU(tum_OnBeforeBattleResult);
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!BMi:N?(num:y);

  !!if&(num)>0;
    !!BMi:T?(type:y);
    !!FU(tum_CheckMonInfernoReinforcementsRate):P(type)/?(rate:y);

    !!if&(rate);
      !!BMi:B?(initNum:y) N?(num:y);
      !!BMi&(num)>(initNum):N(initNum);
    !!en;
  !!en;
!!en;


// Winged Magogs' Precision Fireball and Efreeti Rajahs' Flameguard Aura
// Precision Fireball
; Cancel the AOE damage for Infernao creatures (including hostile) from Magog's Fireball
; Note: The AI of Precision Fireball is not scripted. AIs are not aware that their Fireball no longer damage Inferno guys in an area
; Future plan: Make Precision Fireball toggleable
// Flameguard Aura
; Generate an Aura to protect adjacent units from Fire spell damage
!?FU(tum_OnCalcMonsterDamage);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(stackStruct:y);
!!UN:C(stackStruct)/244/4/?(side:y) C(stackStruct)/248/4/?(stackOfSide:y);
!!VR(atkStack:y):S(side) *(BATTLE_STACKS_PER_SIDE) +(stackOfSide);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EDI)/4/?(stackStruct:y);
!!UN:C(stackStruct)/244/4/?(side:y) C(stackStruct)/248/4/?(stackOfSide:y);
!!VR(defStack:y):S(side) *(BATTLE_STACKS_PER_SIDE) +(stackOfSide);

; Exit if the stack is the one being targeted
!!BG:E?(targetStack:y);
!!FU&(defStack)=(targetStack):E;

; Get monster types
!!BM(atkStack):T?(atkMon:y);
!!BM(defStack):T?(defMon:y);

; Check if the attacker has Precision Fireball
!!FU(tum_CheckIfMonHasPrecisionFireball):P(atkMon)/?(result:y);

!!if&(result);
  !!MA:O(defMon)/?(defTownType:y);

  !!if&(defTownType)=(TOWN_INFERNO);
    ; Jump if the the attacker has Precision Fireball and target is from Inferno
    !!SN:X?(var:y)/0;
    !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4454786;

    !!FU:E;
  !!en;
!!en;

; Check if the target has Flameguard Aura
!!FU(tum_CheckIfMonHasFlameguardAura):P(defMon)/?(result:y);

!!if&(result);
  ; Jump if the the target has Flameguard Aura
  !!SN:X?(var:y)/0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4454786;

; If the target doesn't have Flameguard Aura
!!el;
  ; Get the adjacent stacks and see if they have Flameguard Aura
  !!FU(tum_GetAdjacentStacksOfStack):P(defStack)/?(adjacentStacksList:y)/1/(FALSE)/(TRUE);
  !!SN:M(adjacentStacksList)/?(size:y);

  !!if&(size)>0;
    !!re i/0/(size)/1/-1;
      !!SN:M(adjacentStacksList)/i/?(adjacentStack:y);
      !!BM(adjacentStack):T?(type:y);
      !!FU(tum_CheckIfMonHasFlameguardAura):P(type)/?(result:y);

      !!if&(result);
        ; Jump if the there is one adjacent friendly unit has Flameguard Aura
        !!SN:X?(var:y)/0;
        !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4454786;

        !!br;
      !!en;
    !!en;
  !!en;
!!en;

; Cancel the damage of usual fire damaging spells
!?FU(OnDwarfMagicResistance)&i^tum_%(ART_ORB_OF_VULNERABILITY)_equipped^<>(TRUE);
!!MR:F?(resistance:y);

!!if&(resistance)<100;
  ; Check if the spell is a Fire damaging spell
  !!MR:S?(spell:y);
  !!SS(spell):S?(schoolBits:y);
  !!VR(isFireSpell:y):S(schoolBits) &2;

  !!if&(isFireSpell);
    !!SS(spell):F?(flags:y);
    !!VR(isDmgSpell:y):S(flags) &512;

    !!if&(isDmgSpell);
      !!MR:N?(spellTargetStack:y);
      !!FU(tum_GetAdjacentStacksOfStack):P(spellTargetStack)/?(adjacentStacksList:y)/1/(FALSE);
      !!SN:M(adjacentStacksList)/?(size:y);

      !!if&(size)>0;
        !!re i/0/(size)/1/-1;
          !!SN:M(adjacentStacksList)/i/?(adjacentStack:y);
          !!BM(adjacentStack):T?(type:y);
          !!FU(tum_CheckIfMonHasFlameguardAura):P(type)/?(result:y);

          !!if&(result);
            ; Set spell immunity to 100
            !!MR:F100;

            !!br;
          !!en;
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckIfMonHasPrecisionFireball);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_WINGED_MAGOG):S(TRUE);

!?FU(tum_CheckIfMonHasFlameguardAura);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_EFREETI_RAJAH):S(TRUE);


// Efreeti Rajahs' Flame Barrier
; Generate Fire Walls at the position of the attacker when melee attacked
; This makes Efreeti a worse nightmare for shooters
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkStack)>0/(defNum)>0;
  !!BM(defStack):T?(defMon:y);
  !!FU(tum_CheckIfMonHasFlameBarrier):P(defMon)/?(result:y);

  !!if&(result);
    !!FU(tum_GetStackHeadPosition):P(atkStack)/?(castPos:y);
    *!IF:L^%()%(castPos)^;
    !!BU:O(castPos)/?(obstacleFlags:y);

    !!if&(obstacleFlags)=0;
      !!BM(defStack):I?(defSide:y);
      !!FU(tum_Battle_CanStackBeAffectedBySpell):P(atkStack)/(SPELL_FIRE_WALL)/(defSide)/?(result);

      !!if&(result);
        !!VR(level:y):S(defNum) :10 F(SKILL_NOT_LEARNED)/(SKILL_EXPERT);
        !!VR(power:y):S(defNum) :2 F1/(INT_MAX);
        !!FU(tum_PlaceMagicObstacle):P(SPELL_FIRE_WALL)/(castPos)/(level)/(power)/(TRUE);
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckIfMonHasFlameBarrier);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_EFREETI_RAJAH):S(TRUE);


// Antichrists' Malevolent Reckoning
; Transfer 15% of physical damaged received and put on troops controlled by enenmy
; Doesn't work on the stack of the damage source - this means it would be helpful if you have only one stack
!?FU(OnStackToStackDamage_Quit);
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!BM(defStack):T?(mon:y);

; Calculate blocking damage
!!FU(tum_CheckMonMalevolentReckoningRate):P(mon)/?(dmgReductionRate:y);
!!FU&(dmgReductionRate)<=0:E;

!!VR(reducedDmg:y):S(dmgReductionRate) *(finalDmgConst) :100;
!!FU&(reducedDmg)<=0:E;

!!VR(newfinalDmg:y):S(finalDmg) -(reducedDmg);

!!if&(newfinalDmg)<(finalDmg);
  !!VR(finalDmg):S(newfinalDmg);

  !!FU&(isTheoretical):E;

  ; If not theoretical, store the amount of damage reduced
  !!VRi^tum_malevolentReckoningPhysDamage^:S(reducedDmg);
  *!FU(tum_DealMalevolentReckoningDamage):P(atkStack)/(defStack);
!!en;

; Redirect part of the damage after the attack finishes (or not)
*?FU(tum_DealMalevolentReckoningDamage);
!?FU(tum_OnAfterAttack)&i^tum_malevolentReckoningPhysDamage^;
!#VA(atkStack:x) (defStack:x);

!!BM(defStack):T?(defMon:y) N?(defNum:y);
!!FU(tum_CheckMonMalevolentReckoningRate):P(defMon)/?(dmgReductionRate:y);

!!if&(dmgReductionRate)>0/(defNum)>0;
  !!VR(victimStack:y):S(NO_STACK);

  ; Get the side by the side of the creature with Malevolent Reckoning - this is the best solution as it is possible that stacks are hypnotized
  !!BM(defStack):I?(side:y);
  !!VR(oppSide:y):S(side) X(TRUE);
  !!FU(tum_GetRandomLivingStackFromSide):P(oppSide)/?(victimStack:y)/(atkStack)/(TRUE)/(FALSE);
    
  ; If nothing ideal, get the attacker as the victim
  *!if&(victimStack)=(NO_STACK)/(atkStack)>(NO_STACK);
    *!BM(atkStack):N?(num:y);
    *!VR(victimStack)&(num)>0:S(atkStack);
  *!en;

  !!if&(victimStack)>(NO_STACK);
    !!BM(victimStack):Ki^tum_malevolentReckoningPhysDamage^;

    !!if&i^battle_isVisible^;
      !!FU(tum_UpdateStackAnimation):P;

      !!VR(defIsPlural:y):S(defNum) -1 B;
      !!SN:H^monname^/(defMon)/(defIsPlural)/?(defMonName:z);
      !!BM(victimStack):N?(victimNum:y);
      !!VR(victimIsPlural:y):S(victimNum) -1 B;
      !!BM(victimStack):T?(victimMon:y);
      !!SN:H^monname^/(victimMon)/(victimIsPlural)/?(victimMonName:z);
      !!SN:T^tumr.str.malevolentReckoning%(defIsPlural)^/?(battleLog:z)/^defMon^/(defMonName)/^dmg^/i^tum_malevolentReckoningPhysDamage^/^victimMon^/(victimMonName);
      !!MM:S(battleLog);
    !!en;

    !!FU(tum_ExecutePhoenixResurrection):P;
  !!en;
!!en;

!!VRi^tum_malevolentReckoningPhysDamage^:S0;

!?FU(tum_CheckMonMalevolentReckoningRate);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_ANTICHRIST):S15;


// Supreme Arch Mages' ranged spell casts
; Cast Weakness, Disrupting Ray or Magic Arrow depending on whether spell is applicable
; Similar as Sea Sorceress in HotA, but with Magic Arrow added when the target's defense is 0
!?FU(tum_OnAfterShoot);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):T?(type:y);
!!FU(tum_CheckIfMonCastsAfterShoot):P(type)/?(result:y);

!!if&(result);
  !!BM(atkStack):N?(atkNum:y);
  !!BM(defStack):N?(defNum:y);

  !!if&(atkNum)>0/(defNum)>0;
    !!VR(random:y):R0/0/99;
    !!FU&(random)<50:E;

    !!BM(atkStack):I?(atkSide:y);
    !!BM(defStack):G(SPELL_WEAKNESS)/?(spellDuration:y)/?(spellLevel:y);

    !!if&(spellDuration)<=0;
      !!FU(tum_Battle_CanStackReceiveSpell):P(defStack)/(SPELL_WEAKNESS)/(atkSide)/?(canReceive:y);

      !!if&(canReceive);
        !!VR(spell:y):S(SPELL_WEAKNESS);
      !!el;
        !!VR(spell):S(SPELL_DISRUPTING_RAY);
      !!en;
    !!el;
      !!VR(spell):S(SPELL_DISRUPTING_RAY);
    !!en;

    ; If Weakness is not applicable, check Disrupting Ray
    !!if&(spell)=(SPELL_DISRUPTING_RAY);
      !!FU(tum_Battle_CanStackReceiveSpell):P(defStack)/(SPELL_DISRUPTING_RAY)/(atkSide)/?(canReceive);
      !!BM(defStack):D?(def:y);         [Don't cast Disrupting Ray if Defense is at 0]

      ; If Disrupting Ray is not possible, check Magic Arrow
      !!if|(def)<=0/(canReceive)<>(TRUE);
        !!FU(tum_Battle_CanStackReceiveSpell):P(defStack)/(SPELL_MAGIC_ARROW)/(atkSide)/?(canReceive);
        !!VR(spell)&(canReceive):S(SPELL_MAGIC_ARROW);
      !!en;
    !!en;

    !!if&(canReceive);
      !!BM(defStack):P?(defPos:y);

      !!if|(spell)=(SPELL_WEAKNESS)/(spell)=(SPELL_DISRUPTING_RAY);
        !!VR(level:y):S(SKILL_ADVANCED);
        !!BM(atkStack):C(spell)/(defPos)/(level)/3/(TRUE);
      ; Magic Arrow
      !!el;
        !!FU(tum_CastMonsterDamagingSpell):P(atkStack)/(SPELL_MAGIC_ARROW)/(defPos)/3; [damage = num * 3]
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckIfMonCastsAfterShoot);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_SUPREME_ARCH_MAGE):S(TRUE);

*!VR(result)&(mon)=(MON_SORCERESS):S(TRUE);


// Ghouls' Feast
// This script must be executed earlier than flesheater (era scripts), as the clone flag would be interfered by that script
; Increase attack and defense after knocking down an enemy
!?FU(tum_OnBeforeMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(defStack):F?(monFlags:y);
!!VR(isAlive:y):S(monFlags) &(MON_FLAG_ALIVE);
!!VR(isClone:y):S(monFlags) &(MON_FLAG_CLONE);

!!if&(isAlive)/(isClone)=(FALSE);
  !!VRi^tum_feastActive^:S(TRUE);
!!en;

!?FU(tum_OnAfterMelee)&i^tum_feastActive^;
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkNum)>0/(defNum)<=0;
  !!BM(atkStack):T?(type:y);
  !!FU(tum_CheckMonFeastBonus):P(type)/?(bonus:y);

  !!if&(bonus)>0;
    ; Set up new attack and defense
    !!BM(atkStack):Ad(bonus) Dd(bonus);

    ; Show battle log and play animation/sound
    !!if&i^battle_isVisible^;
      !!VR(isPlural:y):S(atkNum) -1 B;
      !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
      !!SN:T^tumr.str.feast%(isPlural)^?(battleLog:z)/^mon^/(monName)/^bonus^/(bonus);
      !!MM:S(battleLog);

      ; Play sound and animation
      !!SN:P^mirth^;
      !!FU(tum_PlayCustomAnimationOnStack):P(atkStack)/^sp13_^/1;
    !!en;
  !!en;
!!en;

!!VRi^tum_feastActive^:S(FALSE);

!?FU(tum_CheckMonFeastBonus);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_GHOUL):S2;


// Vampire Elders' Bloodsurge Outburst
!?FU(OnBeforeBattleAction);
!!BG:A?(action:y);

!!if&(action)=(BATTLE_ACTION_WALK_AND_ATTACK);
  !!BMi^battle_acting_stack^:T?(type:y);
  !!FU(tum_CheckIfMonHasBloodSurgeOutburst):P(type)/?(result:y);

  !!if&(result);
    !!BMi^battle_acting_stack^:N?(num:y) B?(initNum:y) L?(lostHp:y);
    !!VR(isFull:y):S(FALSE);
    !!VR(isFull)&(num)>(initNum):S(TRUE);
    !!VR(isFull)&(num)=(initNum)/(lostHp)=0:S(TRUE);

    !!if&(isFull);
      !!BMi^battle_acting_stack^:F?(flags:y);
      !!VR(canAttacksAll:y):S(flags) &(MON_FLAG_ATTACKS_ALL_AROUND);

      !!if&(canAttacksAll)=(FALSE);
        !!VRi^tum_bloodSurgeFlag^:S(TRUE);
        !!BMi^battle_acting_stack^:Fd|(MON_FLAG_ATTACKS_ALL_AROUND);
      !!en;
    !!en;
  !!en;
!!en;

!?FU(OnBattleActionEnd)&i^tum_bloodSurgeFlag^;
!!BMi^battle_acting_stack^:Fd~(MON_FLAG_ATTACKS_ALL_AROUND);
!!VRi^tum_bloodSurgeFlag^:S0;

!?FU(tum_CheckIfMonHasBloodSurgeOutburst);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_VAMPIRE_ELDER):S(TRUE);


// Death Knights' Soul Reap
; Dealing more damage when the target is has the total health point below a certain percentage from the initial value. The bonus is calculated at the end of everything
!?FU(OnStackToStackDamage);
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU&(isDistant):E;

; Check if the attaker has Soul Reap
!!BM(atkStack):T?(mon:y);
!!FU(tum_CheckMonHasSoulReapThreshold):P(mon)/?(threshold:y);

!!if&(threshold);
  ; Exit if the target is not alive
  !!BM(defStack):F?(flags:y);
  !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);
  !!FU&(isAlive)=0:E;

  ; Exit if the number has overflow
  !!BM(defStack):B?(initNum:y) H?(hp:y);
  !!VR(totalStartHp:y):S(initNum) *(hp);
  !!FU&(totalStartHp)<=0:E;

  ; Exit if the target hasn't reached the threshold
  !!BM(defStack):N?(num:y) L?(lostHp:y);
  !!VR(totalHp:y):S(num) *(hp) -(lostHp);
  !!VR(totalHpPercentFloat:e):S(totalHp) :(totalStartHp);
  !!VR(thresholdFloat:e):S(threshold) :100; [Works only when the target is below a certain HP]
  !!FU&(totalHpPercentFloat)>=(thresholdFloat):E;

  ; Calculate the final damage based on how much health lost from the threshold. 1% for 3% damage bonus, plus the threshold
  !!VR(damageBonusFloat:e):S(thresholdFloat) -(totalHpPercentFloat) *3 +(thresholdFloat);

  !!VR(finalDmgConstFloat:e):S(finalDmgConst);
  !!VR(finalDmgFloat:e):S(finalDmg);
  !!VR(finalDmgNewFloat:e):S(finalDmgConstFloat) *(damageBonusFloat) +(finalDmgFloat);
  !!VR(finalDmgNew:y):S(finalDmgNewFloat);

  !!if&(finalDmgNew)>(finalDmg);
    !!VR(finalDmg):S(finalDmgNew);      [Fix overflow]

    !!if&(isTheoretical)/i^battle_isVisible^;
      !!VR(damageBonus:y):S100 *(damageBonusFloat);
      !!SN:T^tumr.str.soulReap^/?s^tum_extraBattleMonMouseHint^/^bonus^/(damageBonus);
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonHasSoulReapThreshold);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_DEATH_KNIGHT):S30;


// Red Bones Dragons' Drain Life
; Convert 80% of damage dealt to HP
!?FU(tum_OnDrainLife);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(stackStruct:y);
!!UN:C(stackStruct)/52/4/?(type:y);

!!if&(type)=(MON_RED_BONES_DRAGON);
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EDI)/4/?(eax:y);
  !!UN:C(eax)/4/?(hpDrain:y);
  !!VR(hpDrain)::5 *4;
  !!UN:C(eax)/4/(hpDrain);
!!en;


// Red Bones Dragons' Rite of Blood
; Resurrect dead living Dragons or Hydras to Red Bones Dragons with a rate
; This is similar to Pit Lord's demon raising but with a different calculation, works only on specific targets
!?FU(OnBattleMouseHint)&i^tum_customSpellActive^;
; Check monster position - only when the stack is killed completely
!!BU:Ei^mouse_battleHex^/?(targetStack:y);
!!FU&(targetStack)>(NO_STACK):E;

; Check again for bodies if there is no living stack at the position
!!BU&(targetStack)=(NO_STACK):Di^mouse_battleHex^/?(targetStack);

; Exit if no monster
!!FU&(targetStack)=(NO_STACK):E;

; Get side of the caster and the target
!!VR(currSide:y):Si^battle_current_side^;
!!BM(targetStack):I?(targetSide:y);
!!FU&(currSide)<>(targetSide):E;        [Disable reviving from hostile bodies]

; Get type and check the rate of rite of the current stack
!!BMi^battle_current_stack^:T?(currType:y);
!!FU(tum_GetRiteOfBloodRate):P(currType)/?(riteRate:y);
!!FU&(riteRate)<=0:E;

; Check if there are 20 stacks already - if the proposed stack to revive is hostile
!!FU(tum_CheckIfPossibleToSummonMoreStacks):P(currSide)/?(result:y);

!!if&(result)<>(TRUE);
  !!SN:T^tumr.str.tooManyStacks^/?(hint:z);
  !!MM:M^%(hint)^;
  !!FU:E;
!!en;

!!BMi^battle_current_stack^:N?(currNum:y);

; Show no spell hint if needed
!!BMi^battle_current_stack^:E?(spells:y);

!!if&(spells)<=0;
  !!VR(isPlural:y):S(currNum) -1 B;
  !!SN:H^monname^/(currType)/(isPlural)/?(monName:z);
  !!SN:T^tumr.str.noSpell%(isPlural)^/?(hint:z)/^mon^/(monName);
  !!MM:M^%(hint)^;
  !!FU:E;
!!en;

!!BM(targetStack):B?(targetInitNum:y);

; Exit if not possible to cast
!!FU(tum_CheckIfPossibleToCast):P4/?(result:y)/?(hint:z);

!!if&(result)<>(TRUE);
  !!MM&(hint)<>^^:M(hint);
  !!FU:E;
!!en;

; Check if the target is a living Dragon or Hydra
!!BM(targetStack):T?(targetType:y);
!!FU(tum_CheckIfMonIsLivingDragonOrHydra):P(targetType)/?(isLivingDragonOrHydra:y);

!!SN:H^monname^/(currType)/(TRUE)/?(currMonName:z);

; If not a living dragon or hydra, exit
!!if&(isLivingDragonOrHydra)=(FALSE);
  !!SN:T^tumr.str.riteOfBloodNotDragon^/?(hint)/^mon^/(currMonName);
  !!FU:E;
!!en;

; Check if the target is wide
!!BM(targetStack):Z?(targetStuct:y) P?(pos:y) F?(flags:y);
!!VR(isWide:y):S(flags) &(MON_FLAG_WIDE);

!!if&(isWide);
  !!UN:C(targetStuct)/68/4/?(secPosOrientation:y);

  !!if&(secPosOrientation)>=0;
    !!if&(secPosOrientation)=0;
      !!VR(secPos:y):S(pos) -1;
    !!el&(secPosOrientation)=1;
      !!VR(secPos:y):S(pos) +1;
    !!en;

    !!BU:E(secPos)/?(stackAbove:y);
    !!FU&(stackAbove)>(NO_STACK):E;
  !!en;
!!en;

; Get the total number of resurrection
!!VR(possibleNumRite:y):S(targetInitNum) :(riteRate);

!!if&(possibleNumRite)>0;
  !!VR(casterLimit:y):S(currNum) :(riteRate);
  !!VR(numRite:y):S(possibleNumRite) F0/(casterLimit);

  !!if&(numRite)>0;
    !!UN:R5/3/0;

    !!VR(riteIsPlural:y):S(numRite) -1 B;
    !!SN:H^monname^/(currType)/(riteIsPlural)/?(currMonName:z);
    !!VR(targetIsPlural:y):S(targetInitNum) -1 B;
    !!SN:H^monname^/(targetType)/(targetIsPlural)/?(targetMonName:z);
    !!SN:T^tumr.str.riteOfBloodMain^/?(hint:z)/^num^/(numRite)/^riteMon^/(currMonName)/^targetMon^/(targetMonName);
  !!el;
    !!VR(casterIsPlural:y):S(currNum) -1 B;
    !!SN:H^monname^/(currType)/(casterIsPlural)/?(currMonName);
    !!SN:T^tumr.str.riteOfBloodNotEnoughCaster%(casterIsPlural)^/?(hint)/^mon^/(currMonName);
  !!en;
!!el;
  !!SN:T^tumr.str.riteOfBloodNotEnoughBody^/?(hint)/^mon^/(currMonName);
!!en;

!!MM:M(hint);

!?FU(OnBattleScreenMouseClick)&i^mouse_action^=(MOUSE_LMB_PRESSED)/i^tum_customSpellActive^;
; Check monster position - only when the stack is killed completely
!!BU:Ei^mouse_battleHex^/?(targetStack:y);
!!FU&(targetStack)>(NO_STACK):E;

; Check again for bodies if there is no living stack at the position
!!BU&(targetStack)=(NO_STACK):Di^mouse_battleHex^/?(targetStack);
; Exit if no monster
!!FU&(targetStack)=(NO_STACK):E;

; Get side of the caster and the target
!!VR(currSide:y):Si^battle_current_side^;
!!BM(targetStack):I?(targetSide:y);
!!FU&(currSide)<>(targetSide):E;        [Disable reviving from hostile bodies]

; Get type and check the rate of rite of the current stack
!!BMi^battle_current_stack^:T?(currType:y);
!!FU(tum_GetRiteOfBloodRate):P(currType)/?(riteRate:y);
!!FU&(riteRate)<=0:E;

; Check if there are 20 stacks already - if the proposed stack to revive is hostile
!!FU(tum_CheckIfPossibleToSummonMoreStacks):P(currSide)/?(result:y);
!!FU&(result)<>(TRUE):E;

!!BMi^battle_current_stack^:N?(currNum:y);

!!BMi^battle_current_stack^:E?(spells:y);
!!FU&(spells)<=0:E;

!!BM(targetStack):B?(targetInitNum:y);

; Exit if not possible to cast
!!FU(tum_CheckIfPossibleToCast):P3/?(result:y);
!!FU&(result)<>(TRUE):E;

; Check if the target is a living dragon or hydra
!!BM(targetStack):T?(targetType:y);
!!FU(tum_CheckIfMonIsLivingDragonOrHydra):P(targetType)/?(isLivingDragonOrHydra:y);
!!FU&(isLivingDragonOrHydra)<>(TRUE):E;

; Check if the target is wide
!!BM(targetStack):Z?(targetStuct:y) P?(pos:y) F?(flags:y);
!!VR(isWide:y):S(flags) &(MON_FLAG_WIDE);

!!if&(isWide);
  !!UN:C(targetStuct)/68/4/?(secPosOrientation:y);

  !!if&(secPosOrientation)>=0;
    !!if&(secPosOrientation)=0;
      !!VR(secPos:y):S(pos) -1;
    !!el&(secPosOrientation)=1;
      !!VR(secPos:y):S(pos) +1;
    !!en;

    !!BU:E(secPos)/?(stackAbove:y);
    !!FU&(stackAbove)>(NO_STACK):E;
  !!en;
!!en;

; Get the total number of resurrection
!!VR(possibleNumRite:y):S(targetInitNum) :(riteRate);
!!VR(casterLimit:y):S(currNum) :(riteRate);
!!VR(numRite:y):S(possibleNumRite) F0/(casterLimit);
!!FU&(numRite)<=0:E;

!!FU(tum_ExecuteRiteOfBlood):P(numRite)/(currType)/(targetStack)/(isWide)/(currSide)/(secPos)/(pos)/(targetSide);

!!VR(oppSide:y):S(currSide) X(TRUE);
!!IP:Di^battle_owner_%(oppSide)^;
!!FU(tum_ExecuteRiteOfBlood):D(numRite)/(currType)/(targetStack)/(isWide)/(currSide)/(secPos)/(pos)/(targetSide);

!?FU(tum_ExecuteRiteOfBlood);
!#VA(numRite:x) (currType:x) (targetStack:x) (isWide:x) (currSide:x) (secPos:x) (pos:x) (targetSide:x);

; Play the casting animation manually
!!BMi^battle_current_stack^:P?(currPos:y);

; Get real coordinates of hexes
!!FU(tum_GetCoordsOfHex):P(currPos)/?(currX:y)/?(currY:y) Pi^mouse_battleHex^/?(targetX:y)/?(targetY:y);

; Check if it is required to turn around
!!VR(mustTurnAround:y):S(FALSE);
!!BMi^battle_current_stack^:I?(realSide:y);

!!if&(currX)<(targetX);
  !!VR(mustTurnAround)&(realSide)=(BATTLE_RIGHT):S(TRUE);
!!el&(currX)>(targetX);
  !!VR(mustTurnAround)&(realSide)=(BATTLE_LEFT):S(TRUE);
!!en;

; Get the group of frame for animation
!!if&(currY)<(targetY);
  !!VR(group:y):S11;
!!el&(currY)=(targetY);
  !!VR(group):S12;
!!el;
  !!VR(group):S13;
!!en;

; Get data
!!BMi^battle_current_stack^:Z?(stackStruct:y);

; Turn around
!!SN&(mustTurnAround):E4482112/(CALLCONV_THISCALL)/(stackStruct)/1;

; Battle log
!!VR(riteIsPlural:y):S(numRite) -1 B;
!!SN:H^monname^/(currType)/(riteIsPlural)/?(monName:z);
!!SN:T^tumr.str.res%(riteIsPlural)^/?(battleLog:z)/^num^/(numRite)/^mon^/(monName);
!!MM:S(battleLog);

; Sound
!!SN:P^resurect^;

; Play animation
!!FU(tum_BattleStack_PlayAnimation):P(stackStruct)/(group)/(FALSE);

; Restore the cursor to default - for the current acting player only
!!OW:C?(currPlayer:y)/?(interactPlayer:y);

!!re i/0/1;
  !!if&i^battle_owner_%i^=(interactPlayer);
    !!CM:R0;
    !!UN:R5/0/0;

    !!br;
  !!en;
!!en;

; Remove the dead body
; Here the stack slot is still occupied even if it's removed from the battlefield
!!FU(tum_RemoveDeadBody):P(targetStack);

; Summon current monster on the body
; Correct the position if the target and the current player (actual) is not on the same side and is wide
!!if&(isWide);
  !!if&(currSide)=(BATTLE_LEFT);
    !!if&(secPos)<(pos);
      !!VR(summPos:y):S(secPos);
    !!el;
      !!VR(summPos):S(pos);
    !!en;
  !!el;
    !!if&(secPos)>(pos);
      !!VR(summPos):S(secPos);
    !!el;
      !!VR(summPos):S(pos);
    !!en;
  !!en;
!!en;

; Correct slot if needed
!!if&(targetSide)=(currSide);
  !!BM(targetStack):O?(slot:y);
!!el;
  !!VR(slot):S-1;
!!en;

!!BU:S(currType)/(numRite)/(summPos)/(currSide)/(slot)/(TRUE);

; Manage stuff after summoning
!!BU:E(summPos)/?(summonStack:y);

!!if&(summonStack)>(NO_STACK);
  !!BM(summonStack):Fd|(MON_FLAG_UNUSED_1);
!!en;

; Turn back
!!SN&(mustTurnAround):E4482112/(CALLCONV_THISCALL)/(stackStruct)/1;
!!SN:D;

; Reduce 1 spell
!!BMi^battle_current_stack^:Ed-1;
!!FU(tum_FixXEMonsterSpellCountCompatibility):P; [ACM compatiblity]

; Pass the turn
!!BG:A(BATTLE_ACTION_SKIP);

!?FU(tum_GetRiteOfBloodRate);
; Rate of Rite of Blood = how many dragons/hydras required to summon the current monster
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_RED_BONES_DRAGON):S7;

!?FU(tum_CheckIfMonIsLivingDragonOrHydra);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);

!!MA:L(mon)/?(level:y);
!!FU&(level)<>(MON_MAX_LEVEL):E;

!!MA:X(mon)/?(flags:y);
!!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);
!!FU&(isAlive)=0:E;

!!VR(isDragon:y):S(flags) &(MON_FLAG_DRAGON);
!!VR(isHydra:y)|(mon)=(MON_HYDRA)/(mon)=(MON_CHAOS_HYDRA)/(mon)=(MON_HELL_HYDRA)/(mon)=(MON_NIGHTMARE_HYDRA):S(TRUE);

!!VR(result)|(isDragon)/(isHydra):S(TRUE);

; Collect Rite of Blood summoned units at the end of battle
; Warning: This script assumes Rite of Blood stacks not in the army (BM:O=-1) plus unused flag should be collect. 
; If there is any other source of summoning, the script would be broken.
!?FU(OnAfterBattleAction);
!!BU:C?(battleIsEnded:y);

!!if&(battleIsEnded);
  !!re i/(BATTLE_LEFT)/(BATTLE_RIGHT);
    !!FU(tum_AccumRiteOfBloodMonstersAfterBattle):Pi;
  !!en;
!!en;

!?FU(tum_AccumRiteOfBloodMonstersAfterBattle);
!#VA(side:x);

; Loop through all the all stacks and calculate the amount of Fangarms that is not in the army (BM:O=-1)
!!if&(side)=(BATTLE_LEFT);
  !!VR(firstStack:y):S(BATTLE_ATTACKER_STACK_FIRST);
!!el;
  !!VR(firstStack):S(BATTLE_DEFENDER_STACK_FIRST);
!!en;

!!VR(lastStack:y):S(firstStack) +20;

!!FU(NewIntArray):P?(riteOfBloodMon:y) P?(riteOfBloodNum:y);

; Loop through all the stacks and see if there is any stacks summoned by Rite of Blood
!!re i/(firstStack)/(lastStack);
  !!BMi:N?(num:y) O?(slot:y);
  
  !!if&(num)>0/(slot)=-1;
    !!BMi:F?(flags:y);
    !!VR(isSummoned:y):S(flags) &(MON_FLAG_UNUSED_1);
    !!co&(isSummoned)=(FALSE);

    !!BMi:T?(type:y);
    !!FU(tum_GetRiteOfBloodRate):P(type)/?(rate:y);

    !!if&(rate)>0;
      !!SN:M(riteOfBloodMon)/?(size:y);

      ; If the monster type hasn't been stored, store it
      !!if&(size)=0;
        !!FU(Array_Push):P(riteOfBloodMon)/(type) P(riteOfBloodNum)/(num);
      ; If the monster type has been stored, accumulate the number
      !!el;
        !!re j/0/(size)/1/-1;
          !!SN:M(riteOfBloodMon)/j/?(riteMon:y);

          !!br&(type)=(riteMon);
        !!en;

        !!if&j<(size);
          !!SN:M(riteOfBloodNum)/j/d(num);
        !!el;
          !!FU(Array_Push):P(riteOfBloodMon)/(type) P(riteOfBloodNum)/(num);
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

; Add the Rite of Blood monsters from the array to the army
!!SN:M(riteOfBloodMon)/?(size:y);

!!if&(size)>0;
  !!re i/0/(size)/1/-1;
    !!SN:M(riteOfBloodMon)/i/?(riteMon:y) M(riteOfBloodNum)/i/?(riteNum:y);

    ; Check if there is any Rite of Blood monster stack
    !!re j/(ARMY_SLOT_FIRST)/(ARMY_SLOT_LAST);
      !!BAi:M(side)/j/?(mon:y)/?(num:y);

      !!br&(mon)=(riteMon);
    !!en;

    ; If nothing found, check empty slot instead
    !!if&j>(ARMY_SLOT_LAST);
      !!re j/(ARMY_SLOT_FIRST)/(ARMY_SLOT_LAST);
        !!BAi:M(side)/j/?(mon)/?(num);

        !!br&(mon)=(NO_MON);
      !!en;
    !!en;

    ; If either Rite of Blood monster or empty slot found, add in the Rite of Blood monster
    !!if&j<=(ARMY_SLOT_LAST);
      !!VR(num):F0/(INT_MAX) +(riteNum);
      !!BAi:M(side)/j/(riteMon)/(num);

      !!br;
    !!en;
  !!en;
!!en;


// Harpy Sanguinarys' Voodoo
; by Feanor
; This script is disabled since it should only be activated when the player choose to Strike and Return
*?FU(OnBeforeBattleAction); 
*!BG:A?(action:y) E?(defStack:y);
*!BMi^battle_acting_stack^:T?(atkMon:y);
*!VR(random:y):R0/0/3;
*!VR(random):S0;

*!if&(defStack)>(NO_STACK)/(atkMon)=(MON_HARPY_SANGUINARY)/(action)=(BATTLE_ACTION_WALK_AND_ATTACK)/(random)=0;
  ; Attack the stack remotely
  *!BMi^battle_acting_stack^:Z?(atkStruct:y);
  *!BM(defStack):Z?(defStruct:y);
  *!SN:E4461360/2/(atkStruct)/(defStruct)/2;

  ; Cast spell
  *!FU(tum_CastSpellAfterAttack):Pi^battle_acting_stack^/(defStack)/100/(SPELL_CURSE)/10;

  ; Disable the orignal action
  *!BG:A(BATTLE_ACTION_SKIP);
*!en;


// Harpy Sanguinarys' Bad Reaction
; Casts a spell that counters one of the friendly spell possessed by the defending target on attacking
; Pairs: Haste -> Slow, Bless -> Curse, Fortune -> Misfortune, Mirth -> Sorrow
; If Slow or Curse are casted, the correspond beneficial spells would also be dispelled - that's the original H3 mechanism.
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkNum)>0/(defNum)>0;
  !!BM(atkStack):T?(atkMon:y);
  ; Check if the attacker has Bad Reaction
  !!FU(tum_CheckIfMonHasBadReaction):P(atkMon)/?(result:y);

  !!if&(result);
    ; Check if the victim has any friendly spell buff that can be countered
    !!FU(NewIntArray):P?(friendlyBuffs:y);

    !!VR(spells[4]:y):C(SPELL_BLESS)/(SPELL_HASTE)/(SPELL_FORTUNE)/(SPELL_MIRTH);

    !!re i/0/3;
      !!BM(defStack):G(spells[i])/?(duration:y)/?(level:y);
      !!FU(Array_Push)&(duration)>0:P(friendlyBuffs)/(spells[i]);
    !!en;

    !!SN:M(friendlyBuffs)/?(size:y);

    !!if&(size)>0;
      !!VR(random:y):R0/1/(size) -1;
      !!SN:M(friendlyBuffs)/(random)/?(targetSpell:y);

      ; Get countering spell ID
      !!VR(counterSpell:y):S(targetSpell) +1;
      ; Check if the target monster has already prossessed the countering spell
      !!BM(defStack):G(counterSpell)/?(duration)/?(level);

      !!if&(duration)<=0;
        ; Check if the target monster can receive the countering spell
        !!BM(atkStack):I?(side:y);
        !!FU(tum_Battle_CanStackReceiveSpell):P(defStack)/(counterSpell)/(side)/?(canReceive:y);

        !!if&(canReceive);
          ; Get the info of the buff being countered
          !!BM(defStack):G(targetSpell)/?(duration)/?(level);
          ; Set max level for casting to Advanced
          !!VR(level):F(SKILL_NOT_LEARNED)/(SKILL_ADVANCED);
          ; Cast the countering spell
          !!BM(defStack):P?(pos:y);
          !!BM(atkStack):C(counterSpell)/(pos)/(level)/(duration)/(TRUE);
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckIfMonHasBadReaction);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_HARPY_SANGUINARY):S(TRUE);


// Chimeras' Tri Attack
; Cast different spells on 3-headed attack secondary targets according to the direction
; Left head: Weakness, Right head: Disrupting Ray
!?FU(tum_OnBeforeMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):T?(type:y);
!!FU(tum_CheckMonHasTriAttackChance):P(type)/?(hasElemBlast:y);

!!if&(hasElemBlast);
  !!FU(NewIntArray):P?i^tum_triAttackList^/(M_TEMP);
  !!FU(Array_Push):Pi^tum_triAttackList^/(atkStack);
!!en;

!?FU(OnStackToStackDamage)&i^tum_triAttackList^;
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU|(isDistant)/(isTheoretical):E;

!!SN:Mi^tum_triAttackList^/0/?(savedStack:y);
!!FU(Array_Push)&(atkStack)=(savedStack):Pi^tum_triAttackList^/(defStack);

!?FU(tum_OnAfterMelee)&i^tum_triAttackList^;
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):T?(type:y);
!!FU(tum_CheckMonHasTriAttackChance):P(type)/?(chance:y);

!!VR(isThirdTarget:y):S(FALSE);
!!BM(atkStack):I?(atkSide:y);
!!SN:Mi^tum_triAttackList^/?(size:y);

!!re i/1/(size)/1/-1;
  !!SN:Mi^tum_triAttackList^/i/?(targetStack:y);

  ; Check if it is the target of the middle - if it is, skip it and we know that the next target is the third target
  !!if&(targetStack)=(defStack);
    !!VR(isThirdTarget):S(TRUE);

    !!co;
  !!en;

  ; Execute Tri Attack only when the target is alive
  !!BM(targetStack):N?(num:y);

  !!if&(num)>0;
    !!if&(isThirdTarget)=(FALSE);
      !!FU(tum_CastSpellAfterAttack):P(atkStack)/(targetStack)/(chance)/(SPELL_WEAKNESS)/(SKILL_ADVANCED);
    !!el;
      !!FU(tum_CastSpellAfterAttack):P(atkStack)/(targetStack)/(chance)/(SPELL_DISRUPTING_RAY)/(SKILL_ADVANCED);
    !!en;
  !!en;
!!en;

!!SN:Mi^tum_triAttackList^;
!!VRi^tum_triAttackList^:S0;

!?FU(tum_CheckMonHasTriAttackChance);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_CHIMERA):S50;


// Chasm Dragon's Reflection
; Create a mirror image after each attack (excluding retaliation) with a chance
; The location of the image is depending on whether the attacking stack has Striked and Returned. 
; There is no check for the max amount of image created. It might be added in the future (like 1 image for 1 stack at max, shared the limit with Mirror spell)
; The clones last 2 turns
!?FU(OnBeforeBattleAction);
!!BG:A?(action:y);

!!if&(action)=(BATTLE_ACTION_WALK_AND_ATTACK);
  !!BMi^battle_acting_stack^:T?(type:y);

  !!FU(tum_CheckMonReflectionChance):P(type)/?(result:y);

  !!if&(result);
    ; Skip if it is a clone
    !!BMi^battle_acting_stack^:F?(flags:y);
    !!VR(isClone:y):S(flags) &(MON_FLAG_CLONE);
    !!FU&(isClone):E;

    !!BMi^battle_acting_stack^:P?i^tum_reflectionStartPos^;
  !!en;
!!en;

!?FU(tum_BeforeStackMeleeAttack)&i^tum_reflectionStartPos^; [This hook doesn't trigger for retaliation]
!!BMi^battle_acting_stack^:P?i^tum_reflectionEndPos^;

!?FU(OnBattleActionEnd)&i^battle_acting_stack^>(NO_STACK)/i^tum_reflectionStartPos^>0/i^tum_reflectionEndPos^>0;
; Check if there are 20 stacks already
!!BG:Q?(actSide:y);
!!FU(tum_CheckIfPossibleToSummonMoreStacks):P(actSide)/?(result:y);

!!if&(result)<20;
  ; Make sure the unit hasn't been transmuted
  !!BMi^battle_acting_stack^:T?(type:y) N?(num:y);
  !!FU(tum_CheckMonReflectionChance):P(type)/?(chance:y);

  !!if&(num)>0/(chance);
    ; Exit if the stack has an existing clone
    *!BMi^battle_acting_stack^:U5/?(existingCloneStack:y);
    *!FU&(existingCloneStack)<>(NO_STACK):E;

    ; Exit if the stack is a clone itself
    !!BMi^battle_acting_stack^:F?(flags:y);
    !!VR(isClone:y):S(flags) &(MON_FLAG_CLONE);
    !!FU&(isClone):E;

    !!VR(random:y):R0/0/99;

    !!if&(random)<(chance);
      !!BMi^battle_acting_stack^:P?(currPos:y);

      !!if&(currPos)=i^tum_reflectionStartPos^;
        !!VR(summonPos:y):Si^tum_reflectionEndPos^;
      !!el;
        !!VR(summonPos):Si^tum_reflectionStartPos^;
      !!en;

      !!FU(tum_GetValidPositionToSummon):P(type)/(actSide)/(summonPos)/?(summPos:y);

      !!if&(summPos)>-1;
        ; Calculate the number of summon
        !!VR(summNum:y):S(num);

        ; Summon only when the quantity is more than 0
        !!if&(summNum)>0;
          ; Sound, animation and battle log
          !!if&i^battle_isVisible^;
            !!VR(isPlural:y):S(num) -1 B;
            !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
            !!SN:T^tumr.str.reflection%(isPlural)^/?(battleLog:z)/^mon^/(monName);
            !!MM:S(battleLog);

            !!SN:P^fear^;
          !!en;

          ; Summon Clone and change flags
          !!BU:S(type)/(summNum)/(summPos)/(actSide)/-1/1;

          !!BU:E(summPos)/?(stack:y);

          !!if&(stack)>(NO_STACK);
            ; Set up clone stack attributes
            !!VR(summonedCloneFlags:y):S(MON_FLAG_SUMMONED) +(MON_FLAG_CLONE);
            !!BM(stack):Fd|(summonedCloneFlags);

            ; Set clone info
            ; Here we no longer use BM:U5 as seems to lead to an crash when the stack is killed, and its clone is still alive
            ; 0x24 seemms to be the address when a clone is killed and the stack ID here would be used to clear BM:U5. Check 00444140
            *!BMi^battle_acting_stack^:U5/(stack); [Kill the clone when the original stack is killed]
            *!BMi^battle_acting_stack^:Z?(stackStruct:y); [Clear the clone info of the orignal stack when the clone stack is killed]
            *!UN:C(stackStruct)/40/4/(stack);
            !!BM(stack):Z?(cloneStruct:y); [Clear the clone info of the orignal stack when the clone stack is killed]
            !!UN:C(cloneStruct)/44/4/3; [2 turns, the number here should be +1]

            ; Set up stack exp
            !!UN:P(WOG_OPT_STACK_EXPERIENCE)/?(stackExp:y);

            !!if&(stackExp);
              !!VR(eaStackAct:y):Si^battle_acting_stack^ +1 *-1;
              !!VR(eaStackClone:y):S(stack) +1 *-1;
              ; Copy stack exp abilities
              !!EA(eaStackClone):O(eaStackAct);
              ; Set up exp
              !!EA(eaStackAct):E?(exp:y)/2/d/d;
              !!EA(eaStackClone):E(exp)/2/d/d;
            !!en;

            ; Mark as triggered
            *!VRi^tum_abilityCounter_%i(battle_acting_stack)^:+1;

            *!FU(BattleStack_MakeActive):P(stack); [Make the clone active - doesn't seem to work]
          !!en;
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!!VRi^tum_reflectionStartPos^:S0;
!!VRi^tum_reflectionEndPos^:S0;

!?FU(tum_CheckMonReflectionChance);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_CHASM_DRAGON):S33;


// Orc Leaders' Axe Rampage
; Damage of Orc Leaders (throwing axes) depends quadratically on the distance to the target.
; Bersy's original Formula: Base damage * (19 - distance) ^ 2 / 100%.
; New Formula: New damage = original damage * (19 - distance) / 10. The new damage cannot be lower than the original
!?FU(OnStackToStackDamage);
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU&(isDistant)<>(TRUE):E;

; Check if the monster has Axe Rampage
!!BM(atkStack):T?(type:y);
!!FU(tum_CheckIfMonHasAxeRampage):P(type)/?(result:y);

!!if&(result);
  ; Calculate the damage based on distance. Apply the new damage only when the new damage is greater
  !!VR(bonus:y):S11 -(distanceArg) *5 F0/100;

  !!if&(bonus)>0;
    !!VR(finalDmgNew:y):S(finalDmgConst) *(bonus) :100 +(finalDmg);

    !!if&(finalDmgNew)>(finalDmg);
      !!if&(isTheoretical)/i^battle_isVisible^;
        !!SN:T^tumr.str.axeRampage^/?s^tum_extraBattleMonMouseHint^/^bonus^/(bonus);
      !!en;

      !!VR(finalDmg):S(finalDmgNew);
    !!en;
  !!en;
!!en;

!?FU(tum_CheckIfMonHasAxeRampage);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_ORC_LEADER):S(TRUE);


// Cyclops Emperors' Impervious to Pain
; Put off the timing of physical damage done to Cyclops Emperors
; Here there are different implementations. But any of these have the common issue: not having good interaction with stack exp blocking
; Even if blocked the damage, Cyclops would still be damaged with their ability

; Alternative approach
; This is for ignoring all the damage. It is disabled as it seems when inflicting an AOE spell (like Fire Ball), the damage doesn't get ignored on all the stacks
; tum_abilityCounter3_ is reset to 0 every turn
*?FU(tum_OnDoDamage);
*#VA(hook:x);

*!if&i^tum_mustDoDamage^=(FALSE);
  *!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(stackStruct:y);
  *!UN:C(stackStruct)/52/4/?(type:y);

  *!FU(tum_CheckIfMonHasImperviousToPain):P(type)/?(result:y);

  *!if&(result);
    *!UN:C(stackStruct)/244/4/?(side:y) C(stackStruct)/248/4/?(stackOfSide:y);
    *!VR(stack:y):S(side) *(BATTLE_STACKS_PER_SIDE) +(stackOfSide);
    *!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ECX)/4/?(damage:y);
    *!VRi^tum_abilityCounter2_%(stack)^:+(damage);
    *!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ECX)/4/0;

    *!if&i^battle_isVisible^;
      *!BM(stack):N?(num:y);
      *!VR(isPlural:y):S(num) -1 B;
      *!SN:H^monname^/(type)/(isPlural)/?(monName:z);
      *!SN:T^tumr.str.imperviousToPainNeglect%(isPlural)^/?(battleLog:z)/^mon^/(monName);
      *!MM:S(battleLog);
    *!en;
  *!en;
*!en;

*!VRi^tum_mustDoDamage^:S(FALSE);

; Latest implementation
; Ignore Physical damage until the end of stack turn
; This means the stack can always intiates an attack safely if not hit by spells
!?FU(OnMonsterPhysicalDamage_Quit);
!!FU(tum_GetMonsterPhysicalDamageType):P?(dmgType:y);
!!FU|(dmgType)<0/(dmgType)>2:E;

; Get the stack being hit
!!MF:N?(defStack:y);
!!BM(defStack):T?(type:y);
!!FU(tum_CheckIfMonHasImperviousToPain):P(type)/?(result:y);

!!if&(result);
  !!MF:F?(damage:y);
  !!VR(newDamage:y):S(damage) +i^tum_abilityCounter2_%(defStack)^;
  !!VRi^tum_abilityCounter2_%(defStack)^&(newDamage)>i^tum_abilityCounter2_%(defStack)^:S(newDamage);
  !!MF:F0;
  !!MF:E0;                              [don't show damage animation]

  !!if&i^battle_isVisible^;
    !!BM(defStack):N?(num:y);
    !!VR(isPlural:y):S(num) -1 B;
    !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
    !!SN:T^tumr.str.imperviousToPainNeglect%(isPlural)^/?(battleLog:z)/^mon^/(monName)/^dmg^/(damage);
    !!MM:S(battleLog);
  !!en;
!!en;

; Inflict damage at the start of round
!?FU(OnBattleRound)&i^battle_round^>0;
!!VR(inflictedDamage:y):S(FALSE);

!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!co&i^tum_abilityCounter2_%i^=0;

  !!BMi:N?(num:y);

  !!if&(num)>0;
    !!BMi:T?(type:y);
    !!FU(tum_CheckIfMonHasImperviousToPain):P(type)/?(result:y);

    !!if&(result);
      !!VR(damage:y):Si^tum_abilityCounter2_%i^;
      !!BMi:K(damage);
      !!VRi^tum_abilityCounter2_%i^:S0;

      !!if&i^battle_isVisible^;
        !!FU(tum_UpdateStackAnimation):P;

        !!VR(isPlural:y):S(num) -1 B;
        !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
        !!SN:T^tumr.str.imperviousToPainInflict%(isPlural)^/?(battleLog:z)/^mon^/(monName)/^dmg^/(damage);
        !!MM:S(battleLog);
      !!en;
    !!en;
  !!en;
!!en;

; Inflict damage at the end of turn, starting from the second turn only
; Don't do it OnBattleAction End as it is buggy, the stack would still stand when it should be killed
; Disable as it results in crash
*?FU(OnBattleActionEnd)&i^battle_round^>=0;
; Exit if it is not an action that would pass to the next turn
*!BG:A?(action:y);
*!FU&(action)<>(BATTLE_ACTION_WALK)/(action)<>(BATTLE_ACTION_DEFEND)/(action)<>(BATTLE_ACTION_WALK_AND_ATTACK)
  /(action)<>(BATTLE_ACTION_SHOOT)/(action)<>(BATTLE_ACTION_WAIT):E;

*!VR(stack:y):Si^battle_current_stack^;

*!BM(stack):T?(type:y);
*!FU(tum_CheckIfMonHasImperviousToPain):P(type)/?(result:y);

*!if&(result);
  *!BM(stack):T?(num:y);

  *!VR(damage:y):Si^tum_abilityCounter2_%i(battle_current_stack)^;

  *!if&(damage);
    *!VR(damage)&(damage)<0:S(INT_MAX);

    *!BM(stack):K(damage);
    *!VRi^tum_abilityCounter2_%i(battle_current_stack)^:S0;

    *!if&i^battle_isVisible^;
      *!VR(isPlural:y):S(num) -1 B;
      *!SN:H^monname^/(type)/(isPlural)/?(monName:z);
      *!SN:T^tumr.str.imperviousToPainInflict%(isPlural)^/?(battleLog:z)/^mon^/(monName)/^dmg^/(damage);
      *!MM:S(battleLog);

      *!FU(tum_UpdateStackAnimation):P;
    *!en;

    *!FU(tum_ExecutePhoenixResurrection):P;

    ; Find next stack turn if needed - is it needed?
    *!BM(stack):N?(num:y);

    *!if&(num)<=0;
      *!UN:C(COMBAT_MANAGER)/4/?(cmbMgr:y);
      *!SN:E4607072/(CALLCONV_THISCALL)/(cmbMgr)/(TRUE);
    *!en;
  *!en;
*!en;

!?FU(tum_CheckIfMonHasImperviousToPain);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_CYCLOPS_EMPEROR):S(TRUE);


// Spectral Behemoth and Rats' Remove Defense (reduce defense by 100%)
// Cleaving Blow (chance to ignore defense)
// Recreated these abilities to get rid of the crap from Amethyst
; Second implementation for Remove defense only
; Didn't work for some reason. The hook isn't triggered
*?FU(tum_OnBehemothReduceDefenseProc);
*!FU:E;

*#VA(hook:x);

*!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EDX)/4/?(stackStruct:y);
*!UN:C(stackStruct)/52/4/?(type:y);

*!FU(tum_CheckIfMonCanRemoveDefense):P(type)/?(result:y);

*!if&(result);
  *!SN:X?t/0;
  *!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/7722330; 
*!en;

; Define creatures to have the ability here
*?FU(tum_CheckIfMonCanRemoveDefense);
*#VA(mon:x) (result:x);

*!VR(result):S(FALSE);
*!VR(result)&(mon)=(MON_SPECTRAL_BEHEMOTH):S(TRUE);
*!VR(result)|(mon)=(MON_RAT)/(mon)=(MON_BATTLE_RAT):S(TRUE);

; First implementation
; Restore memory hacks
!?FU(OnBeforeBattleUniversal);
!!UN:C7722324/(UNC_INT)/(MON_GHOST_BEHEMOTH); 7722324

!?FU(OnSetupBattlefield);
!!UN:C7722324/(UNC_INT)/(MON_GHOST_BEHEMOTH);

; Change removed defense monster to the current monster (for displaying correct hint)
!?FU(OnBattleStackObtainsTurn);
!!UN:C7722324/(UNC_INT)/(MON_GHOST_BEHEMOTH);

!!BMi^battle_current_stack^:T?(mon:y);
!!FU(tum_CheckMonChanceToRemovesDefense):P(mon)/?(chance:y);
!!UN&(chance)=100:C7722324/(UNC_INT)/(mon);

; Restore memory hacks
!?FU(OnAfterBattleUniversal);
!!UN:C7722324/(UNC_INT)/(MON_GHOST_BEHEMOTH);

!?FU(OnGameLeave);
!!UN:C7722324/(UNC_INT)/(MON_GHOST_BEHEMOTH);

; Change removed defense monster to acting monster (for correct damage calculation on retaliation) & Cleaving Blow
!?FU(tum_OnBeforeMelee);
!#VA(atkStack:x) (defStack:x);

!!UN:C7722324/(UNC_INT)/(MON_GHOST_BEHEMOTH);

!!BM(atkStack):T?(atkType:y);
!!FU(tum_CheckMonChanceToRemovesDefense):P(atkType)/?(chance:y);

!!if&(chance)>0;
  !!VR(random:y):R0/0/99;

  !!if&(random)<(chance);
    !!UN:C7722324/(UNC_INT)/(atkType);

    ; Cleaving Blow (only for chance < 100%)
    !!if&i^battle_isVisible^/(chance)<100;
      !!BM(atkStack):N?(atkNum:y);
      !!VR(atkIsPlural:y):S(atkNum) -1 B;
      !!SN:H^monname^/(atkType)/(atkIsPlural)/?(atkMonName:z);
      !!BM(defStack):N?(defNum:y) T?(defType:y);
      !!VR(defIsPlural:y):S(defNum) -1 B;
      !!SN:H^monname^/(defType)/(defIsPlural)/?(defMonName:z);
      !!SN:T^tumr.str.cleavingBlow%(atkIsPlural)^/?(battleLog:z)/^atkMon^/(atkMonName)/^defMon^/(defMonName);
      !!MM:S(battleLog);
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonChanceToRemovesDefense);
!#VA(mon:x) (result:x);

!!VR(result)&(mon)=(MON_SPECTRAL_BEHEMOTH):S100;
!!VR(result)|(mon)=(MON_RAT)/(mon)=(MON_BATTLE_RAT):S100;

; Cleaving Blow (a chance to ignore 100% of defense of a stack)
; add here


// Spectral Behemoths' Spectral Echo
; The attacker's physical attack now hits an additional enemy closed to the attacked target, if the target was killed by the attack
; The damage hittig the second target = damage exceeding the kill on the first target
!?FU(OnMonsterPhysicalDamage);
; Exit if not melee damage
!!FU(tum_GetMonsterPhysicalDamageType):P?(dmgType:y);
!!FU&(dmgType)<>0:E;

; Get the attacker/defender stack
!!MF:N?(defStack:y);

; If it is a retaliation
!!if&(defStack)=i^battle_acting_stack^;
  !!BG:E?(atkStack:y);
; If it is a normal attack, exit for secondary targets
!!el;
  !!BG:E?(targetStack:y);
  !!FU&(defStack)<>(targetStack):E;

  !!VR(atkStack):Si^battle_acting_stack^;
!!en;

!!FU|(atkStack)=(NO_STACK)/(defStack)=(NO_STACK):E;

; Check if the attacking monster has Spectral Echo
!!BM(atkStack):T?(type:y);
!!FU(tum_GetMonSpectralEchoRate):P(type)/?(rate:y);

!!if&(rate)>0;
  !!MF:F?(finalDmg:y);

  ; Check if the defending monster would be be killed
  !!BM(defStack):N?(num:y) H?(hp:y) L?(lostHp:y);
  !!VR(defCurrTotalHp:y):S(num) *(hp) -(lostHp);

  ; Calculate the Spectral Echo damage if it would be killed
  !!if&(finalDmg)>=(defCurrTotalHp);
    !!VR(echoDmg:y):S(finalDmg) -(defCurrTotalHp) *(rate) :4; [3/4]
    !!VRi^tum_spectralEchoDamage^&(echoDmg)>0:S(echoDmg);
  !!en;
!!en;

; Alternative approach
*?FU(OnStackToStackDamage_Quit);
*#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distancArg:x) (isTheoretical:x);

*!FU|(isTheoretical)/(isDistant):E;

; Check if the attacking monster has Spectral Echo
*!BM(atkStack):T?(type:y);
*!FU(tum_GetMonSpectralEchoRate):P(type)/?(rate:y);

*!if&(rate);
  ; Check if the defending monster would be be killed
  *!BM(defStack):N?(num:y) H?(hp:y) L?(lostHp:y);
  *!VR(defCurrTotalHp:y):S(num) *(hp) -(lostHp);

  ; Calculate the Spectral Echo damage if it would be killed
  *!if&(finalDmg)>=(defCurrTotalHp);
    *!VRi^tum_spectralEchoDamage^:S(finalDmg) -(defCurrTotalHp);
  *!en;
*!en;

!?FU(tum_OnAfterMelee)&i^tum_spectralEchoDamage^;
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkNum)>0/(defNum)<=0;
  ; Look for adjacent stacks to the killed stack
  !!FU(tum_GetAdjacentStacksOfStack):P(defStack)/?(adjacentStacksList:y)/1/(FALSE);
  !!SN:M(adjacentStacksList)/?(size:y);

  !!if&(size)>0;
    !!VR(random:y):R0/1/(size) -1;
    !!SN:M(adjacentStacksList)/(random)/?(targetStack:y);
    !!BM(targetStack):Ki^tum_spectralEchoDamage^;

    !!if&i^battle_isVisible^;
      !!FU(tum_PlayCustomAnimationOnStack):P(targetStack)/^Claws^;

      !!FU(tum_UpdateStackAnimation):P;

      !!BM(targetStack):N?(num:y) T?(type:y);
      !!VR(isPlural:y):S(num) -1 B;
      !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
      !!SN:T^tumr.str.spectralEcho^/?(battleLog:z)/^dmg^/i^tum_spectralEchoDamage^/^mon^/(monName);
      !!MM:S(battleLog);
    !!en;

    !!FU(tum_ExecutePhoenixResurrection):P;
  !!en;
!!en;

!!VRi^tum_spectralEchoDamage^:S0;

; Would be divided by 4
; The number is a bit weird to avoid overflowing as much as possible
!?FU(tum_GetMonSpectralEchoRate);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_SPECTRAL_BEHEMOTH):S3;


// Venomspike Wyverns' Venomweave Seizure
; 15% to stun the attacked target (excluding retaliation) if it has been poisoned
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

; Exit if it is a retaliation
!!FU&i^battle_acting_stack^<>(atkStack):E;

!!if&(atkNum)>0/(defNum)>0;
  !!BM(atkStack):T?(atkMon:y);
  ; Check if the attacker has Venomweave Seizure
  !!FU(tum_CheckMonVenomweaveSeizureChance):P(atkMon)/?(chance:y);

  !!if&(chance)>0;
    ; Check if the defender has been Poisoned
    !!BM(defStack):G71/?(poisonDuration:y)/?(level:y);

    !!if&(poisonDuration)>0;
      ; Check if the target is alive
      !!BM(defStack):F?(flags:y);
      !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);

      !!if&(isAlive);
        ; Check if the target has retaliations remained or has not acted
        !!BM(defStack):R?(retals:y);
        !!VR(hasActed:y):S(flags) &(MON_FLAG_ACTED);

        !!if|(retals)>0/(hasActed)=(FALSE);
          ; Check if it is lucky
          !!VR(random:y):R0/0/99;

          !!if&(random)<(chance);
            !!BM(defStack):R0 Fd|(MON_FLAG_ACTED);

            !!if&i^battle_isVisible^;
              !!BM(defStack):T?(defMon:y);
              !!VR(defIsPlural:y):S(defNum) -1 B;
              !!SN:H^monname^/(defMon)/(defIsPlural)/?(monName:z);
              !!SN:T^tumr.str.stun%(defIsPlural)^/?(battleLog:z)/^mon^/(monName);
              !!MM:S(battleLog);

              !!SN:P^SPELLSTUN^;
              !!FU(tum_PlayCustomAnimationOnStack):P(defStack)/^Stun^;
            !!en;
          !!en;
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonVenomweaveSeizureChance);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_VENOMSPIKE_WYVERN):S15;


// Venomspike Wyverns' Poison Nova
; Poison all the adjacent units for 3 turns when killed
!?FU(tum_OnBattleStackKilled);
!#VA(stackId:x) (side:x);

!!BM(stackId):T?(type:y);
!!FU(tum_CheckIfMonHasPoisonNova):P(type)/?(result:y);

!!if&(result);
  ; Get all the adjacent hostile stack
  !!FU(tum_GetAdjacentStacksOfStack):P(stackId)/?(adjacentStacksList:y)/-1/(FALSE);

  !!SN:M(adjacentStacksList)/?(size:y);

  !!if&(size)>0;
    ; Loop through all the stacks found and check their duration of poison
    !!FU(NewIntArray)&i^battle_isVisible^:P?(affectedStacksList:y);

    !!re i/0/(size)/1/-1;
      !!SN:M(adjacentStacksList)/i/?(targetStack:y);

      !!BM(targetStack):G71/?(duration:y)/?(level:y);

      ; If there is any stack found with fewer than 3 turns of poison, check if they are immune to poison
      !!if&(duration)<3;
        !!FU(tum_Battle_CanStackReceiveSpell):P(targetStack)/71/(side)/?(result);

        ; Push the found stack to array and poison it
        !!if&(result);
          !!FU(Array_Push)&i^battle_isVisible^:P(affectedStacksList)/(targetStack);
          !!BM(targetStack):M71/3/(SKILL_NOT_LEARNED);
        !!en;
      !!en;
    !!en;

    !!if&i^battle_isVisible^;
      ; If any stacks were poisoned with Poison Nova, play sound, animation and battle log
      !!SN:M(affectedStacksList)/?(size:y);

      !!if&(size)>0;
        !!SN:T^tumr.str.poisonNova^/?(battleLog:z);
        !!MM:S(battleLog);

        !!SN:P^poison^;
        !!FU(tum_PlayAnimationOnMultipleStacks):P(affectedStacksList)/67/(TRUE); [animation/array/Play damaged animation]
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckIfMonHasPoisonNova);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_VENOMSPIKE_WYVERN):S(TRUE);


// Nightmare Hydras' Nightmare
; 10% chance to stop a melee attacker from attacking
; The stooped stack will first walk closed to Hydra then got stop before landing the attack
; this creates a huge oppurtunity for Hydras to strike back with Stirke all Around
; Warning: It is possible to have defStack =-1 in FU(OnBeforeBattleAction)
!?FU(OnBeforeBattleAction);
!!BG:A?(action:y);

!!if&(action)=(BATTLE_ACTION_WALK_AND_ATTACK);
  !!BG:E?(defStack:y);

  !!if&(defStack)>(NO_STACK);
    !!BM(defStack):N?(num:y) T?(type:y);
    !!FU(tum_GetMonNightmareChance):P(type)/?(chance:y);

    !!if&(num)>0/(chance)>0;
      ; Check acted flag for ES achievements compatibility
      !!BMi^battle_acting_stack^:F?(flags:y);
      !!VR(isActed:y):S(flags) &(MON_FLAG_ACTED);

      !!if&(isActed)=0;
        !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);
        !!FU&(isAlive)=0:E;

        !!VR(random:y):R0/0/99;

        ; Make the victim walk to the creature with Darkness but stop before attack
        !!if&(random)<(chance);
          !!BG:D-1;                     [Warning: BG:E value would also be set to -1 here!]
          !!BMi^battle_acting_stack^:Fd|(MON_FLAG_ACTED); [Added acted flag for ES achievements compatibility]

          !!VRi^tum_lostInNightmare^&i^battle_isVisible^:S(TRUE);
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(OnBattleActionEnd)&i^tum_lostInNightmare^;
!!BMi^battle_acting_stack^:N?(num:y);

!!if&(num)>0;
  !!BMi^battle_acting_stack^:T?(type:y);
  !!VR(isPlural:y):S(num) -1 B;
  !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
  !!SN:T^tumr.str.nightmare%(isPlural)^/?(battleLog:z)/^mon^/(monName);
  !!MM:S(battleLog);

  !!SN:P^fear^;
  !!FU(tum_PlayCustomAnimationOnStack):Pi^battle_acting_stack^/^_fear^;
!!en;
  
!!VRi^tum_lostInNightmare^:S(FALSE);

!?FU(tum_GetMonNightmareChance);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_NIGHTMARE_HYDRA):S10;


// Elemental Marks
; Not yet done
!?FU(tum_OnAfterAttack);
!#VA(atkStack:x) (defStack:x);

!!FU:E;

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkNum)>0/(defNum)>0;
  !!BM(atkStack):T?(atkMon:y);
  !!FU(tum_CheckMonElementalTriggerType):P(atkMon)/?(triggerType:y);

  !!if&(triggerType);
    !!re i/(SPELL_AIR_MARK)/(SPELL_EARTH_MARK);
      !!BM(defStack):Gi/?(duration:y)/?(level:y);

      !!br&(duration)>0;
    !!en;

    ; If the defending stack has already been marked, trigger additional effects depending on the trigger type and the mark type if the mark is not the same with the trigger
    !!if&i<=80/i<>(triggerType);
      !!if&(triggerType)=(SPELL_AIR_MARK);
        ; Lightning
        !!if&i=(SPELL_WATER_MARK);

        ; Fire Wall
        !!el&i=(SPELL_FIRE_MARK);

        !!el&i=(SPELL_EARTH_MARK);
          !!FU(tum_RemoveSpellFromStack):P(defStack)/i;
        !!en;
      !!el&(triggerType)=(SPELL_WATER_MARK);
        ; Ice Bolt
        !!if&i=(SPELL_AIR_MARK);

        !!el&i=(SPELL_FIRE_MARK);
          !!FU(tum_RemoveSpellFromStack):P(defStack)/i;
        ; Quick Sand
        !!el&i=(SPELL_EARTH_MARK);
          
        !!en;
      !!el&(triggerType)=(SPELL_FIRE_MARK);
        ; Fire Ball
        !!if&i=(SPELL_AIR_MARK);

        !!el&i=(SPELL_WATER_MARK);
          !!FU(tum_RemoveSpellFromStack):P(defStack)/i;
        ; Land Mine (Must test if it works for defender)
        !!el&i=(SPELL_EARTH_MARK);
          
        !!en;
      !!el&(triggerType)=(SPELL_EARTH_MARK);
        !!if&i=(SPELL_AIR_MARK);
          !!FU(tum_RemoveSpellFromStack):P(defStack)/i;
        ; Bind
        !!el&i=(SPELL_WATER_MARK);
        
        ; Meteor Shower
        !!el&i=(SPELL_FIRE_MARK);
          
        !!en;
      !!en;

    ; If the defending stack has not yet been marked, or the mark is the same with the trigger, mark it (again). Also clear other marks
    !!el;
      !!FU(tum_SetElementalMark):P(defStack)/i;

      !!if&i^battle_isVisible^;

      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonElementalTriggerType);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_HURRICANE_ELEMENTAL):S(SPELL_AIR_MARK);
!!VR(result)&(mon)=(MON_SNOW_ELEMENTAL):S(SPELL_WATER_MARK);
!!VR(result)&(mon)=(MON_PLASMA_ELEMENTAL):S(SPELL_FIRE_MARK);
!!VR(result)&(mon)=(MON_MINERAL_ELEMENTAL):S(SPELL_EARTH_MARK);

!?FU(tum_SetElementalMark);
!#VA(stack:x) (spell:x);

!!re i/(SPELL_AIR_MARK)/(SPELL_EARTH_MARK);
  !!FU(tum_RemoveSpellFromStack):P(stack)/(spell);
!!en;

!!BM(stack):M(spell)/1000/(SKILL_NOT_LEARNED);


// Void Elementals' Mana Siphon
; Chance to absorb attacked stack's spells (works for all the targets of Strike all Around)
!?FU(tum_OnBeforeMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):T?(type:y);
!!FU(tum_CheckMonManaSiphonChance):P(type)/?(chance:y);

!!if&(chance)>0;
  !!FU(NewIntArray):P?i^tum_manaSiphonList^/(M_TEMP);
  !!FU(Array_Push):Pi^tum_manaSiphonList^/(atkStack);
!!en;

!?FU(OnStackToStackDamage)&i^tum_manaSiphonList^;
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU|(isDistant)/(isTheoretical):E;

!!SN:Mi^tum_manaSiphonList^/0/?(savedStack:y);
!!FU(Array_Push)&(atkStack)=(savedStack):Pi^tum_manaSiphonList^/(defStack);

!?FU(tum_OnAfterMelee)&i^tum_manaSiphonList^;
!#VA(atkStack:x) (defStack:x);

; Set up array to store affected stacks list
!!FU(NewIntArray)&i^battle_isVisible^:P?(affectedStacksList:y);

; Get the chance of Mana Siphon
!!BM(atkStack):T?(atkMon:y);
!!FU(tum_CheckMonManaSiphonChance):P(atkMon)/?(chance:y);

; Loop through all the attacked targets
!!SN:Mi^tum_manaSiphonList^/?(size:y);

!!re i/1/(size)/1/-1;
  !!SN:Mi^tum_manaSiphonList^/i/?(targetStack:y);
  ; Execute Mana Siphon only when target is alive
  !!BM(targetStack):N?(num:y);

  !!if&(num)>0;
    !!BM(targetStack):E?(spells:y);

    !!if&(spells)>0;
      !!VR(random:y):R0/0/99;

      !!if&(random)<(chance);
        !!BM(targetStack):Ed-1;
        !!BM(atkStack):Ed1;

        !!FU(Array_Push)&i^battle_isVisible^:P(affectedStacksList)/(targetStack);
      !!en;
    !!en;
  !!en;
!!en;

!!SN:Mi^tum_manaSiphonList^;
!!VRi^tum_manaSiphonList^:S0;

!!if&i^battle_isVisible^;
  !!SN:M(affectedStacksList)/?(size:y);

  !!if&(size)>0;
    ; Text
    !!BM(atkStack):N?(atkNum:y);
    !!VR(atkIsPlural:y):S(atkNum) -1 B;
    !!SN:H^monname^/(atkMon)/(atkIsPlural)/?(atkMonName:z);
    !!SN:T^tumr.str.manaSiphon%(atkIsPlural)^/?(battleLog:z)/^mon^/(atkMonName);
    !!MM:S(battleLog);

    ; Sound
    !!SN:P^ManaDrai^;
    ; Set up animation
    !!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(cmbMgr:y);
    !!UN:C(cmbMgr)/78572/(UNC_INT)/-1;
    ; Play the animation
    !!SN:B6835288/d/^frost bite.def^;
    !!FU(tum_PlayAnimationOnMultipleStacks):P(affectedStacksList)/82;
    !!SN:B6835288/d/^Poof.def^;
    ; Reset changes
    !!UN:C(cmbMgr)/78572/(UNC_INT)/-1;
  !!en;
!!en;

!?FU(tum_CheckMonManaSiphonChance);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_VOID_ELEMENTAL):S12;


// Void Elementals' Mana Transfer
; Transfer half of the spells to an ally by casting on them. The rest of the spells would be discarded
!?FU(OnBattleMouseHint)&i^tum_customSpellActive^;
; Check monster position, exit if not on the same side (after Hypnotized) or is self
!!BU:Ei^mouse_battleHex^/?(targetStack:y);
!!FU&(targetStack)=(NO_STACK):E;
!!FU&(targetStack)=i^battle_current_stack^:E;

!!BM(targetStack):I?(targetSide:y);
!!VR(currSide:y):Si^battle_current_side^;
!!FU&(targetSide)<>(currSide):E;

; Get type and check if the stack has Mana Transfer
!!BMi^battle_current_stack^:T?(currType:y);
!!FU(tum_CheckMonHasManaTransferRate):P(currType)/?(rate:y);
!!FU&(rate)=0:E;

!!BMi^battle_current_stack^:N?(currNum:y);
!!BM(targetStack):E?(targetSpells:y) T?(targetType:y);

!!BM(targetStack):N?(targetNum:y);
!!VR(currIsPlural:y):S(currNum) -1 B;
!!SN:H^monname^/(currType)/(currIsPlural)/?(currMonName:z);
!!VR(targetIsPlural:y):S(targetNum) -1 B;
!!SN:H^monname^/(targetType)/(targetIsPlural)/?(targetMonName:z);

; Show not enough spell hint if needed
!!BMi^battle_current_stack^:E?(spells:y);
!!VR(spellsToTransfer:y):S(spells) :(rate);

!!if&(spellsToTransfer)<=0;
  !!VR(isPlural:y):S(currNum) -1 B;
  !!SN:H^monname^/(currType)/(isPlural)/?(monName:z);
  !!SN:T^tumr.str.manaTransferNotEnough%(isPlural)^/?(hint:z)/^mon^/(monName);
  !!MM:M^%(hint)^;
  !!FU:E;
!!en;

; Exit if not possible to cast
!!FU(tum_CheckIfPossibleToCast):P3/?(result:y)/?(hint:z);

!!if&(result)<>(TRUE);
  !!MM&(hint)<>^^:M(hint);
  !!FU:E;
!!en;

; Exit if the target can transfer spells
!!FU(tum_CheckMonHasManaTransferRate):P(targetType)/?(targetRate:y);
!!FU&(targetRate)>0:E;

; Exit if the target cannot cast
!!if&(targetSpells)<=0;
  !!MA:B(targetType)/?(targetSpells);

  !!if&(targetSpells)<=0;
    *!SN:T^tumr.str.manaTransferNotValid^/?(hint)/^currMon^/(currMonName)/^targetMon^/(targetMonName);
    *!MM:M^%(hint)^;
    !!FU:E;
  !!en;
!!en;

; Exit if the target can't receive level 3 spell
!!FU(tum_CheckIfStackCanReceiveCustomSpell):P(targetStack)/(currSide)/(SPELL_TELEPORT)/3/0/?(result);
!!FU&(result)<>(TRUE):E;

; Change the cursor and show hint
!!UN:R5/3/0;

!!SN:T^tumr.str.manaTransferMain^/?(hint)/^spell^/(spellsToTransfer)/^mon^/(targetMonName);
!!MM:M(hint);

!?FU(OnBattleScreenMouseClick)&i^mouse_action^=(MOUSE_LMB_PRESSED)/i^tum_customSpellActive^;
; Check monster position, exit if not on the same side (after Hypnotized) or is self
!!BU:Ei^mouse_battleHex^/?(targetStack:y);
!!FU&(targetStack)=(NO_STACK):E;
!!FU&(targetStack)=i^battle_current_stack^:E;

!!BM(targetStack):I?(targetSide:y);
!!VR(currSide:y):Si^battle_current_side^;
!!FU&(targetSide)<>(currSide):E;

; Get type and check if the stack has Mana Transfer
!!BMi^battle_current_stack^:T?(currType:y);
!!FU(tum_CheckMonHasManaTransferRate):P(currType)/?(rate:y);
!!FU&(rate)=0:E;

!!BMi^battle_current_stack^:N?(currNum:y);
!!BM(targetStack):E?(targetSpells:y) T?(targetType:y);

; Exit if not enough spell
!!BMi^battle_current_stack^:E?(spells:y);
!!VR(spellsToTransfer:y):S(spells) :(rate);
!!FU&(spellsToTransfer)<=0:E;

; Exit if not possible to cast
!!FU(tum_CheckIfPossibleToCast):P3/?(result:y);
!!FU&(result)<>(TRUE):E;

; Exit if the target can transfer spells
!!FU(tum_CheckMonHasManaTransferRate):P(targetType)/?(targetRate:y);
!!FU&(targetRate)>0:E;

; Exit if the target cannot cast
!!if&(targetSpells)<=0;
  !!MA:B(targetType)/?(targetSpells);
  !!FU&(targetSpells)<=0:E;
!!en;

; Exit if the target can't receive level 3 spell
!!FU(tum_CheckIfStackCanReceiveCustomSpell):P(targetStack)/(currSide)/(SPELL_TELEPORT)/3/0/?(result);
!!FU&(result)<>(TRUE):E;

!!FU(tum_ExecuteManaTransfer):P(targetStack)/(currNum)/(currType)/(targetType)/(spellsToTransfer)/(targetStack);

!!VR(oppSide:y):S(currSide) X(TRUE);
!!IP:Di^battle_owner_%(oppSide)^;
!!FU(tum_ExecuteManaTransfer):D(targetStack)/(currNum)/(currType)/(targetType)/(spellsToTransfer)/(targetStack);

!?FU(tum_ExecuteManaTransfer);
!#VA(targetStack:x) (currNum:x) (currType:x) (targetType:x) (spellsToTransfer:x) (targetStack:x);

; Play the casting animation manually
!!BMi^battle_current_stack^:P?(currPos:y);

; Get real coordinates of hexes
!!FU(tum_GetCoordsOfHex):P(currPos)/?(currX:y)/?(currY:y) Pi^mouse_battleHex^/?(targetX:y)/?(targetY:y);

; Check if it is required to turn around
!!VR(mustTurnAround:y):S(FALSE);
!!BMi^battle_current_stack^:I?(realSide:y);

!!if&(currX)<(targetX);
  !!VR(mustTurnAround)&(realSide)=(BATTLE_RIGHT):S(TRUE);
!!el&(currX)>(targetX);
  !!VR(mustTurnAround)&(realSide)=(BATTLE_LEFT):S(TRUE);
!!en;

; Get the group of frame for animation
!!if&(currY)<(targetY);
  !!VR(group:y):S14;
!!el&(currY)=(targetY);
  !!VR(group):S15;
!!el;
  !!VR(group):S16;
!!en;

; Get data
!!BMi^battle_current_stack^:Z?(stackStruct:y);

; Turn around
!!SN&(mustTurnAround):E4482112/(CALLCONV_THISCALL)/(stackStruct)/1;

; Sound
!!SN:P^MagChDrn^;
; Play animation
!!FU(tum_BattleStack_PlayAnimation):P(stackStruct)/(group)/(FALSE);
; Animation
!!BMi^battle_current_stack^:V76;

; Restore the cursor to default - for the current acting player only
!!OW:C?(currPlayer:y)/?(interactPlayer:y);

!!re i/0/1;
  !!if&i^battle_owner_%i^=(interactPlayer);
    !!CM:R0;
    !!UN:R5/0/0;

    !!br;
  !!en;
!!en;

; Battle log
!!BM(targetStack):N?(targetNum:y);
!!VR(currIsPlural:y):S(currNum) -1 B;
!!SN:H^monname^/(currType)/(currIsPlural)/?(currMonName:z);
!!VR(targetIsPlural:y):S(targetNum) -1 B;
!!SN:H^monname^/(targetType)/(targetIsPlural)/?(targetMonName:z);
!!SN:T^tumr.str.manaTransferCast%(currIsPlural)^/?(battleLog:z)/^currMon^/(currMonName)/^spell^/(spellsToTransfer)/^targetMon^/(targetMonName);
!!MM:S(battleLog);

; Sound on the target
!!SN:P^MagChFil^;
; Animation on the target
!!FU(tum_PlayCustomAnimationOnStack):P(targetStack)/^HourOPow^;

; Transfer spells
!!BM(targetStack):Ed(spellsToTransfer);

; Turn back
!!SN&(mustTurnAround):E4482112/(CALLCONV_THISCALL)/(stackStruct)/1;
!!SN:D;

; Reset spell of the current stack
!!BMi^battle_current_stack^:E0;
!!FU(tum_FixXEMonsterSpellCountCompatibility):P; [ACM Compatiblity]

; Pass the turn
!!BG:A(BATTLE_ACTION_SKIP);

!?FU(tum_CheckMonHasManaTransferRate);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_VOID_ELEMENTAL):S2;


// Divine Phoenixes and Red Skeletons' Rebirth
// Recreated these abilities to get rid of the crap of Amethyst
!?FU(tum_OnPhoenixResurrectionProc);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(stackStruct:y) C(stackStruct)/52/4/?(type:y);
!!FU(tum_GetMonRebirthType):P(type)/?(rebirthType:y);

!!if&(rebirthType)>=2;
  !!SN:X?t/0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/7725366;
!!en;


// Divine Phoenixes' Flame Renewal
; Creates an explosion before Phoenix resurrection
; Has no effect on Elementals (including water elemental) - This is because AI strategy is difficult to script, nothing is implemented
; Heals and revives Fire-type Elementals (including summoned ones)
// Must not use OnBattleStackKilled as it would result in infinite explosion
!?FU(tum_OnPhoenixResurrection);
!#VA(stackId:x) (side:x);

!!BM(stackId):T?(type:y);
!!FU(tum_CheckMonFlameRenewalDamage):P(type)/?(flameDamage:y);

!!if&(flameDamage)>0;
  ; Get all the adjacent hostile stack
  !!FU(NewIntArray):P?(stacksToDamageList:y) P?(stacksToRegenList:y);
  !!FU(tum_GetAdjacentStacksOfStack):P(stackId)/?(adjacentStacksList:y)/0/(FALSE);

  !!SN:M(adjacentStacksList)/?(size:y);

  !!if&(size)>0;
    ; Here we use Summon Boat as a dummy spell (level 5, Fire school)
    !!SS(SPELL_INFERNO):F?(infernoFlags:y);
    !!SS(SPELL_SUMMON_BOAT):L?(origLevel:y) L5 S?(origSchool:y) S2 F?(origFlags:y) F(infernoFlags);

    ; Loop through all the stacks found and see if they can acceopt a fire school spell
    !!re i/0/(size)/1/-1;
      !!SN:M(adjacentStacksList)/i/?(targetStack:y);
      !!BM(targetStack):F?(flags:y);
      !!VR(isFireImmune:y):S(flags) &(MON_FLAG_FIRE_IMMUNITY);
      !!FU(tum_GetStackOrMonLivingType):P(targetStack)/(FALSE)/?(livingType:y); [Check if the stack is elemental]

      ; If the stack is a normal creauture (not elemental)
      !!if&(isFireImmune)=(FALSE)/(livingType)<>3;
        !!FU(tum_Battle_CanStackReceiveSpell):P(targetStack)/(SPELL_SUMMON_BOAT)/(side)/?(result:y);

        !!FU(Array_Push)&(result):P(stacksToDamageList)/(targetStack);

      ; If the stack is Fire Elemental
      !!el&(isFireImmune)/(livingType)=3;
        !!FU(Array_Push):P(stacksToRegenList)/(targetStack);
      !!en;
    !!en;

    !!SS(SPELL_SUMMON_BOAT):L(origLevel) S(origSchool) F(origFlags);
  !!en;

  !!SN:M(stacksToDamageList)/?(damageSize:y) M(stacksToRegenList)/?(regenSize:y);

  !!if|(size)>0/(regenSize)>0;
    ; Get the amount of damage and regeneration
    !!BM(stackId):B?(initNum:y);
    !!VR(totalFlameDamage:y):S(flameDamage) *(initNum);
    !!VR(regenHp:y)&(regenSize):S(totalFlameDamage) :2;

    ; Inflict damage
    !!if&(damageSize)>0;
      !!re i/0/(damageSize)/1/-1;
        !!SN:M(stacksToDamageList)/i/?(targetStack:y);
        !!BM(targetStack):K(totalFlameDamage);
      !!en;
    !!en;

    ; Regen
    !!VR(hasRegen:y):S(FALSE);          [variable to check if actually regenerated any for log]

    !!if&(regenSize)>0;
      !!re i/0/(regenSize)/1/-1;
        !!SN:M(stacksToRegenList)/i/?(targetStack);
        !!FU(tum_HealAndReviveStack):P(targetStack)/(regenHp)/?(reviveNum:y)/?(actualRegenHp:y);

        !!VR(hasRegen)&(actualRegenHp)>0:S(TRUE);
      !!en;
    !!en;

    ; Check the type of flame, whether it damaged or healed
    !!if&i^battle_isVisible^;
      !!if|(damageSize)>0/(hasRegen);
        !!VR(flameType:y):S0;

        !!if&(hasRegen);
          !!VR(flameType)&(damageSize)<=0:S1;
          !!VR(flameType)&(damageSize)>0:S2;
        !!en;
        
        !!SN:T^tumr.str.flameRenewal%(flameType)^/?(battleLog:z)/^dmg^/(totalFlameDamage)/^hp^/(regenHp);
        !!MM:S(battleLog);

        !!SN:P^explosion^;
        !!FU(tum_PlayCustomAnimationOnStack):P(stackId)/^SP_summon^/1;

        ; Play damaged animation on stacks if any has been damaged
        !!if&(damageSize)>0;
          !!FU(tum_UpdateStackAnimation):P;
        !!en;
      !!en;
    !!en;

    ; Don't call Phoenix resurrection - it resutls in a loop
    *!FU(tum_ExecutePhoenixResurrection):P;
  !!en;
!!en;

!?FU(tum_CheckMonFlameRenewalDamage);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_DIVINE_PHOENIX):S25;


// Light Paladins' Celestial Purge
; Casts Destroy Undead after attacking Undead
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);
!!FU|(atkNum)<=0/(defNum)<=0:E;

!!BM(atkStack):T?(type:y);
!!FU(tum_GetMonCeletialPurgeChance):P(type)/?(chance:y);
!!FU&(chance)=0:E;

!!BM(defStack):F?(flags:y);
!!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);
!!FU&(isUndead)=0:E;

!!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/(chance)/(SPELL_DESTROY_UNDEAD)/10;

!?FU(tum_GetMonCeletialPurgeChance);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_LIGHT_TEMPLAR):S20;
!!VR(result)&(mon)=(MON_LIGHT_PALADIN):S50;


// Oak Dryads' Nature's Purification
!?FU(OnBattleActionEnd)&i^battle_acting_stack^>(NO_STACK)/i^tum_%(ART_SPHERE_OF_PERMANENCE)_equipped^<>(TRUE);
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_MONSTER_CAST):E;

!!BMi^battle_acting_stack^:T?(actType:y);
!!FU(tum_CheckIfMonHasNaturesPurification):P(actType)/?(result:y);

!!BG:D?(pos:y);
!!FU(tum_GetAdjacentStacksOfPosition):P(pos)/?(adjacentStacksList:y)/1/(FALSE); [x3 = friendly units only, x4 = allow dead units]

; Get the units applicable to be revived from the adjacent list
!!SN:M(adjacentStacksList)/?(size:y);
!!FU&(size)=0:E;

!!FU(NewIntArray)&i^battle_isVisible^:P?(dispelList:y);

!!re i/0/(size)/1/-1;
  !!SN:M(adjacentStacksList)/i/?(targetStack:y);

  ; Dispel harmful spells from the target
  !!re j/(SPELL_FIRST_BATTLE)/(SPELL_LAST_WOG);
    !!SSj:O?(spellType:y);
    !!co&(spellType)>=0;

    !!BM(targetStack):Gj/?(duration:y)/?(power:y);

    !!if&(duration)>0;
      !!FU(tum_RemoveSpellFromStack):P(targetStack)/j;
      !!FU(Array_Push)&i^battle_isVisible^:P(dispelList)/(targetStack);
    !!en;
  !!en;
!!en;

; If there is at least one unit to be dispelled
!!FU&i^battle_isVisible^<>(TRUE):E;

!!SN:M(dispelList)/?(size);

!!if&(size)>0;
  ; Battle log
  !!BMi^battle_acting_stack^:N?(actNum:y);
  !!VR(isPlural:y):S(actNum) -1 B;
  !!SN:H^monname^/(actType)/(isPlural)/?(monName:z);
  !!SN:T^tumr.str.naturalsPurification%(isPlural)^/?(battleLog:z)/^mon^/(monName);
  !!MM:S(battleLog);

  ; Sound
  !!SN:P^dispell^;

  ; Animation
  !!FU(tum_PlayAnimationOnMultipleStacks):P(dispelList)/41/(FALSE);
!!en;

!?FU(tum_CheckIfMonHasNaturesPurification);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(MON_OAK_DRYAD):S(TRUE);


// Illithids and Fangarms' Hypnotize Attack
; The max target health to be Hypothzed is the same as Fangarm's ability from HotA (20 + 25*(Illithird count))
; If the requirements of casting Hypnotize are met, it will be cast with 100% chance.
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(defStack):N?(defNum:y);

!!if&(defNum)>0;
  !!BM(atkStack):T?(atkMon:y);
  ; Check if the attacker can cast Hynotize
  !!FU(tum_CheckIfMonCanHypnotize):P(atkMon)/?(canHypnotize:y);

  !!if&(canHypnotize);
    ; Check if the target monster is hypnotized
    !!BM(defStack):G(SPELL_HYPNOTIZE)/?(duration:y)/?(level:y);

    !!if&(duration)<=0;
      !!FU(tum_GetActualStackSide):P(atkStack)/?(atkSide:y);
      ; Check the defender's immunity to Hypnotize
      !!FU(tum_CheckIfStackCanBeHypnotized):P(defStack)/(atkSide)/?(acceptSpell:y);

      !!if&(acceptSpell);
        ; Check if the total HP of the defender is lower than 20 + 25*(attacker count)
        ; Attacker's power
        !!BM(atkStack):N?(atkNum:y);
        !!VR(maxHypnotizeHp:y):S25 *(atkNum) +20;
        ; Defender's total Hp
        !!BM(defStack):H?(hp:y) L?(lostHp:y);
        !!VR(totlaHp:y):S(hp) *(defNum) -(lostHp);

        ; Cast if condition meet
        !!if&(maxHypnotizeHp)>=(totlaHp);
          !!BM(defStack):P?(pos:y);
          !!BM(atkStack):C(SPELL_HYPNOTIZE)/(pos)/(SKILL_EXPERT)/3/(TRUE);

          ; Remove Attack Twice and retailiations temporarily for the victim and restore later
          !!BM(defStack):F?(flags:y) Fd~(MON_FLAG_ATTACKS_TWICE) R?(retals:y) R0;
          !!VR(hasAttackTwice:y):S(flags) &(MON_FLAG_ATTACKS_TWICE) B;
          !!FU(PackUnion):P(defStack)/8/(retals)/16/(hasAttackTwice)/7/1/1/?i^tum_hypnotize_stackData^;
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(OnBattleActionEnd)&i^tum_hypnotize_stackData^;
!!FU(UnpackUnion):Pi^tum_hypnotize_stackData^/?(defStack:y)/8/?(retals:y)/8/?(hasAttackTwice:y)/7/?(value:y)/1;
!!BM(defStack):R(retals);
!!BM(defStack)&(hasAttackTwice):Fd|(MON_FLAG_ATTACKS_TWICE);
!!VRi^tum_hypnotize_stackData^:S0;

!?FU(tum_CheckIfMonCanHypnotize);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)|(mon)=(MON_ILLITHID)/(mon)=(MON_ALHOON):S(TRUE);
!!VR(result)&(mon)=(MON_FANGARM):S(TRUE);

!?FU(tum_CheckIfStackCanBeHypnotized);
!#VA(stackId:x) (castingSide:x) (result:x);

!!VR(spellId:y):S(SPELL_HYPNOTIZE);

; Get the offset of the power address
!!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(combatManager:y);
!!VR(offset:y):S(castingSide) *(UNC_INT) +21460;

; Set the power to max
!!UN:C(combatManager)/(offset)/(UNC_INT)/?(power:y);
!!VR(newPower:y):S2000000;
!!UN:C(combatManager)/(offset)/(UNC_INT)/(newPower);

; Check if the stack can receive Hypnotize with the new power
!!FU(tum_Battle_CanStackReceiveSpell):P(stackId)/(spellId)/(castingSide)/?(result);

; Restore the power
!!UN:C(combatManager)/(offset)/(UNC_INT)/(power);


// Alhoons' Veil of Chaos
; Casts Berserk when attacked
; Note that both OnBeforeBattleAction and OnAfterMelee does not work here as Berserk would be cleared after attack is finished
!?FU(OnBattleActionEnd)&i^battle_acting_stack^>(NO_STACK);
!!BG:A?(action:y);

!!if&(action)=(BATTLE_ACTION_WALK_AND_ATTACK);
  !!BG:E?(defStack:y);

  !!if&(defStack)>(NO_STACK);
    !!BM(defStack):T?(defType:y);
    !!FU(tum_GetMonVeilOfChaosChance):P(defType)/?(chance:y);
    !!FU&(chance)=0:E;

    ; If the creature has been hypnotized, skip (as it can be used more effectively without Berserk)
    !!BMi^battle_acting_stack^:G(SPELL_HYPNOTIZE)/?(duration:y)/?(power:y);
    !!FU&(duration)>0:E;

    ; Casts
    !!FU(tum_CastSpellAfterAttack)&(chance)>0:P(defStack)/i^battle_acting_stack^/(chance)/(SPELL_BERSERK)/(SKILL_NOT_LEARNED)/?(result:y);

    ; Display msg
    !!if&i^battle_isVisible^/(result);
      !!BMi^battle_acting_stack^:N?(atkNum:y) T?(atkType:y);
      !!VR(isPlural:y):S(atkNum) -1 B;
      !!SN:H^monname^/(atkType)/(isPlural)/?(monName:z);
      !!SN:T^tumr.str.veilOfChaos%(isPlural)^/?(msg:z)/^mon^/(monName);
      !!MM:S(msg);
    !!en;
  !!en;
!!en;

!?FU(tum_GetMonVeilOfChaosChance);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_ALHOON):S15;


// Couatls and Quetzalcouatls' Hardened Skin
!?FU(OnBattleStackObtainsTurn)&i^tum_abilityCounter_%i(battle_current_stack)^=0/i^tum_tacticsIsEnded^;
!!BMi^battle_current_stack^:T?(type:y);
!!FU(tum_GetHardenedSkinType):P(type)/?(hardenedSkinTypeType:y);

!!if&(hardenedSkinTypeType);
  !!VRi^tum_abilityCounter_%i(battle_current_stack)^:+1;

  ; Type 1 - increase the defense
  !!BMi^battle_current_stack^:Dd1;

  !!if&i^battle_isVisible^;
    !!BMi^battle_current_stack^:N?(num:y);
    !!VR(isPlural:y):S(num) -1 B;
    !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
    !!SN:T^tumr.str.hardenedSkin%(isPlural)^/?(battleLog:z)/^mon^/(monName);
    !!MM:S(battleLog);

    !!SN:P^puppet master^;
    !!FU(tum_PlayCustomAnimationOnStack):Pi^battle_current_stack^/^_bow^/0;
  !!en;
!!en;

!?FU(tum_GetHardenedSkinType);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)|(mon)=(MON_COUATL)/(mon)=(MON_QUETZALCOUATL):S1;


// Carpet Whisperers' carpet animation
!?FU(OnStackToStackDamage)&i^battle_isVisible^;
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU|(isTheoretical)/(isDistant)<>(TRUE):E;

; Check if the attacker is Succubus
!!BM(atkStack):T?(type:y);

!!if&(type)=(MON_CARPET_WHISPERER);
  !!SN:P^carpSpell^;
  !!FU(tum_PlayCustomAnimationOnStack):P(defStack)/^carpet^;
!!en;


// Carpet Whisperers' Dispels benefical spells
; Dispels benefical spells after shoot
!?FU(tum_OnAfterShoot)&i^tum_%(ART_SPHERE_OF_PERMANENCE)_equipped^<>(TRUE);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):T?(type:y);
!!FU(tum_CheckIfMonHasMysticUnravel):P(type)/?(result:y);
!!FU&(result)<>(TRUE):E;

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);
!!FU|(atkNum)<=0/(defNum)<=0:E;

; Exit if immune to dispel
!!BM(atkStack):I?(atkSide:y);
!!FU(tum_Battle_CanStackReceiveSpell):P(defStack)/78/(atkSide)/?(canReceive:y); [Dispel friendly spell != Dispel!]
!!FU&(canReceive)<>(TRUE):E;

; Count number of spells to dispel
!!VR(spellNum:y):S0;

!!re i/(SPELL_FIRST)/(SPELL_LAST_WOG);
  !!SSi:O?(spellType:y);
  !!co&(spellType)<>1;

  !!BM(defStack):Gi/?(duration:y)/?(power:y);

  !!if&(duration)>0;
    !!VR(spellNum):+1;
    !!FU(tum_RemoveSpellFromStack):P(defStack)/i;
  !!en;
!!en;

!!FU&(spellNum)=0:E;

; Reduce defense based on the number of spells removed
!!VR(defReduced:y):S0;
!!BM(defStack):D?(defense:y);

!!if&(defense)>0;
  !!VR(newDefense:y):S(defense) -(spellNum) F0/(INT_MAX);
  !!VR(defReduced):S(defense) -(newDefense);
!!en;

!!if&i^battle_isVisible^;
  ; Text
  ; First part, dispell
  !!VR(isPlural:y):S(defNum) -1 B;
  !!BM(defStack):T?(defMon:y);
  !!SN:H^monname^/(defMon)/(isPlural)/?(monName:z);
  !!SN:T^tumr.str.mysticUnravel%(isPlural)^/?(msg:z)/^mon^/(monName);
  ; Second part, reduce defense
  !!if&(defReduced)>0;
    !!SN:T^tumr.str.mysticUnravelEnd^/?(msgEnd:z)/^def^/(defReduced);
    !!VR(msg):+(msgEnd);
  !!en;

  !!MM:S(msg);

  ; Sound and animation
  !!SN:P^dispell^;
  !!BM(defStack):V41;
!!en;

!?FU(tum_CheckIfMonHasMysticUnravel);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_CARPET_WHISPERER):S(TRUE);


// Lost Souls' Lost Souls Return
; Collect Lost Souls at the end of neutral battle (combat with neutral stacks)
!?FU(OnAfterBattleAction)&i^tum_isNeutralBattle^;
!!BU:C?(battleIsEnded:y);
!!FU&(battleIsEnded)<>(TRUE):E;

!!VRi^tum_lostSoulsCollected^:S0;
!!FU(tum_AccumLostSoulsAfterBattle)&i^tum_winnerSide^>-1/i^battle_hero_%i(tum_winnerSide)^>(NO_HERO):Pi^tum_winnerSide^;

!?FU(tum_AccumLostSoulsAfterBattle);
!#VA(side:x);

!!VR(oppSide:y):S(side) X(TRUE);

; Loop through all the all stacks and calculate the amount of Fangarms that is not in the army (BM:O=-1)
!!if&(oppSide)=(BATTLE_LEFT);
  !!VR(firstStack:y):S(BATTLE_ATTACKER_STACK_FIRST);
!!el;
  !!VR(firstStack):S(BATTLE_DEFENDER_STACK_FIRST);
!!en;

!!VR(lastStack:y):S(firstStack) +20;

; Loop through all the stacks and see if there is any Lost Souls
!!re i/(firstStack)/(lastStack);
  !!BMi:B?(initNum:y) T?(type:y);
  
  !!if&(initNum)>0/(type)=(MON_LOST_SOUL);
    !!VRi^tum_lostSoulsCollected^:+(initNum);
  !!en;
!!en;

; Divide by 5 (20%)
!!VRi^tum_lostSoulsCollected^::5;

!?FU(OnAfterBattleUniversal)&i^tum_lostSoulsCollected^>0/i^tum_isNeutralBattle^;
!!if&i^battle_ai_%i(tum_winnerSide)^<>(TRUE);
  !!HEi^battle_hero_%i(tum_winnerSide)^:C(MON_LOST_SOUL)/i^tum_lostSoulsCollected^/-1/0/-1/0/-1/0/-1/0/-1/0/-1/0;  [give creatures, in this way the dialog is always shown]
  !!SN:D;
!!el;
  !!HEi^battle_hero_%i(tum_winnerSide)^:C2/(MON_LOST_SOUL)/i^tum_lostSoulsCollected^/0;            [offer AI creatures]
!!en;

!!VRi^tum_lostSoulsCollected^:S0;


// Tiamats' Elemental Blast
; Cast different damaging spells for each attacked target after attacking (no effect on retaliation)
; Four spells: Lightning Bolt, Frost Ring, Fire Ball and Implosion, each attacked target would receive a different spell until the cycle is ended
!?FU(tum_OnBeforeMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):T?(type:y);
!!FU(tum_CheckIfMonHasElementalBlast):P(type)/?(hasElemBlast:y);

!!if&(hasElemBlast);
  !!FU(NewIntArray):P?i^tum_elementalBlastList^/(M_TEMP);
  !!FU(Array_Push):Pi^tum_elementalBlastList^/(atkStack);
!!en;

!?FU(OnStackToStackDamage)&i^tum_elementalBlastList^;
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU|(isDistant)/(isTheoretical):E;

!!SN:Mi^tum_elementalBlastList^/0/?(savedStack:y);
!!FU(Array_Push)&(atkStack)=(savedStack):Pi^tum_elementalBlastList^/(defStack);

!?FU(tum_OnAfterMelee)&i^tum_elementalBlastList^;
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):I?(atkSide:y);
!!SN:Mi^tum_elementalBlastList^/?(size:y);

!!re i/1/(size)/1/-1;
  !!SN:Mi^tum_elementalBlastList^/i/?(targetStack:y);
  ; Execute Elemental Blast only when the target is alive
  !!BM(targetStack):N?(num:y);

  !!if&(num)>0;
    !!VR(counter:y):Si^tum_abilityCounter2_%(atkStack)^ %4;

    ; Air
    !!if&(counter)=0;
      !!FU(tum_CastSpellAfterAttack):P(atkStack)/(targetStack)/100/(SPELL_LIGHTNING_BOLT)/15/?(result:y);
    ; Water
    !!el&(counter)=1;
      !!FU(tum_GetFrostRingPos):P(atkStack)/(defStack)/?(pos:y);
      !!FU(tum_CastMonsterDamagingSpell)&(pos)>-1:P(atkStack)/(SPELL_FROST_RING)/(pos)/10;
    ; Fire
    !!el&(counter)=2;
      !!FU(tum_CastSpellAfterAttack):P(atkStack)/(targetStack)/100/(SPELL_FIREBALL)/15/?(result);
    ; Earth
    !!el&(counter)=3;
      !!FU(tum_CastSpellAfterAttack):P(atkStack)/(targetStack)/100/(SPELL_IMPLOSION)/30/?(result);
    !!en;

    !!VRi^tum_abilityCounter2_%(atkStack)^:+1;
  !!en;
!!en;

!!SN:Mi^tum_elementalBlastList^;
!!VRi^tum_elementalBlastList^:S0;

; Function to get the nearest position to the target on the caster for casting Frost Ring - this is only needed when the caster is 2-hex
!?FU(tum_GetFrostRingPos);
!#VA(castStack:x);
!#VA(targetStack:x);
!#VA(result:x);

!#VA(castPos[2]:y);

!!BM(castStack):F?(flags:y) P?(castPos[0]);
!!VR(isWide:y):S(flags) &(MON_FLAG_WIDE);

; Exit if the caster is 1-hex
!!if&(isWide)=(FALSE);
  !!VR(result):S(castPos[0]);
  !!FU:E;
!!en;

!!BM(targetStack):P?(targetPos:y);
!!BM(castStack):I?(side:y);

; Get the second pos (the head) to cast
!!if&(side)=(BATTLE_LEFT);
  !!VR(castPos[1]):S(castPos[0]) +1;
!!el;
  !!VR(castPos[1]):S(castPos[0]) -1;
!!en;

; Check which pos is closer to the target
!#VA(castPosX[2]:y);
!#VA(distance[2]:y);

!!VR(targetPosX:y):S(targetPos) %(BATTLE_HEXES_PER_ROW);
!!VR(castPosX[0]):S(castPos[0]) %(BATTLE_HEXES_PER_ROW);
!!VR(castPosX[1]):S(castPos[1]) %(BATTLE_HEXES_PER_ROW);

!!re i/0/1;
  !!VR(distance[i]):S(targetPosX) -(castPosX[i]);
  !!VR(distance[i])&(distance[i])<0:*-1;
!!en;

; Prefer the head hex to cast, if distances are the same
!!if&(distance[0])<(distance[1]);
  !!VR(result):S(castPos[0]);
!!el;
  !!VR(result):S(castPos[1]);
!!en;

!?FU(tum_CheckIfMonHasElementalBlast);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_TIAMAT):S(TRUE);


// Miracle Mages' Spell Absorption
; Transfer a beneficial spell from the attacked target and enhance the creature with the spell
; Works on Vendetta (new creature spell) but would not trasnfer the attack/max damage stacked on the target.
; However, the target got Vendetta removed would lose all the stacks
!?FU(tum_OnBeforeMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkNum)>0/(defNum)>0;
  !!BM(atkStack):T?(atkMon:y);
  ; Check if the attacker can absorb spell
  !!FU(tum_CheckIfMonHasSpellAbsorption):P(atkMon)/?(result:y);

  !!if&(result);
    ; Check if the defender has a buff to be absorbed
    !!FU(NewIntArray):P?(availSpellsList:y);

    !!re i/(SPELL_VENDETTA)/(SPELL_LAST_BATTLE);
      !!co&i<(SPELL_FIRST_BATTLE)/i<>(SPELL_VENDETTA); [Skip adventure spell if not Vendetta]

      !!SSi:O?(spellType:y);

      !!if&(spellType)=1;
        !!BM(defStack):Gi/?(defDuration:y)/?(defLevel:y);

        ; Must be a buff the attacker hasn't got
        !!if&(defDuration)>0;
          !!BM(atkStack):Gi/?(atkDuration:y)/?(atkLevel:y);

          !!FU(Array_Push)&(atkDuration)<=0:P(availSpellsList)/i;
        !!en;
      !!en;
    !!en;

    !!SN:M(availSpellsList)/?(size:y);

    !!if&(size)>0;
      ; Get the spell
      !!VR(random:y):R0/1/(size) -1;
      !!SN:M(availSpellsList)/(random)/?(spell:y);

      ; Get the details of the spell
      !!BM(defStack):G(spell)/?(duration:y)/?(level:y);      
      !!VR(level):F(SKILL_NOT_LEARNED)/(SKILL_ADVANCED); [not exceeding advanced]

      ; Remove the spell from the target and put it on the attacker
      !!FU(tum_RemoveSpellFromStack):P(defStack)/(spell);

      !!if&(spell)<>(SPELL_VENDETTA);
        !!BM(atkStack):P?(pos:y) C(spell)/(pos)/(level)/(duration)/(TRUE); [piercing spell immunity]

      !!el;
        !!BM(atkStack):M(spell)/(duration)/(level);
      !!en;

      ; Show cosmetics
      !!if&i^battle_isVisible^;
        !!if&(spell)=(SPELL_VENDETTA);
          !!SN:P^NravenEye^;
          !!FU(tum_PlayCustomAnimationOnStack):P(atkStack)/^ravEyeAni^/0;
        !!en;

        !!VR(atkIsPlural:y):S(atkNum) -1 B;
        !!BM(defStack):T?(defMon:y);
        !!VR(defIsPlural:y):S(defNum) -1 B;
        !!SN:H^monname^/(atkMon)/(atkIsPlural)/?(atkMonName:z) H^monname^/(defMon)/(defIsPlural)/?(defMonName:z);
        !!SN:H^spell^/(spell)/(SPELL_TEXT_NAME)/?(spellName:z);
        !!SN:T^tumr.str.spellAbsorption^/?(battleLog:z)/^atkMon^/(atkMonName)/^defMon^/(defMonName)/^spell^/(spellName);
        !!MM:S(battleLog);
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckIfMonHasSpellAbsorption);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_MIRACLE_MAGE):S(TRUE);


// Primal Faerie Dragons' Weakening Aura
; Increase the spell damage received of adjacent hostile stacks by 30%
!?FU(OnMagicCorrectedResistance);
!!MR:N?(spellTargetStack:y);
!!FU(tum_GetAdjacentStacksOfStack):P(spellTargetStack)/?(adjacentStacksList:y)/-1/(FALSE)/(TRUE);
!!SN:M(adjacentStacksList)/?(size:y);

!!if&(size)>0;
  !!re i/0/(size)/1/-1;
    !!SN:M(adjacentStacksList)/i/?(adjacentStack:y);
    !!BM(adjacentStack):T?(type:y);
    !!FU(tum_CheckIfMonHasWeakeningAura):P(type)/?(result:y);

    !!br&(result);
  !!en;

  !!if&i<(size);
    !!MR:D?(basicDmg:y) F?(correctedDmg:y);
    !!VR(newCorrectedDmg:y):S(basicDmg) *30 :100 +(correctedDmg);
    !!MR&(newCorrectedDmg)>(correctedDmg):F(newCorrectedDmg);
  !!en;
!!en;

!?FU(tum_CheckIfMonHasWeakeningAura);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_PRIMAL_FAERIE_DRAGON):S(TRUE);


// Assassin's Backstab
; Increase damage when attacking from behind (ass we can)
!?FU(OnStackToStackDamage);
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU&(isDistant):E;

; Check if the attaker can backstab
!!BM(atkStack):T?(mon:y);
!!FU(tum_CheckMonBackstabBonus):P(mon)/?(bonus:y);

!!if&(bonus)>0;
  !!VR(isBackPos:y):S(FALSE);
  !!BM(defStack):I?(side:y);

  !!if&(isTheoretical);
    ; Check if cursor is at the backstab position - thanks to wessonsm
    !!UN:C6918832/4/?(mouseMgr:y);
    !!UN:C(mouseMgr)/80/4/?(cursorFrame:y);

    !!if&(side)=(BATTLE_LEFT);
      !!VR(backCursor:y):S8;
    !!el;
      !!VR(backCursor):S11;
    !!en;

    !!VR(isBackPos)&(cursorFrame)=(backCursor):S(TRUE);

  !!el;
    ; Check if the attacker stands on the backstab position
    !!BM(atkStack):P?(atkPos:y);

    ; Get the back position of the defender
    !!BM(defStack):P?(defPos:y) F?(monFlags:y);
    !!VR(isWide:y):S(monFlags) &(MON_FLAG_WIDE) B;

    !!if&(side)=(BATTLE_LEFT);
      !!VR(backPos:y):S(defPos) -1 -(isWide);
    !!el;
      !!VR(backPos):S(defPos) +1 +(isWide);
    !!en;

    !!VR(isBackPos)&(atkPos)=(backPos):S(TRUE);
  !!en;

  ; Change the damage if it's at the backstab position
  !!if&(isBackPos);
    !!VR(finalDmgNew:y):S(finalDmgConst) *(bonus) :100 +(finalDmg);

    !!if&(finalDmgNew)>(finalDmg);
      !!VR(finalDmg):S(finalDmgNew); [Fix overflow if needed]

      !!if&(isTheoretical)/i^battle_isVisible^;
        !!SN:T^tumr.str.backstab^/?s^tum_extraBattleMonMouseHint^/^bonus^/(bonus);
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonBackstabBonus);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_ASSASSIN):S30;


// Smooth Criminal's White Disguise
; Well...
!?FU(tum_CreateERMHook);
!#VA(setHook:x);

!!SN:E(setHook)/1/4446789/(tum_BattleStack_InitDefsAndWavs); 43DA45
!!SN:E(setHook)/1/4642757/(tum_OnCombatCreaturePanel_Prepare); 46D7C5

; Replace sound and sprite on the battlefield
!?FU(OnAfterErmInstructions);
!!FU(NewStrArray):P4/?i^tum_smoothCriminalStrings^/(M_STORED);
!!SN:Vi^tum_smoothCriminalStrings^/0/^smoo^/^smoothCr.def^/^%T(tumr.str.smoothCriminal0)^/^%T(tumr.str.smoothCriminal1)^;

!?FU(tum_BattleStack_InitParams);
!#VA(stackId:x) (side:x);

!!BM(stackId):T?(type:y);

!!if&(type)=(MON_ASSASSIN);
  !!VR(random:y):R0/1/100;              [chance]

  !!if&(random)<=1;
    !!BM(stackId):Z?(stackStruct:y);
    !!SN:Mi^tum_smoothCriminalStrings^/?(ptr:y)/0;
    !!UN:C(stackStruct)/124/4/(ptr);

    ; Creature name - not working at the moment
    !!SN:Mi^tum_smoothCriminalStrings^/?(ptr)/2;
    !!UN:C(stackStruct)/136/4/(ptr);
    !!SN:Mi^tum_smoothCriminalStrings^/?(ptr)/3;
    !!UN:C(stackStruct)/140/4/(ptr);

    !!VRi^tum_smoothCriminalFound^:S(TRUE);
  !!en;
!!en;

!?FU(tum_BattleStack_InitDefsAndWavs)&i^tum_smoothCriminalFound^;
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBX)/4/?(stackStruct:y);
!!UN:C(stackStruct)/52/4/?(type:y);

!!if&(type)=(MON_ASSASSIN);
  !!SN:Mi^tum_smoothCriminalStrings^/?(ptr:y)/1;
  ; Set def for what creature looks on the battlefield
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ECX)/4/(ptr);
  ; Set def for creature info dialog
  !!UN:C(stackStruct)/128/4/(ptr);     [0x80]
!!en;

!!VRi^tum_smoothCriminalFound^:S(FALSE);

; Big Portrait - thanks for daemon's help on the hook!
!?FU(tum_OnCombatCreaturePanel_Prepare);
!#VA(hook:x);

!!UN:C6916120/4/?(isCombatCreaturePanelEnabled:y); [system setting]

!!if&(isCombatCreaturePanelEnabled);
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/8/4/?(stackStruct:y); // get combatCreature
  !!UN:C(stackStruct)/52/4/?(type:y);

  !!if&(type)=(MON_ASSASSIN);
    !!UN:C(stackStruct)/124/4/?(soundPrefixPtr:y);
    !!SN:B(soundPrefixPtr)/d/?(soundPrefix:z);

    !!if&(soundPrefix)=^smoo^;
      !!SN:R^twcrport.def:0_262.png^/^data\defs\twcrport.def\0_262a.png^;
    !!el;
      !!SN:R^twcrport.def:0_262.png^/^^;
    !!en;
  !!en;
!!en;

!?FU(OnAfterBattleUniversal);
!!SN:R^twcrport.def:0_262.png^/^^;

; Play extra sound when Cutthroat (Era Scripts) triggered
!?FU(OnBeforeBattleStackTurn)&i^es_758_defStack^>(NO_STACK);
!#VA(stack:x);

; Check if it is a Smooth Criminal
!!BM(stack):Z?(stackStruct:y);
!!UN:C(stackStruct)/124/4/?(ptr:y);
!!SN:B(ptr)/d/?(soundName:z);

!!SN&(soundName)=^smoo^:P^smooDONT^;


// Mermaid's Protection from Whirlpool
; Protect the hero from losing troops when passing through Whirlpool
!?FU(tum_OnEnterWhirlpool);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/(UNC_INT)/?(ebp:y) C(ebp)/8/(UNC_INT)/?(heroStruct:y);
!!UN:C(heroStruct)/26/(UNC_INT)/?(heroId:y);

!!re i/(ARMY_SLOT_FIRST)/(ARMY_SLOT_LAST);
  !!HE(heroId):C0/i/?(type:y)/?(num:y);

  !!if&(type)>(NO_MON)/(num)>0;
    !!FU(tum_CheckIfMonHasProtectionFromWhirlpool):P(type)/?(result:y);

    !!if&(result);
      !!SN:X?t/0;
      !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/(UNC_INT)/4901007;

      !!br;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckIfMonHasProtectionFromWhirlpool);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_MERMAID):S(TRUE);


// Ice Knights' Ice Cloak
; Casts Frost Ring when melee attacked once per round
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

; Check if the defedner has ice cloak
!!BM(defStack):T?(defMon:y) N?(defNum:y);
!!FU(tum_CheckMonIceCloakDamage):P(defMon)/?(iceCloakDmg:y);

; Check if the ability has been used this turn
!!if&(iceCloakDmg)>0/(defNum)>0/i^tum_abilityCounter_%(defStack)^=0;
  ; Activate the ability
  *!if&i^battle_isVisible^;
    *!VR(isPlural:y):S(num) -1 B;
    *!SN:H^monname^/(defMon)/(isPlural)/?z2;
    *!SN:T^tumr.str.iceCloak^/?z3/^mon^/z2;
  *!en;

  !!BM(defStack):P?(pos:y);
  !!FU(tum_CastMonsterDamagingSpell):P(defStack)/(SPELL_FROST_RING)/(pos)/(iceCloakDmg);

  ; Set the ability counter
  !!VRi^tum_abilityCounter_%(defStack)^:+1;
!!en;

!?FU(tum_CheckMonIceCloakDamage);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_ICE_KNIGHT):S10;
!!VR(result)&(mon)=(MON_TRITON):S6;
!!VR(result)&(mon)=(MON_ABYSSAL_TRITON):S10;


// Thunder Warrior's Lightning Rod
; Casts Lightning Bolt to an adjacent enemy on battle action end
!?FU(OnBattleActionEnd)&i^battle_acting_stack^>(NO_STACK); [it can possibly be -1 for some reason]
; Exit if the action is not correct
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_WALK)/
     (action)<>(BATTLE_ACTION_WALK_AND_ATTACK)/
     (action)<>(BATTLE_ACTION_DEFEND):E;

; Check if the acted stack has Lightning Rod
!!BMi^battle_acting_stack^:T?(mon:y) N?(num:y);
!!FU(tum_CheckIfMonHasLightningRod):P(mon)/?(result:y);

!!if&(result)/(num)>0;
  !!VR(stack:y):Si^battle_acting_stack^;
  !!VR(side:y):Si^battle_acting_side^;

  ; Get all the adjacent stacks around the acted stack
  !!BM(stack):P?(pos:y);
  !!FU(NewIntArray):P?(validStacks:y);

  !!re i/0/5;
    !!FU(tum_GetAdjacentHex):P(pos)/i/?(adjacentHex:y);

    !!if&(adjacentHex)>-1;
      !!BU:E(adjacentHex)/?(targetStack:y);

      !!if&(targetStack)>(NO_STACK);
        ; Only works for hostile units
        !!BM(targetStack):I?(targetSide:y);

        !!if&(side)<>(targetSide);
          ; Check spell immunity, only a stack without lightning immunity is valid
          !!FU(tum_Battle_CanStackReceiveSpell):P(targetStack)/(SPELL_LIGHTNING_BOLT)/(side)/?(canReceive:y);

          !!FU(Array_Push)&(canReceive):P(validStacks)/(targetStack);
        !!en;
      !!en;
    !!en;
  !!en;

  ; Choose a random victim among the adjacent stacks, if there is one
  !!SN:M(validStacks)/?(size:y);

  !!if&(size)>0;
    !!VR(random:y):R0/1/(size) -1;
    !!SN:M(validStacks)/(random)/?(randomTarget:y);
    !!BM(randomTarget):P?(targetPos:y);

    ; Activate the ability
    *!if&i^battle_isVisible^;
      *!VR(isPlural:y):S(num) -1 B;
      *!SN:H^monname^/(mon)/(isPlural)/?(monName);
      *!SN:T^tumr.str.lightningRod^/?(battleLog)/^mon^/(monName);
      *!MM:S(battleLog);
    *!en;

    !!FU(tum_CastMonsterDamagingSpell):P(stack)/(SPELL_LIGHTNING_BOLT)/(targetPos)/10;
  !!en;
!!en;

!?FU(tum_CheckIfMonHasLightningRod);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_THUNDER_WARRIOR):S(TRUE);


// Mana Skeleton's Spell Break
; Reduce one spell from the attacked target
; This is super useful dealing with Phoenix, as they have one of the most powerful spells
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkNum)>0/(defNum)>0;
  !!BM(atkStack):T?(atkMon:y);
  ; Check if the attacker can break spell
  !!FU(tum_CheckIfMonHasSpellBreak):P(atkMon)/?(result:y);

  !!if&(result);
    ; Check if the defender has spell to be broken
    !!BM(defStack):E?(spells:y);

    !!if&(spells)>0;
      !!if&i^battle_isVisible^;
        !!BM(defStack):T?(defMon:y);
        !!VR(defIsPlural:y):S(defNum) -1 B;
        !!SN:H^monname^/(defMon)/(defIsPlural)/?(monName:z);
        !!SN:T^tumr.str.spellBreak^/?(battleLog:z)/^mon^/(monName);
        !!MM:S(battleLog);

        !!SN:P^ManaDrai^;               [Mana Drain sound]
        !!FU(tum_PlayCustomAnimationOnStack):P(defStack)/^vortex^;
      !!en;

      !!BM(defStack):Ed-1;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckIfMonHasSpellBreak);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_MANA_SKELETON):S(TRUE);


// Moss Thrall's Adaptability
; Different abilities depends on the terrain of battlefield
; Set up new descriptions
; Here we use two stage in order to be compatible with global vars like i^battle_isVisible^ and the string array i^tum_battleStrings^'s initialization
!?FU(OnSetupBattlefield)&i^battle_isVisible^;
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!BMi:T?(type:y) N?(num:y);

  !!if&(type)>(NO_MON)/(num)>0;
    !!FU(tum_CheckIfMonHasAdaptability):P(type)/?(result:y);
    !!FU(tum_SetUpAdaptabilityDesc)&(result):Pi;
  !!en;
!!en;

; Disabled for now. We assume there would be no creature with Adapterbility summoned after battlefield initialised
*?FU(tum_BattleStack_InitParams)&i^tum_tacticsIsEnded^/i^battle_isVisible^;
*#VA(stack:x) (side:x);

*!BM(stack):T?(type:y);
*!FU(tum_CheckIfMonHasAdaptability):P(type)/?(result:y);
*!FU(tum_SetUpAdaptabilityDesc)&(result):P(stack);

!?FU(tum_SetUpAdaptabilityDesc);
!#VA(stack:x);

; Get the original descriptions
!!BM(stack):Z?(stackStruct:y);
!!UN:C(stackStruct)/144/(UNC_INT)/?(descPtr:y);
!!SN:B(descPtr)/(UNC_INT)/?(desc:z);

; Get new descriptions
!!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(terrainType:y)/?t/?t/?t/?t/?t/?t/?t;
!!SN:T^tumr.str.adaptabilityDesc%(terrainType)^/?(newDesc:z);

; Set up combined description
!!VR(desc):+^%T(tumr.str.endl)^ +^%T(tumr.str.endl)^ +(newDesc);

!!FU(tum_AllocBattleStr):P(desc)/?(newDescAddr:y);
!!UN:C(stackStruct)/144/(UNC_INT)/(newDescAddr);


; Dirt, Slow attack
; Snow, 20% chance to attack with Ice Bolt
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkNum)>0/(defNum)>0;
  !!BM(atkStack):T?(type:y);
  !!FU(tum_CheckIfMonHasAdaptability):P(type)/?(result:y);

  !!if&(result);
    !!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(terrainType:y)/?t/?t/?t/?t/?t/?t/?t;

    !!if&(terrainType)=0;               [Dirt]
      !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/100/(SPELL_SLOW)/(SKILL_ADVANCED);
    !!el&(terrainType)=3;               [Snow]
      !!FU(tum_CastSpellAfterAttack):P(atkStack)/(defStack)/20/(SPELL_ICE_BOLT)/10;
    !!en;
  !!en;
!!en;

; Sand, deals only 95% of damage
; Subterranean, 10% chance to block a physical attack
!?FU(OnStackToStackDamage);
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!FU&(isDistant):E;

!!BM(atkStack):T?(atkType:y);
!!FU(tum_CheckIfMonHasAdaptability):P(atkType)/?(result:y);

!!if&(result);
  !!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(terrainType:y)/?t/?t/?t/?t/?t/?t/?t;

  !!if&(terrainType)=1;                 [Sand]
    !!VR(dmgReduction:y):S(finalDmgConst) :20; [5% damage]
    !!VR(finalDmgNew:y):S(finalDmg) -(dmgReduction);
    !!VR(finalDmg)&(finalDmgNew)<(finalDmg):S(finalDmgNew);
  !!en;

!!el;
  !!BM(defStack):T?(defType:y);
  !!FU(tum_CheckIfMonHasAdaptability):P(defType)/?(result:y);

  !!if&(result);
    !!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(terrainType:y)/?t/?t/?t/?t/?t/?t/?t;

    !!if&(terrainType)=6;                 [Subterranean]
      !!FU&(isTheoretical)=(TRUE):E;

      !!VR(random:y):R0/0/99;

      !!if&(random)<10;                   [10% chance]
        !!VR(finalDmg):S0;

        !!if&i^battle_isVisible^;
          !!FU(tum_ShowBlockCosmetics):P(defStack)/(defType);
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

; Grass, haste
!?FU(tum_BattleStack_InitParams);
!#VA(stack:x) (side:x);

!!BM(stack):T?(type:y);
!!FU(tum_CheckIfMonHasAdaptability):P(type)/?(result:y);

!!if&(result);
  !!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(terrainType:y)/?t/?t/?t/?t/?t/?t/?t;

  !!if&(terrainType)=2;
    !!BM(stack):M(SPELL_HASTE)/1000/(SKILL_ADVANCED);
  !!en;
!!en;

!?FU(OnBattleRound);
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!BMi:T?(type:y) N?(num:y);

  !!if&(type)>(NO_MON)/(num)>0;
    !!FU(tum_CheckIfMonHasAdaptability):P(type)/?(result:y);

    !!if&(result);
      !!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(terrainType:y)/?t/?t/?t/?t/?t/?t/?t;

      !!if&(terrainType)=2;
        !!BMi:M(SPELL_HASTE)/1000/(SKILL_ADVANCED);
      !!en;
    !!en;
  !!en;
!!en;

; Swamp, casts poison at the end of action (once each turn)
!?FU(OnBattleActionEnd)&i^battle_acting_stack^>(NO_STACK);
!!BMi^battle_acting_stack^:T?(mon:y) N?(num:y);
!!FU(tum_CheckIfMonHasAdaptability):P(mon)/?(result:y);

!!if&(result)/(num)>0;
  !!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(terrainType:y)/?t/?t/?t/?t/?t/?t/?t;

  ; Check if the ability has been used this turn
  !!if&(terrainType)=4;
    !!VR(stack:y):Si^battle_acting_stack^;
    !!VR(side:y):Si^battle_acting_side^;

    !!if&i^tum_abilityCounter_%(stack)^=0;
      ; Get all the adjacent stacks around the acted stack
      !!BM(stack):P?(pos:y);
      !!FU(NewIntArray):P?(validStacks:y);

      !!re i/0/5;
        !!FU(tum_GetAdjacentHex):P(pos)/i/?(adjacentHex:y);

        !!if&(adjacentHex)>-1;
          !!BU:E(adjacentHex)/?(targetStack:y);

          !!if&(targetStack)>(NO_STACK);
            ; Only works for hostile units
            !!BM(targetStack):I?(targetSide:y);

            !!if&(side)<>(targetSide);
              ; Check spell immunity, only a stack without Poision immunity is valid
              !!FU(tum_Battle_CanStackReceiveSpell):P(targetStack)/71/(side)/?(canReceive:y);

              !!FU(Array_Push)&(canReceive):P(validStacks)/(targetStack);
            !!en;
          !!en;
        !!en;
      !!en;

      ; Choose a random victim among the adjacent stacks, if there is one
      !!SN:M(validStacks)/?(size:y);

      !!if&(size)>0;
        !!VR(random:y):R0/1/(size) -1;
        !!SN:M(validStacks)/(random)/?(randomTarget:y);
        !!BM(randomTarget):P?(targetPos:y);

        !!BM(stack):C71/(targetPos)/(SKILL_NOT_LEARNED)/3/(TRUE);

        ; Set the ability counter
        !!VRi^tum_abilityCounter_%(stack)^:+1;
      !!en;
    !!en;
  !!en;
!!en;

; Rough, 25% spell resistance
!?FU(OnDwarfMagicResistance)&i^tum_%(ART_ORB_OF_VULNERABILITY)_equipped^<>(TRUE);
!!MR:M?(mon:y);

!!FU(tum_CheckIfMonHasAdaptability):P(mon)/?(result:y);

!!if&(result);
  !!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(terrainType:y)/?t/?t/?t/?t/?t/?t/?t;

  !!if&(terrainType)=5;
    !!MR:F?(resistance:y);
    !!VR(resistance):+25 F0/100;
    !!MR:F(resistance);
  !!en;
!!en;

; Lava, suffer 30% more fire spell damage
!?FU(OnMagicCorrectedResistance);
!!MR:M?(type:y);
!!FU(tum_CheckIfMonHasAdaptability):P(type)/?(result:y);

!!if&(result);
  !!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(terrainType:y)/?t/?t/?t/?t/?t/?t/?t;

  !!if&(terrainType)=7;
    !!MR:S?(spell:y);

    !!SS(spell):S?(schoolBits:y);
    !!VR(isFireSchool:y):S(schoolBits) &2;  [2 - Fire school]

    !!if&(isFireSchool);
      !!MR:D?(basicDmg:y) F?(fixedDmg:y);
      !!VR(newDmg:y):S(basicDmg) :10 *3 +(fixedDmg);
      !!MR&(newDmg)>(fixedDmg):F(newDmg);
    !!en;
  !!en;
!!en;

; Water, regenerating 35 HP every turn (possible to revive)
!?FU(OnBattleStackObtainsTurn)&i^tum_tacticsIsEnded^;
!!BMi^battle_current_stack^:T?(type:y);

!!if&(type)=(MON_MOSS_THRALL);
  !!VR(stack:y):Si^battle_current_stack^;

  !!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(terrainType:y)/?t/?t/?t/?t/?t/?t/?t;

  !!if&(terrainType)=8;
    !!FU(tum_HealAndReviveStack):P(stack)/35/?(reviveNum:y)/?(actualRegenHp:y);

    ; Here we use Eternal Resilience for cosmetic stuff
    !!if&i^battle_isVisible^/(actualRegenHp)>0;
      !!FU(tum_ShowEternalResilienceCosmetics):P(stack)/(type)/(reviveNum)/(actualRegenHp);
    !!en;
  !!en;
!!en;

; Function to check everything
!?FU(tum_CheckIfMonHasAdaptability);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_MOSS_THRALL):S(TRUE);


// Shadow Lords' True Teleportation
; Access to any hex on the battlefield
; Does not affect the order of units
; Don't use i^battle_round^>=0 as condition here, it would skip the first Shadow Sneaker's bonus
!?FU(OnBeforeBattleStackTurn_Quit)&i^tum_tacticsIsEnded^;
!#VA(stack:x);

!!BM(stack):T?(type:y);
!!FU(tum_CheckIfMonHasTrueTeleportation):P(type)/?(result:y);

!!if&(result);
  !!BM(stack):Sd30;
  !!VRi^tum_trueTeleportationStackPlusOne^:S(stack) +1;
!!en;

; Restore the speed of True Teleporter
!?FU(OnBattleActionEnd)&i^tum_trueTeleportationStackPlusOne^/i^tum_isBattleStackAction^;
!!VR(stack:y):Si^tum_trueTeleportationStackPlusOne^ -1;
!!BM(stack):S?(speed:y);
!!VR(speed):-30 F1/(INT_MAX);
!!BM(stack):S(speed);
!!VRi^tum_trueTeleportationStackPlusOne^:S0;

!?FU(OnAfterBattleUniversal);
!!VRi^tum_trueTeleportationStackPlusOne^:S0;

!?FU(tum_CheckIfMonHasTrueTeleportation);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_SHADOW_LORD):S(TRUE);


// Shadow Lords' Shadow Sneak
; Cancel the incoming attack, teleports to the back of the attacker and initiates retaliation
!?FU(OnBeforeBattleAction);
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_WALK_AND_ATTACK)/(action)<>(BATTLE_ACTION_SHOOT):E;

; Check if the defStack is no stack, it is possible when BG:D-1 (Nightmare ability)
!!BG:E?(defStack:y);
!!FU&(defStack)<=(NO_STACK):E;

; Check if the target can perform Shadow Sneak
!!BM(defStack):T?(defType:y);
!!FU(tum_GetMonShadowSneakChance):P(defType)/?(chance:y);
!!FU&(chance)=0:E;

; Check if it is lucky
!!VR(random:y):R0/0/99;
!!FU&(random)>(chance):E;

; Check if possible to retaliate
!!VR(atkStack:y):Si^battle_acting_stack^;
!!BM(defStack):I?(defSide:y);
!!FU(tum_CheckIfStackCanBeRetaliated):P(atkStack)/(defSide)/?(result:y);
!!FU&(result)<>(TRUE):E;

!!BM(defStack):R?(retals:y);
!!FU&(retals)<=0:E;

; Check if there is any available hex next to the attacking stack
; Here we separate the unoccupied hexes and the hex Shadow Sneaker standing on as we prefer the shadow sneaker moves a bit before retaliating if possible
!!FU(tum_GetAvailAdjacentPositionsOfStack):P(atkStack)/?(availHexesList:y);
!!SN:M(availHexesList)/?(size:y);

; New position for the Shadow Sneaker
!!VR(newDefPos:y):S-1;

; If there is at least one available spot adjacent to the attacker, check if any of them reachable by the Shadow Sneaker
!!if&(size)>0;
  ; Get the hex of the back (even it cannot be accessed apart from teleporting)
  !!BM(atkStack):P?(atkPos:y) I?(atkSide:y);

  !!if&(atkSide)=(BATTLE_LEFT);
    !!VR(posBehind:y):S(atkPos) -1;
  !!el;
    !!VR(posBehind):S(atkPos) +1;
  !!en;

  ; Get the best hex to teleport (position closest to the position behind) from the array
  ; Also check if the hex is reachable with the Shadow Sneaker's speed
  !!BM(defStack):Z?(defStruct:y);
  !!VR(minDistance:y):S(INT_MAX);

  !!re i/0/(size)/1/-1;
    !!SN:M(availHexesList)/i/?(hex:y);

    ; Check if the hex from array is accessible by Shadow Sneaker (if the speed allowing it do so)
    !!SN:E5390176/(CALLCONV_THISCALL)/(defStruct)/(hex)/0;

    !!if&v1;
      !!FU(tum_CalcHexesDistance):P(posBehind)/(hex)/?(distance:y);
      !!VR(newDefPos)&(distance)<(minDistance):S(hex);
    !!en;
  !!en;
!!en;

; If no available position found, check if the shadow sneaker is next to the target
!!if&(newDefPos)=-1;
  !!FU(tum_CheckIfStacksAreAdjacent):P(atkStack)/(defStack)/?(result:y);
  !!FU&(result)<>(TRUE):E;
!!en;

; log
!!if&i^battle_isVisible^;
  !!BM(defStack):N?(defNum:y);
  !!VR(isPlural:y):S(defNum) -1 B;
  !!SN:H^monname^/(defType)/(isPlural)/?(defMonName:z);

  !!BM(atkStack):T?(atkType:y) N?(atkNum:y);
  !!VR(isPlural):S(atkNum) -1 B;
  !!SN:H^monname^/(atkType)/(isPlural)/?(atkMonName:z);

  !!SN:T^tumr.str.shadowSneak^/?(msg:z)/^defMon^/(defMonName)/^atkMon^/(atkMonName);
  !!MM:S(msg);
!!en;

; Move the Shadow Sneaker
!!if&(newDefPos)>-1;
  !!BM(defStack):Z?(defStruct:y);
  !!SN:E4479536/(CALLCONV_THISCALL)/(defStruct)/(newDefPos)/0; [move to position]
!!en;

!!FU(tum_MakeStackMeleeAttackStack):P(defStack)/(atkStack);

; Reduce one retaliation
!!BM(defStack):Rd-1;

; Cancel the attack
!!BG:A(BATTLE_ACTION_SKIP);

!?FU(tum_GetMonShadowSneakChance);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_SHADOW_LORD):S17;


// Wendigos' Flesh-eater
; Eat the stack killed by attack and wipe it from the battlefield completely
; If the stack was killed not resulted by an attack dealt by Flesh-eaters, then it's no longer possible to be consumed
!?FU(OnMonsterPhysicalDamage);
; Exit if not direct melee or strike all around
!!UN:C42149568/(UNC_INT)/?(dmgType:y);
!!FU&(dmgType)<>4456676/(dmgType)<>4462398:E;

; Get the attacker/defender stack
!!MF:N?(defStack:y);

; If it is a retaliation
!!if&(defStack)=i^battle_acting_stack^;
  !!BG:E?(atkStack:y);
; If it is a normal attack, exit for secondary targets
!!el;
  !!BG:E?(targetStack:y);
  !!FU&(defStack)<>(targetStack):E;

  !!VR(atkStack):Si^battle_acting_stack^;
!!en;

!!FU|(atkStack)=(NO_STACK)/(defStack)=(NO_STACK):E;

; Check if the attacking monster is a flesh eater
!!BM(atkStack):T?(type:y);
!!FU(tum_CheckIfMonIsFleshEater):P(type)/?(result:y);

!!if&(result);
  !!MF:F?(finalDmg:y);

  ; Check if the defedning monster is a living one
  !!BM(defStack):F?(monFlags:y);
  !!VR(isAlive:y):S(monFlags) &(MON_FLAG_ALIVE);

  !!if&(isAlive);
    ; Check if the defending monster would be be killed by the flesh eater
    !!BM(defStack):N?(num:y) H?(hp:y) L?(lostHp:y);
    !!VR(defCurrTotalHp:y):S(num) *(hp) -(lostHp);

    ; Store the hp of the def stack if it would be killed, set up flags for the victim to disappear 
    !!if&(finalDmg)>=(defCurrTotalHp);
      !!VRi^tum_flesheaterRegenHp^:S(defCurrTotalHp);
      !!BM(defStack):Fd|813694976 E0;    [Clone, Sacrified, No Colouring]
    !!en;
  !!en;
!!en;

!?FU(tum_OnAfterMelee)&i^tum_flesheaterRegenHp^;
!#VA(atkStack:x) (defStack:x);

; Warning: 
; In some case the attacerk's killed, or the defender wasn't killed, quit the flesh eating scene
; However, the defender would still suffer from clone flag/0 spell. Will be fixed if reported
!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);

!!if&(atkNum)>0/(defNum)<=0;
  ; Remove the clone flag from the defender
  !!BM(defStack):Fd~(MON_FLAG_CLONE);
  
  ; Calculate the new HP and number of the flesheater
  !!VR(noHpLost:y):S(FALSE);
  !!BM(atkStack):H?(hp:y) L?(lostHp:y) B?(startNum:y);

  !!VR(totalStartHp:y):S(startNum) *(hp);
  !!VR(totalHp:y):S(atkNum) *(hp) -(lostHp);
  !!VR(noHpLost)&(totalStartHp)=(totalHp):S(TRUE);

  !!VR(newTotalHp:y):S(totalHp) +i^tum_flesheaterRegenHp^ F(totalHp)/(totalStartHp);
  !!VR(newCurrHp:y):S(newTotalHp) %(hp);
  !!VR(newNum:y):S(newTotalHp) :(hp) +1;

  !!if&(newCurrHp)=0;
    !!VR(newCurrHp):S(hp);
    !!VR(newNum):-1;
  !!en;

  !!VR(hpDrained:y):S(newTotalHp) -(totalHp);
  !!VR(resurrectedNum:y):S(newNum) -(atkNum);

  !!VR(newLostHp:y):S(hp) -(newCurrHp);

  ; Set up new number and hp
  !!BM(atkStack):N(newNum) L(newLostHp);

  ; Show battle log and play animation/sound
  !!if&i^battle_isVisible^/(noHpLost)<>(TRUE);
    !!BM(atkStack):T?(type:y);
    !!VR(isPlural:y):S(atkNum) -1 B;
    !!SN:H^monname^/(type)/(isPlural)/?(flesheaterName:z);
    !!SN:T^tumr.str.flesheater%(isPlural)^?(battleLog:z)/^flesheater^/(flesheaterName)/^hp^/(hpDrained);
    !!MM:S(battleLog);

    ; Play sound and animation
    !!SN:P^ANIMDEAD^;
    !!BM(atkStack):V74;
  !!en;
!!en;

; Restore the global variable
!!VRi^tum_flesheaterRegenHp^:S0;

; Funciton to check if the targeted monster is eligible for flesh eating
!?FU(tum_CheckIfMonIsFleshEater);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_WENDIGO):S(TRUE);


// Everlasting Dragons' Eternal Resilience
; Regenerate some HP on stack obtains turn - possible to revive
!?FU(OnBattleStackObtainsTurn)&i^tum_abilityCounter_%i(battle_current_stack)^=0;
!!BMi^battle_current_stack^:T?(type:y) N?(num:y);
!!FU(tum_GetMonEternalResilienceHp):P(type)/?(staticHp:y)/?(individualHp:y);
!!VR(regenHp:y):S(num) *(individualHp) +(staticHp);

!!if&(regenHp)>0;
  !!VR(stack:y):Si^battle_current_stack^;

  ; Set the ability counter
  !!VRi^tum_abilityCounter_%(stack)^:+1;  

  ; Heal
  !!FU(tum_HealAndReviveStack):P(stack)/(regenHp)/?(reviveNum:y)/?(actualRegenHp:y);

  !!if&i^battle_isVisible^/(actualRegenHp)>0;
    !!FU(tum_ShowEternalResilienceCosmetics):P(stack)/(type)/(reviveNum)/(actualRegenHp);
  !!en;
!!en;

!?FU(tum_ShowEternalResilienceCosmetics);
!#VA(stack:x) (type:x) (reviveNum:x) (actualRegenHp:x);

!!BM(stack):N?(num:y);
!!VR(isPlural:y):S(num) -1 B;
!!SN:H^monname^/(type)/(isPlural)/?(monName:z);

!!SN:T^tumr.str.eternalResilience^/?(battleLog:z)/^mon^/(monName)/^regenHp^/(actualRegenHp);

!!if&(reviveNum)=0;
  !!SN:T^tumr.str.period^/?(battleLogExt:z);
!!el;
  !!SN:T^tumr.str.eternalResilienceExt^/?(battleLogExt)/^reviveNum^/(reviveNum);
!!en;

!!VR(battleLog):+(battleLogExt);
!!MM:S(battleLog);

; Sound
!!if&(reviveNum)=0;
  !!SN:P^Regener^;
!!el;
  !!SN:P^Resurect^;
!!en;

; Animation
!!FU(tum_PlayCustomAnimationOnStack):P(stack)/^heal^;

!?FU(tum_GetMonEternalResilienceHp);
!#VA(mon:x) (staticHp:x) (individualHp:x);

!!VR(staticHp):S0;
!!VR(individualHp):S0;

!!if&(mon)=(MON_EVERLASTING_DRAGON);
  !!VR(staticHp):S200;
  !!VR(individualHp):S30;
!!en;


// Cultist's Spell Jammer
// Disable the target's ability to cast a spell
; Difference with the original implementation: Instead of disabling the ability to cast, this hack removes spell number to prevent casts
; Original idea: http://heroescommunity.com/viewthread.php3?TID=45286&PID=1559162#focus
; Works on Enchanters and Phoenixes. That's really imba.
!?FU(OnSetupBattlefield);
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!VRi^tum_spellJammerSpells_%i^:S0;
!!en;

!?FU(tum_OnAfterShoot);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);
!!FU|(atkNum)<=0/(defNum)<=0:E;

!!BM(atkStack):T?(atkMon:y);
!!FU(tum_CheckMonSpellJammerType):P(atkMon)/?(jammerType:y);

!!if&(jammerType)>0;
  !!BM(defStack):T?(defMon:y) E?(spells:y);

  ; Skip if the monster can rebirth
  ; Disable as it's difficult to tell whether Rebirth is the only spell the monster has
  *!FU(tum_GetMonRebirthType):P(defMon)/?(rebirthType:y);

  *!if&(rebirthType)=0;
    ; Check stack exp
    *!UN:P(WOG_OPT_STACK_EXPERIENCE)/?(stackExp:y);

    *!if&(stackExp);
      *!VR(eaStack:y):S(defStack) +1 *-1;
      *!EA(eaStack):F114/?(rebirthSlot:y);
      *!EA(eaStack):B(rebirthSlot)/?(switch:y)/?(ability:y)/?(modifier:y)/?t/?t/?t/?t/?t/?t/?t/?t/?t/?t/?t; [This didn't work!]

      *!IF:L^%(ability) %(modifier)^;
    *!en;
  *!en;

  *FU&(rebirthType)>0:E;

  ; If the target stack has spell count, remove it
  ; If the target stack has spell stolen, reset the duration to 2 turns
  ; Note that there is no need to check whether the target has Rebirth as the stolen spells would be returned when the stack's killed (before rebirth check)
  !!if|(spells)>0/i^tum_spellJammerSpells_%(defStack)^>0/(defMon)=(MON_ENCHANTER);
    ; Remove spells
    !!VRi^tum_spellJammerSpells_%(defStack)^:+(spells);
    !!BM(defStack):E0;

    !!BM(defStack):M(SPELL_SPELL_JAMMER)/2/(SKILL_NOT_LEARNED);

    ; Display cosmetics
    !!if&i^battle_isVisible^;
      ; Show battle log
      !!VR(isPlural:y):S(defNum) -1 B;
      !!SN:H^monname^/(defMon)/(isPlural)/?(monName:z);
      !!SN:T^tumr.str.spellJammer%(isPlural)^/?(battleLog:z)/^mon^/(monName);
      !!MM:S(battleLog);
      ; Play sound
      !!SN:P^FORGET^;
      ; Play animation
      !!VR(animation:z):S^RedmatEff^;
      !!VR(animation)&(jammerType)=2:S^PurpmatEff^;
      !!FU(tum_PlayCustomAnimationOnStack):P(defStack)/(animation)/0;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonSpellJammerType);
!#VA(mon:x);
!#VA(result:x);                         [Type 1: Red. Type 2: Purple]

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_CULTIST):S1;
!!VR(result)&(mon)=(MON_CULTIST_LEADER):S2;

; Prevent Enchanter from casting
!?FU(tum_OnEnchanterCastsMassSpell);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/-8/4/?(stackStruct:y);

!!UN:C(stackStruct)/52/4/?(type:y);

!!if&(type)=(MON_ENCHANTER);
  !!UN:C(stackStruct)/244/4/?(side:y) C(stackStruct)/248/4/?(stackOfSide:y);
  !!VR(stack:y):S(side) *(BATTLE_STACKS_PER_SIDE) +(stackOfSide);

  !!BM(stack):G(SPELL_SPELL_JAMMER)/?(duration:y)/?(level:y);

  !!if&(duration)>0;
    !!SN:X?t/0;
    !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4488655; [Jumps and doesn't update mass spell timer]
  !!en;
!!en;

; Prevent Phoenixes rebirth
; This is triggered before FU(tum_OnBattleStackKilled)
!?FU(tum_OnBattleStackKilled);
!#VA(stack:x) (side:x);

!!VRi^tum_spellJammerSpells_%(stack)^:S0;


// Ooze's Flammable Coat
// Give fire vulnerability after melee attack (including retaliation)
; Difference with the original implementation: Using unused graphics (yellow implosion) for corrosion damage
; Original idea: http://heroescommunity.com/viewthread.php3?TID=45286&PID=1561734#focus
!?FU(tum_OnAfterMelee);
!#VA(atkStack:x) (defStack:x);

!!BM(atkStack):N?(atkNum:y);
!!BM(defStack):N?(defNum:y);
!!FU|(atkNum)<=0/(defNum)<=0:E;

!!BM(atkStack):T?(atkMon:y);
!!FU(tum_CheckMonCastsFlammableCoat):P(atkMon)/?(cloakType:y);

!!if&(cloakType)>0;
  !!BM(defStack):T?(defMon:y);
  !!FU(tum_CheckMonCastsFlammableCoat):P(defMon)/?(result:y);
  
  !!if&(result)<>(TRUE);
    !!BM(defStack):F?(flags:y);
    !!VR(isFireImmune:y):S(flags) &(MON_FLAG_FIRE_IMMUNITY);

    !!if&(isFireImmune)=0;
      !!BM(defStack):M(SPELL_FLAMMABLE_COAT)/3/(SKILL_NOT_LEARNED);

      ; Display cosmetics
      !!if&i^battle_isVisible^;
        ; Show battle log
        !!VR(isPlural:y):S(defNum) -1 B;
        !!SN:H^monname^/(defMon)/(isPlural)/?(monName:z);
        !!SN:T^tumr.str.flammableCoatBuff%(isPlural)^/?(battleLog:z)/^mon^/(monName);
        !!MM:S(battleLog);
        ; Play sound
        !!SN:P^DISEASE^;
        ; Play animation
        !!FU(tum_PlayCustomAnimationOnStack):P(defStack)/^greenOoze^/0;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(OnMagicCorrectedResistance);
!!MR:N?(stack:y);

!!BM(stack):G(SPELL_FLAMMABLE_COAT)/?(duration:y)/?(level:y);

!!if&(duration)>0;
  !!MR:S?(spell:y);

  !!SS(spell):S?(schoolBits:y);
  !!VR(isFireSchool:y):S(schoolBits) &2;  [2 - Fire school]

  !!if&(isFireSchool);
    !!MR:D?(basicDmg:y) F?(fixedDmg:y);
    !!VR(newDmg:y):S(basicDmg) :2 +(fixedDmg);
    !!MR&(newDmg)>(fixedDmg):F(newDmg);
  !!en;
!!en;

!?FU(OnBattleRound)&i^battle_round^>=0;
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!BMi:N?(num:y);

  !!if&(num)>0;
    !!BMi:G(SPELL_FLAMMABLE_COAT)/?(duration:y)/?(spellLevel:y);

    !!if&(duration)>0;
      !!BMi:T?(type:y);
      !!MA:L(type)/?(monLevel:y);
      !!VR(realLevel:y):S(monLevel) +1;

      !!if&(realLevel)>=7;
        !!MA:F(MON_BLOOD_DRAGON)/?(bloodDragonFv:y) F(type)/?(fv:y);
        !!VR(realLevel)&(fv)>=(bloodDragonFv):S8;
      !!en;

      !!VR(damage:y):S(realLevel) *5;
      !!BMi:K(damage);

      !!if&i^battle_isVisible^;
        !!FU(tum_UpdateStackAnimation):P;

        ; Battle log
        !!VR(isPlural:y):S(num) -1 B;
        !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
        !!SN:T^tumr.str.flammableCoatDmg%(isPlural)^/?(battleLog:z)/^mon^/(monName)/^dmg^/(damage);
        !!MM:S(battleLog);

        !!SN:P^FAERATTK^;
        !!FU(tum_PlayCustomAnimationOnStack):Pi/^yellowSlime^/1;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonCastsFlammableCoat);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)|(mon)=(MON_OOZE)/(mon)=(MON_GEL_OOZE):S(TRUE);


// Gel Ooze's Shed
; Remove debuff at the start of every round
!?FU(OnBattleRound)&i^battle_round^>=0;
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!BMi:N?(num:y);

  !!if&(num)>0;
    !!BMi:T?(type:y);
    !!FU(tum_CheckMonCanShed):P(type)/?(result:y);

    !!if&(result);
      !!BMi:Z?(stackStuct:y);

      !!re j/(SPELL_FIRST_BATTLE)/(SPELL_LAST_BATTLE);
        !!SSj:O?(spellType:y);

        !!if&(spellType)=-1;
          !!BMi:Gj/?(duration:y)/?(level:y);
          !!FU(tum_RemoveSpellFromStack)&(duration)>0:Pi/j;
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_CheckMonCanShed);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_GEL_OOZE):S(TRUE);


// Scouting Bonus (Monsters and Artifacts)
; For Monsters: This script works only for +1 range and not other values, this is to reduce the amount of calculation executing, as this hook triggers pretty often
; For Artifacts: This script works for +4 range only
!?FU(tum_OnGetScoutingRadius);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/(UNC_INT)/?(heroStruct:y);
!!UN:C(heroStruct)/26/(UNC_INT)/?(heroId:y);

!!VR(scoutingBonus:y):S0;

// Rook and Raven's Scouting Range +1
!!re i/(ARMY_SLOT_FIRST)/(ARMY_SLOT_LAST);
  !!HE(heroId):C0/i/?(type:y)/?(num:y);

  !!if&(type)>(NO_MON)/(num)>0;
    !!FU(tum_CheckIfMonHasScoutingRangePlusOne):P(type)/?(result:y);

    !!if&(result);
      !!VR(scoutingBonus):+1;

      !!br;
    !!en;
  !!en;
!!en;

// Binoculars's Scouting Range +4 (Binoculars Part 2)
!!if&i^tum_emerald_on^;
  !!HE(heroId):A2/(ART_BINOCULARS)/?(has:y)/?(equipped:y);

  !!if&(equipped)>0;
    !!VR(scoutingBonus):+4;
  !!en;
!!en;

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/(UNC_INT)/d(scoutingBonus);

!?FU(tum_CheckIfMonHasScoutingRangePlusOne);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)|(mon)=(MON_ROOK)/(mon)=(MON_RAVEN):S(TRUE);


// Rook and Raven's Vendetta
; Receive additional attack and max damage after attacked
; This implementation is slightly different its origin: Vendetta is triggered after the attack happens. I guess this is actually better than in VCMI. 
; The origin: http://heroescommunity.com/viewthread.php3?TID=45286&PID=1564383#focus
!?FU(OnSetupBattlefield);
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!VRi^tum_vendettaAtk_%i^:S0;
  !!VRi^tum_vendettaMaxDmg_%i^:S0;
!!en;

!?FU(tum_OnAfterAttack);
!#VA(atkStack:x) (defStack:x);

; First part: Deal with the case when Rook/Raven is attacked
!!BG:N?(currStack:y);

; If it is a normal attack, check if the attacked stack has Vendetta
!!if&(currStack)=(atkStack);
  ; Increase the status of Ravens if they are hit
  !!BM(defStack):T?(defType:y) N?(defNum:y);

  !!if&(defType)>(NO_MON)/(defNum)>0;
    !!FU(tum_CheckIfMonVendettaType):P(defType)/?(vendettaType:y);

    !!if&(vendettaType)>0;
      ; Check if Vendetta buff should be renewed (set the duration of Vendetta to 3 turns)
      ; If the stack is a Rook, check if there is any Raven alive on the battlefield (including hostile)
      !!if&(vendettaType)=1;
        !!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
          !!BMi:T?(type:y) N?(num:y);

          !!if&(type)=(MON_RAVEN)/(num)>0;
            !!BM(defStack):M(SPELL_VENDETTA)/3/(SKILL_NOT_LEARNED);

            !!br;
          !!en;
        !!en;

      ; If the stack is a Raven, for sure the buff should be renewed
      !!el&(vendettaType)=2;
        !!BM(defStack):M(SPELL_VENDETTA)/3/(SKILL_NOT_LEARNED);
      !!en;
    !!en;
    
    ; Get the latest duration of Vendetta
    ; Note that for some edge case (Miracle Mage), Vendetta might be put on other creatures than Rook/Raven
    !!BM(defStack):G(SPELL_VENDETTA)/?(duration:y)/?(level:y);

    !!if&(duration)>0;
      ; Increase the atttack and max damage by 1
      !!VRi^tum_vendettaAtk_%(defStack)^:+1;
      !!VRi^tum_vendettaMaxDmg_%(defStack)^:+1;
      !!BM(defStack):Ad1 U2/d1;

      ; Show battle log and play animation/sound
      !!if&i^battle_isVisible^;
        !!VR(isPlural:y):S(defNum) -1 B;
        !!SN:H^monname^/(defType)/(isPlural)/?(monName:z);
        !!SN:T^tumr.str.vendetta%(isPlural)^?(battleLog:z)/^mon^/(monName);
        !!MM:S(battleLog);
        
        !!SN:P^NravenEye^;
        !!FU(tum_PlayCustomAnimationOnStack):P(defStack)/^ravEyeAni^/0;
      !!en;
    !!en;
  !!en;
!!en;

; Second Part: Reduce gained attack when Rook/Raven or other stack got Vendetta additional attack attacks
; No matter whether it is a normal attack or retaliation
!!BM(atkStack):T?(atkType:y) N?(atkNum:y);

!!if&(atkType)>(NO_MON)/(atkNum)>0;
  !!BM(atkStack):G(SPELL_VENDETTA)/?(duration:y)/?(level:y);

  !!if&(duration)>0/i^tum_vendettaAtk_%(atkStack)^>0;
    ; Reduce gained attack
    !!BM(atkStack):A?(atk:y);
    !!VR(atk):-i^tum_vendettaAtk_%(atkStack)^ F0/(INT_MAX);
    !!VRi^tum_vendettaAtk_%(atkStack)^:S0;
    !!BM(atkStack):A(atk);
  !!en;
!!en;

!?FU(tum_CheckIfMonVendettaType);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)&(mon)=(MON_ROOK):S1;
!!VR(result)&(mon)=(MON_RAVEN):S2;


// Swordmaster's Good Morale and Ice Dragon's Move Twice
// Warning: i^battle_round^>=0 is required in every function, otherwise the script will corrupt the timing of artifact casts
// Good Morale
; Always acts a second time if the morale is >=3 (once every 2 turns)
// Move Twice
; Always acts a second time. Possible to stack with Morale to act a third time
!?FU(OnBattleRound)&i^battle_round^>=0;
!!VRi^tum_twice_actingStack^:S(NO_STACK);

!?FU(OnBeforeBattleAction)&i^battle_round^>=0;
!!VRi^tum_twice_actingStack^:S(NO_STACK);

!!FU&i^tum_abilityCounter_%i(tum_twice_actingStack)^>0:E;

; Exit if the action is not correct
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_WALK)/
     (action)<>(BATTLE_ACTION_WALK_AND_ATTACK)/
     (action)<>(BATTLE_ACTION_SHOOT)/
     (action)<>(BATTLE_ACTION_CATAPULT)/
     (action)<>(BATTLE_ACTION_MONSTER_CAST)/
     (action)<>(BATTLE_ACTION_TENT_HEAL):E;

; Exit if the stack is not Swordmaster nor Ice Dragon
!!BMi^battle_acting_stack^:T?(type:y);
!!FU(tum_CheckMonMoveTwiceMode):P(type)/?(mode:y);
!!FU&(mode)=-1:E;

!!BG:N?i^tum_twice_actingStack^;

!?FU(OnBattleActionEnd)&i^battle_round^>=0/i^tum_twice_actingStack^<>(NO_STACK)/i^tum_abilityCounter_%i(tum_twice_actingStack)^=0;
!!VR(stack:y):Si^tum_twice_actingStack^;
!!BM(stack):N?(num:y);

!!FU&(num)<=0:E;

!!BM(stack):T?(type:y);
!!FU(tum_CheckMonMoveTwiceMode):P(type)/?(mode:y);
!!FU&(mode)=0:E;

; Check if the stack has triggered morale
!!BM(stack):F?(flags:y);
!!VR(isActed:y):S(flags) &(MON_FLAG_ACTED);

; Ice Dragons
!!if&(mode)=1;
  ; If the monster has morale activated, it should not be acted OnBattleActionEnd
  !!if&(isActed)=(FALSE);
    !!VRi^tum_twice_actingStack^:S(NO_STACK);
    !!FU:E;
  !!en;
; Special treatment for Swordmaster
!!el&(mode)=2;
  !!FU&(isActed)=(FALSE):E;

  !!BM(stack):G(BMG_FIELD_MORALE)/?(morale:y)/d;

  ; Exit if Swordmaster doesn't have morale +3 or more
  !!if&(morale)<3;
    !!VRi^tum_twice_actingStack^:S(NO_STACK);
    !!FU:E;
  !!el;
    ; "fake" good morale
    ; Note that there is no need to check if a stack is not blind/paralyzed/stoned before activate morale
    !!if&i^battle_isVisible^;
      !!VR(isPlural:y):S(num) -1 B;
      !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
      !!SN:T^tumr.str.goodMorale^/?(battleLog:z)/^mon^/(monName);
      !!MM:S(battleLog);

      !!SN:P^GoodMrle^;
      !!BM(stack):V20;
    !!en;

    !!BM(stack):Fd|(MON_FLAG_MORALE);
  !!en;
!!en;

!!BM(stack):Fd~(MON_FLAG_ACTED);

!?FU(OnBeforeBattleStackTurn)&i^battle_round^>=0/i^tum_twice_actingStack^<>(NO_STACK)/i^tum_abilityCounter_%i(tum_twice_actingStack)^=0;
!#VA(stack:x);

!!BMi^tum_twice_actingStack^:T?(monType:y) N?(monNum:y);
!!FU|(monType)=(NO_MON)/(monNum)<=0:E;

!!FU(tum_CheckMonMoveTwiceMode):P(monType)/?(mode:y);
!!FU&(mode)=0:E;

!!VRi^tum_abilityCounter_%i(tum_twice_actingStack)^:+(mode);
!!VR(stack):Si^tum_twice_actingStack^;

!!VRi^tum_twice_actingStack^:S(NO_STACK);

!?FU(tum_CheckMonMoveTwiceMode);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_ICE_DRAGON):S1;
!!VR(result)&(mon)=(MON_SWORDMASTER):S2;


// Dragonling Evolutions
; Dragonlings' evolution to grown dragons and also the special effects of dragon arrifacts are defined here
!?FU(OnEveryDay);
!!re i/(HERO_FIRST)/(HERO_LAST_WOG);
  !!HEi:O?(owner:y);
  !!co&(owner)<>i^timerOwner^;

  !!re (slot:y)/(ARMY_SLOT_FIRST)/(ARMY_SLOT_LAST);
    !!HEi:C0/(slot)/?(type:y)/?(num:y)/?(exp:y)/2;
    
    !!if&(type)>=(MON_GREEN_DRAGONLING)/(type)<=(MON_AZURE_DRAGONLING)/(num)>0; [Works only for Dragonlings]
      !!VR(equipped1:y):S0;
      !!VR(equipped2:y):S0;

      ; Normal dragon eyes
      !!if&(type)=(MON_GREEN_DRAGONLING);
        !!HEi:A2/(ART_EYE_OF_THE_GREEN_DRAGON)/?(has:y)/?(equipped1);
        !!VR(evoRank:y):S7;
      !!el&(type)=(MON_RED_DRAGONLING);
        !!HEi:A2/(ART_EYE_OF_THE_RED_DRAGON)/?(has)/?(equipped1);
        !!VR(evoRank):S7;
      !!el&(type)=(MON_FAERIE_DRAGONLING);
        !!HEi:A2/(ART_EYE_OF_THE_FAERIE_DRAGON)/?(has)/?(equipped1);
        !!VR(evoRank):S8;
      !!el&(type)=(MON_RUST_DRAGONLING);
        !!HEi:A2/(ART_EYE_OF_THE_RUST_DRAGON)/?(has)/?(equipped1);
        !!VR(evoRank):S9;
      !!el&(type)=(MON_AZURE_DRAGONLING);
        !!HEi:A2/(ART_EYE_OF_THE_AZURE_DRAGON)/?(has)/?(equipped1);
        !!VR(evoRank):S10;
      !!en;

      !!VR(newExp:y):S(exp) +2000;

      !!VR(newExp)&(equipped1):+20000;
      ; Prismatic Eye of the Dragon God (stacking with the other dragon eyes)
      !!HEi:A2/(ART_PRISMATIC_EYE_OF_THE_GOD_DRAGON)/?(has)/?(equipped2);
      !!VR(newExp)&(equipped2):+20000;

      !!SN:E7503648/1/(type)/(newExp);
      !!VR(newRank:y):Sv1;

      ; Evo the dragonling if the new rank equals or is greater than the evolution level
      !!if&(newRank)>=(evoRank);
        !!FU(tum_GetDragonlingUpgrades):P(type)/?(newType:y);
        !!HEi:C0/(slot)/(newType)/(num);
      ; Set up new rank if the new rank is less than evo rank and one of the dragon eye is activated
      !!el;
        !!HEi:C0/(slot)/(type)/(num)/(newExp)/2;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_GetDragonlingUpgrades);
!#VA(mon:x) (newMon:x);

!!VR(newMon):S(NO_MON);

!!if&(mon)=(MON_GREEN_DRAGONLING);
  !!VR(newMon):S(MON_GREEN_DRAGON);
!!el&(mon)=(MON_RED_DRAGONLING);
  !!VR(newMon):S(MON_RED_DRAGON);
!!el&(mon)=(MON_FAERIE_DRAGONLING);
  !!VR(newMon):S(MON_FAERIE_DRAGON);
!!el&(mon)=(MON_RUST_DRAGONLING);
  !!VR(newMon):S(MON_RUST_DRAGON);
!!el&(mon)=(MON_AZURE_DRAGONLING);
  !!VR(newMon):S(MON_AZURE_DRAGON);
!!en;


// Fire Dragon's Inferno Wrath
; Casts Inferno on battle action end
!?FU(OnBattleActionEnd)&i^battle_acting_stack^>(NO_STACK); [it can possibly be -1 for some reason]
; Exit if the action is not correct
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_WALK)/
     (action)<>(BATTLE_ACTION_WALK_AND_ATTACK)/
     (action)<>(BATTLE_ACTION_DEFEND):E;

; Check if the acted stack has Inferno Wrath
!!BMi^battle_acting_stack^:T?(mon:y) N?(num:y);
!!FU(tum_GetMonInfernoWrathDamage):P(mon)/?(damage:y);

!!if&(damage)>0/(num)>0;
  !!VR(stack:y):Si^battle_acting_stack^;
  !!FU(tum_GetStackHeadPosition):P(stack)/?(pos:y);

  !!FU(tum_GetActualStackSide):P(stack)/?i^tum_fireWrathSide^;
  !!VRi^tum_fireWrathStackPlusOne^:S(stack) +1;

  !!FU(tum_CastMonsterDamagingSpell):P(stack)/(SPELL_INFERNO)/(pos)/(damage);

  !!VRi^tum_fireWrathStackPlusOne^:S0;
  !!VRi^tum_fireWrathSide^:S0;
!!en;

; Manage piecing spell immunities
!?FU(OnDwarfMagicResistance)&i^tum_fireWrathStackPlusOne^;
!!MR:S?(spell:y);
!!FU&(spell)<>(SPELL_INFERNO):E;

!!MR:N?(stack:y);
!!VR(fireWrathStack:y):Si^tum_fireWrathStackPlusOne^ -1;
!!BM(stack):I?(side:y);

!!if|(stack)=(fireWrathStack)/(side)=i^tum_fireWrathSide^;
  !!MR&i^tum_%(ART_ORB_OF_VULNERABILITY)_equipped^<>(TRUE):F100;
!!el;
  !!MR:F0;
!!en;

!?FU(tum_GetMonInfernoWrathDamage);
!#VA(mon:x) (result:x);

!!VR(result):S0;
!!VR(result)&(mon)=(MON_FIRE_DRAGON):S200;

****************************************************************************************************
// Custom Fire Shield
; Eventually, I decide to use Amethyst hooks, as it might be slightly better in performance

; This hack requires to disable Fire Shield hooks in Amethyst
*?FU(OnGameEnter);
; Disable Sacred Phoenix Fire Shield so we can recreate it in Efreet Sultan way
*!UN:C7727244/2/5611; 75E88C
*!UN:C7735029/2/5611;

!?FU(tum_CreateERMHook);
!#VA(setHook:x);

!!FU:E;

!!SN:E(setHook)/1/4335068/(tum_OnGetFireShieldDamage); 4225DC
!!SN:E(setHook)/1/4468334/(tum_OnGetFireShieldStrength); 442E6E

!?FU(tum_OnGetFireShieldDamage);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(stackStruct:y);
!!UN:C(stackStruct)/52/4/?(type:y);
!!FU(tum_GetMonFireShieldStrength):P(type)/?(rate:y);
!!FU&(rate)=0:E;

!!IF:M^%(rate)^;

!!SN:X?t/0;
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4335078; 004225E6

!?FU(tum_OnGetFireShieldStrength);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ECX)/4/?(type:y);
!!FU(tum_GetMonFireShieldStrength):P(type)/?(rate:y);
!!FU&(rate)=0:E;

!!VR(rateFloat:e):S(rate) :100;
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/(rateFloat);

!!SN:X?t/0;
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4468340; 442E74

!?FU(tum_GetMonFireShieldStrength);
!#VA(mon:x) (result:x);

!!VR(result):S0;

!!if&(mon)=(MON_EFREETI_RAJAH);
  !!VR(result):S20;
*!el|(mon)=(MON_SACRED_PHOENIX)/(mon)=(MON_DIVINE_PHOENIX);
  *!VR(result):S20;
!!el&(mon)=(MON_FIRE_DRAGON);
  !!VR(result):S40;
!!en;

****************************************************************************************************
// Skeleton Transformer Overhaul
; Skeletons for Undead monsters
; Red Skeleton for any monster with Draining Life or Attract Dead Souls
; Mana Skeleton for monster with level 4+ and with spells (including Monks, Mages, Liches, Psychic Elementals, Enchanters and Sorceresses)
; Skeleton Archer or Skeleton Sharpshooter for monsters with shots (Archers for level 2+, Sharshooters for level 4+)
; Gold Skeleton for monster wiht level 7 (but not a dragon or hydra)
; Bone Dragon/Dracolich for level 7 living Dragons or Hydras (depending on fight value)
!?FU(OnGameEnter);
!!FU(GetMaxMonsterId):P?(lastMon:y);
!!MA:F(MON_DRACOLICH)/?(dracoFightValue:y);

!!re i/(MON_FIRST)/(lastMon);
  ; Everything to Skeletons by default
  !!FU(tum_SetNewSkeletonTransformation):Pi/(MON_SKELETON);

  ; Skip if Undead (Undead will always become Skeletons)
  !!MA:Xi/?(flags:y);
  !!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);

  !!co&(isUndead);

  ; Check if the monster is a level 7 living dragon or hydra
  !!MA:Li/?(level:y);
  !!VR(isLivingDragonOrHydra:y):S(FALSE);
  !!VR(isDragon:y):S(flags) &(MON_FLAG_DRAGON);
  !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);
  !!VR(isHydra:y):S(FALSE);
  !!VR(isHydra)|i=(MON_HYDRA)/i=(MON_CHAOS_HYDRA)/i=(MON_HELL_HYDRA)/i=(MON_NIGHTMARE_HYDRA):S(TRUE);

  !!if&(isAlive);
    !!VR(isLivingDragonOrHydra)|(isDragon)/(isHydra):S(TRUE);
  !!en;

  ; If not a living dragon or hydra
  !!if&(isLivingDragonOrHydra)=(FALSE);

    !!if&(level)<6;
      ; Red Skeleton for any monster with Draining Life or Attract Dead Souls
      !!FU(WOG_44_CheckIfMonDrainsLife):Pi/?(canDrainLife:y);

      !!if&(canDrainLife);
        !!FU(tum_SetNewSkeletonTransformation):Pi/(MON_RED_SKELETON);

        !!co;
      !!en;

      ; Mana Skeleton for monster with level 4+ and with spells (including Monks, Mages, Liches, Psychic Elementals, Enchanters and Sorceresses)
      !!VR(result:y):S(FALSE);
      !!VR(result)&i=(MON_MANA_SKELETON):S(TRUE);
      !!VR(result)|i=(MON_MONK)/i=(MON_ZEALOT)/i=(MON_WAR_ZEALOT)/i=(MON_HIGH_PRIEST):S(TRUE);
      !!VR(result)|i=(MON_MAGE)/i=(MON_ARCHANGEL)/i=(MON_SUPREME_ARCH_MAGE):S(TRUE);
      !!VR(result)|i=(MON_LICH)/i=(MON_POWER_LICH)/i=(MON_LICH_KING):S(TRUE);
      !!VR(result)|i=(MON_PSYCHIC_ELEMENTAL)/i=(MON_MAGIC_ELEMENTAL)/i=(MON_VOID_ELEMENTAL):S(TRUE);
      !!VR(result)|i=(MON_ENCHANTER)/i=(MON_SORCERESS)/i=(MON_SPELLWEAVER):S(TRUE);
      !!VR(result)|i=(MON_CULTIST)/i=(MON_CULTIST_LEADER):S(TRUE);

      !!if&(result)=(FALSE)/(level)>=3;
        !!MA:Bi/?(spells:y);
        !!VR(result)&(spells)>0:S(TRUE);
      !!en;

      !!if&(result);
        !!FU(tum_SetNewSkeletonTransformation):Pi/(MON_MANA_SKELETON);

        !!co;
      !!en;

      ; Skeleton Archer or Skeleton Sharpshooter for monsters with shots (Archers for level 2+, Sharshooters for level 4+)
      !!MA:Ni/?(shots:y);

      !!if&(shots)>0;
        !!if&(level)>=1/(level)<3;
          !!FU(tum_SetNewSkeletonTransformation):Pi/(MON_SKELETON_ARCHER);
        !!el&(level)>=3;
          !!FU(tum_SetNewSkeletonTransformation):Pi/(MON_SHARPSHOOTER_SKELETON);
        !!en;
      !!en;

    ; Gold Skeleton for monster wiht level 7 (but not a dragon nor hydra)
    !!el;
      !!FU(tum_SetNewSkeletonTransformation):Pi/(MON_GOLD_SKELETON);
    !!en;

  ; Bone Dragon/Dracolich for level 7 living Dragons or Hydras (depending on fight value)
  !!el&(level)>=6;
    !!MA:Fi/?(fightValue:y);

    !!if&(fightValue)<(dracoFightValue);
      !!FU(tum_SetNewSkeletonTransformation):Pi/(MON_BONE_DRAGON);
    !!el;
      !!FU(tum_SetNewSkeletonTransformation):Pi/(MON_DRACOLICH);
    !!en;
  !!en;
!!en;

; Fix the conversion of Cavaliers and Unicorns
!!FU(tum_SetNewSkeletonTransformation):P(MON_UNICORN)/(MON_SKELETON) P(MON_CAVALIER)/(MON_SKELETON);

!?FU(tum_SetNewSkeletonTransformation);
!#VA(mon:x) (newMon:x);

!!UN:C5661880/(UNC_INT)/?(address:y);
!!VR(offset:y):S(mon) *(UNC_INT);
!!UN:C(address)/(offset)/(UNC_INT)/(newMon);

!?FU(tum_CheckIfMonCanTransformToManaSkeleton);
!#VA(mon:x) (level:x) (result:x);

!!VR(result):S(FALSE);
!!VR(result)|(mon)=(MON_MONK)/(mon)=(MON_ZEALOT)/(mon)=(MON_WAR_ZEALOT)/(mon)=(MON_HIGH_PRIEST):S(TRUE);
!!VR(result)|(mon)=(MON_MAGE)/(mon)=(MON_ARCHANGEL)/(mon)=(MON_SUPREME_ARCH_MAGE):S(TRUE);
!!VR(result)|(mon)=(MON_LICH)/(mon)=(MON_POWER_LICH)/(mon)=(MON_LICH_KING):S(TRUE);
!!VR(result)|(mon)=(MON_PSYCHIC_ELEMENTAL)/(mon)=(MON_MAGIC_ELEMENTAL)/(mon)=(MON_VOID_ELEMENTAL):S(TRUE);
!!VR(result)|(mon)=(MON_ENCHANTER)/(mon)=(MON_SORCERESS)/(mon)=(MON_SPELLWEAVER):S(TRUE);

****************************************************************************************************
// Manage TUM Object Replacements
!?FU(OnAfterErmInstructions);
; Disable Emissary CBs as they appear to be buggy
!!re i/119/122;
  !!VRi^CB_%i_Replace_Objects^:S(FALSE);
!!en;

; Edited Treehouses script. now use Dens of Thieves for repalcent - Mage Schools does not fit in tiles
; Edited Volcanic Well in txts from 4 tiles to 2 in order to match the passibilities

****************************************************************************************************
// Rebalance the growth of Sacred Phoenix/Divine Phoenix, Light Templars and Light Paladins
; Reduce the growth of Firebird and Phoenix but gives one extra to be recruited if Citadel is built in the town
!?FU(OnAfterErmInstructions);
; Set the growth of phoenix to 1
!!MA:G(MON_FIREBIRD)/1;
!!MA:G(MON_PHOENIX)/1;

!!UN:P189/(FALSE);                      [Disable reduced Firebird/Phoenix amount each week]

; Set up RMB text when checking creature growth from town screen
; This would be executed later than Castle Upgrading (WoG Scripts)
!?FU(tum_Town_GetDwellingGrowth);
!#VA(hook:x);

!!CA0/i^tum_growth_townId^:T?(townType:y);

!!if&(townType)=(TOWN_CONFLUX);
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/8/4/?(creatureSpot:y); [Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/?(baseGrowth:y);]

  !!if|(creatureSpot)=6/(creatureSpot)=13;
    ; Increate 1 if Citadel is built
    !!CA0/i^tum_growth_townId^:B3/8;
    !!UN&1:C(hook)/(STRUCT_HOOK_CONTEXT_ECX)/2/d1;
  !!en;
!!en;

!?FU(tum_Town_GetCreatureGrowthText);
!#VA(hook:x);

!!CM:I?(itemId:y);                      [get dwelling level by clikcing item id]
!!VR(creatureSpot:y):S(itemId:y) -164;
!!VR(creatureSpot)&(creatureSpot)>7: -8;[fix the mouse click on the text]

!!CA(CURRENT_TOWN):T?(townType:y);

!!if&(townType)=(TOWN_CONFLUX)/(creatureSpot)=6;
  !!CA(CURRENT_TOWN):B3/8;              [if Citadel is built]

  !!if&1;
    !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ECX)/4/?(currentTextPtr:y);
    !!SN:B(currentTextPtr:y)/d/?z1;

    ; Fix the growth number of grail if it is the last item of the text
    !!CA(CURRENT_TOWN):B3/26;

    !!if&1;
      !!UN:P45/?(castleUpg:y);

      !!if&(castleUpg);
        !!CA(CURRENT_TOWN):U?(townId:y);
        !!VR(monBonusItemId:y):S(townId) *10 +2 +(MON_MAX_LEVEL);
        !!SN:M(WOG_OPT_CASTLE_UPGRADING)/(monBonusItemId)/?(monNum:y);
        !!FU(tum_FixGrailText)&(monNum)=0:Pz1/1/?z1;
      !!en;
    !!en;

    !!VRz1:+^%T(tumr.str.vaultOfAshes)^;
    !!SN:B6911016/d/z1;     [store it in the text h3 buffer]
    !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ECX)/4/6911016; [redirect ecx to read h3 buffer instead original ptr]
  !!en;
!!en;

!?FU(tum_FixGrailText);
!#VA(text:x) (growth:x) (result:x);

!!VRs^tum_temp^:S^%z(text)^ M4/?(length:y);                 [get string and len]
!!VR(length):-1;
!!FU(NewStrArray):P?(grailIncomeTextArray:y);                  [create revert array to store text from the end to begin]
!!re i/(length)/0/-1;
  !!SN:Ks^tum_temp^/i/?(char:z);
  !!if&(char)<>^+^;                                            [if not "+" then add "number" into array]
    !!FU(Array_Push):P(grailIncomeTextArray)/(char);
  !!el;                                                        [if "+" then stop loop string]
    !!VRi:+1;
    !!br;
  !!en;
!!en;

!!VRs^tum_temp^:M1/s^tum_temp^/0/i;                      [decrease text len]
!!FU(Array_Revert):P(grailIncomeTextArray);                    [reverse inversed array]

!!FU(Array_Join):P(grailIncomeTextArray)/?(grailIncomeText:z); [create word from char array]

!!VR(wrongGrowth:y):V(grailIncomeText);                        [set to int]
!!VR(grailGrowth:y):S(wrongGrowth) -(growth);                  [correct growth]

!!VRs^tum_temp^:+^%(grailGrowth)^;                          [and add to string cut before]
!!VR(result):Zs^tum_temp^;                                  [return result]
!!VRs^tum_temp^:S^^;

****************************************************************************************************
// Rebalance Creatures
; Must be executed later than anything
!?FU(OnEveryDay)&i^timerOnce^/i^timerDay^=1;
; Add new upgrade to Sharpshooters so that they are closer to the strength of Enchanters
!!MA:U(MON_SHARPSHOOTER)/(MON_ARCTIC_SHARPSHOOTER) U(MON_ARCTIC_SHARPSHOOTER)/(MON_LAVA_SHARPSHOOTER) U(MON_LAVA_SHARPSHOOTER)/(MON_ARCTIC_SHARPSHOOTER);
!!MA:O(MON_SHARPSHOOTER)/?(faction:y) O(MON_ARCTIC_SHARPSHOOTER)/(faction) O(MON_LAVA_SHARPSHOOTER)/(faction);
; Add new upgrade to Rust Dragon so they are strengh are like Faerie Dragons
!!MA:U(MON_RUST_DRAGON)/(MON_SULFIDE_DRAGON);
; Convert Miracle Mages and Enchanters
!!MA:U(MON_MIRACLE_MAGE)/(MON_ENCHANTER);

***************************************************************************************
**** New Artifacts * New Artifacts * New Artifacts * New Artifacts * New Artifacts ****
***************************************************************************************

!?FU(OnAfterErmInstructions)&i^tum_emerald_on^;
// New combination artifacts
!!UN:A19/(ART_GARB_OF_THE_FOREST_LORD)/(ART_CENTAUR_AXE)/(ART_SHIELD_OF_THE_DWARVEN_LORDS)/(ART_HELM_OF_THE_ALABASTER_UNICORN)/(ART_BREASTPLATE_OF_PETRIFIED_WOOD);
!!UN:A20/(ART_THIRD_EYE)/(ART_BIRD_OF_PERCEPTION)/(ART_STOIC_WATCHMAN)/(ART_EMBLEM_OF_COGNIZANCE);
!!UN:A21/(ART_ARMOR_OF_THE_ANCIENT_LIZARDMAN)/(ART_GREATER_GNOLLS_FLAIL)/(ART_BUCKLER_OF_THE_GNOLL_KING)/(ART_HELM_OF_CHAOS)/(ART_SCALES_OF_THE_GREATER_BASILISK);
!!UN:A22/(ART_BINOCULARS)/(ART_SPYGLASS)/(ART_SPECULUM)/(ART_PENDANT_OF_SECOND_SIGHT);

// New artifact strings
!!FU(NewStrArray):P?i^tum_artStrList^/(M_STORED);
!!FU(Array_Push):Pi^tum_artStrList^/^%T(tumr.str.triColourScepterUndead)^;

// Artifact Immunities
; Set up artifact immunity arrays before battlefield setting up
!?FU(OnBeforeBattleUniversal)&i^tum_emerald_on^;
!!SN:Mi^tum_artifactImmunity_0^ Mi^tum_artifactImmunity_1^;

!!re i/(BATTLE_LEFT)/(BATTLE_RIGHT);
  !!FU(NewIntArray):P83/?i^tum_artifactImmunity_%i^/(M_TEMP);
  !!co&i^battle_hero_%i^=(NO_HERO);

  !!re (spell:y)/10/82;
    ; Next if the targeted spell is not defined with any artifact
    !!SN:T^tumr.art.immunity.%(spell)^/?(immnueArtStr:z);
    !!co&(immnueArtStr)=^tumr.art.immunity.%(spell)^;

    !!SN:K(immnueArtStr)/?(length:y);
    !!co&(length)=0;

    ; Convert the json contents into array and set up our new array of immunity
    !!FU(tum_ConvertStrToInts):P(immnueArtStr)/?(immuneArtList:y)/?(immunetArtQty:y);

    ; Check if the hero has any of the artifact that immune to the given spell
    !!re (item:y)/0/(immunetArtQty)/1/-1;
      !!SN:M(immuneArtList)/(item)/?(art:y);
      !!HEi^battle_hero_%i^:A2/(art)/?(has:y)/?(equipped:y);

      ; Set the value from the immunity array to TRUE and jump to the next spell
      !!if&(equipped)>0;
        !!SN:Mi^tum_artifactImmunity_%i^/(spell)/(TRUE);
        ; Jump to the next spell (no need to check the rest of the arts)
        !!co 2;
      !!en;
    !!en;
  !!en;
!!en;

; Execute artifact immunity on spell casting
!?FU(OnDwarfMagicResistance)&i^tum_emerald_on^;
!!MR:N?(stack:y);
!!BM(stack):I?(side:y);

; Exit if the targeted stack does not belong to a hero
!!FU&i^battle_hero_%(side)^=(NO_HERO):E;

; Exit if the targeted spell is not defined with any artifact immunity
!!MR:S?(spell:y);
!!SN:Mi^tum_artifactImmunity_%(side)^/(spell)/?(isImmune:y);
!!MR&(isImmune):F100;

!?FU(OnAfterBattleUniversal)&i^tum_emerald_on^;
!!SN:Mi^tum_artifactImmunity_0^ Mi^tum_artifactImmunity_1^;
!!VRi^tum_artifactImmunity_0^:S0;
!!VRi^tum_artifactImmunity_1^:S1;


// Artifact auto spells
; Trigger before the native artifact auto spell casting (must be "before" in order to be compatible with emerald 3
; This is no better than Emerald 3 at the moment as the spell casted by SN:E5898560 doesn't show correct name of artifact. It must be improved
!?FU(tum_OnBeforeArtifactAutoSpells)&i^tum_emerald_on^;
!!FU:E;                                 [Disable for now]

!!VR(side:y):Si^battle_current_side^;
!!VR(hero:y):Si^battle_hero_%i(battle_current_side)^;

!!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(combatManager:y);

!!re i/(ART_SLOT_EQUIPPED_FIRST)/(ART_SLOT_EQUIPPED_LAST);
  !!co&i>=(ART_SLOT_BALLISTA)/i<=(ART_SLOT_SPELL_BOOK);

  ; Next artifact if the targeted artifact is not defined with an auto spell
  !!HE(hero):A1/?(art:y)/i;
  !!SN:T^tumr.art.autoSpell.%(art)^/?(autoSpellArtStr:z);
  !!co&(autoSpellArtStr)=^tumr.art.autoSpell.%(art)^;

  !!SN:K(autoSpellArtStr)/?(length:y);
  !!co&(length)=0;

  ; Check if the hero has artifact that casts on battle start
  !!FU(tum_ConvertStrToInts):P(autoSpellArtStr)/?(autoSpellList:y)/?(autoSpellQty:y);

  !!re (index:y)/0/(autoSpellQty)/1/-1;
    !!SN:M(autoSpellList)/(index)/?(spell:y);

    ; Write how you'd like to cast the spell here
    !!SN:E5898560/(CALLCONV_THISCALL)/(combatManager)/(spell)/0/2/-1/(SKILL_EXPERT)/50;
  !!en;
!!en;


// Artifact auto summon
; Same timing as auto spells
!?FU(tum_OnBeforeArtifactAutoSpells)&i^tum_emerald_on^;
!!VR(side:y):Si^battle_current_side^;

; Get the values from memory and set
!!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(cmbMgr:y);
!!UN:C(cmbMgr)/78528/(UNC_INT)/?(origActiveSide:y) C(cmbMgr)/78528/(UNC_INT)/(side);

!!VR(summonedMonOffset:y):S(side) *(UNC_INT) +78504;
!!UN:C(cmbMgr)/(summonedMonOffset)/(UNC_INT)/?(origSummonedMon:y); [The monster summoned by Summon Elemental spell]

!!SS(SPELL_EARTH_ELEMENTAL):E0/?(origEff:y) E0/1;

; Check if any summuning artifact available
!!BG:H?(hero:y);

; Get level
!!HE(hero):E?(exp:y)/?(level:y)/1;

!!re i/(ART_SLOT_EQUIPPED_FIRST)/(ART_SLOT_EQUIPPED_LAST);
  !!co&i>=(ART_SLOT_BALLISTA)/i<=(ART_SLOT_SPELL_BOOK);

  ; Next artifact if the targeted artifact is not defined with an auto spell
  !!HE(hero):A1/?(art:y)/i;
  !!SN:T^tumr.art.autoSummon.%(art)^/?(autoSpellArtStr:z);
  !!co&(autoSpellArtStr)=^tumr.art.autoSummon.%(art)^;

  !!SN:K(autoSpellArtStr)/?(length:y);
  !!co&(length)=0;

  ; Check if the hero has artifact that auto summons on battle start
  !!FU(tum_ConvertStrToInts):P(autoSpellArtStr)/?(autoSummonList:y)/?(autoSummonQty:y);
  ; Get the level percentage of summoning
  !!FU(Array_Pop):P(autoSummonList)/?(levelPercent:y);
  ; Get the summoning quantity
  !!VR(monQty:y):S(levelPercent) *(level) :100 F1/(INT_MAX);

  !!re (index:y)/0/(autoSummonQty)/1/-2;
    !!SN:M(autoSummonList)/(index)/?(monType:y);
    !!SN:E5927824/(CALLCONV_THISCALL)/(cmbMgr)/(SPELL_EARTH_ELEMENTAL)/(monType)/(monQty)/0;
  !!en;
!!en;

; Restore values to the memory
!!UN:C(cmbMgr)/(summonedMonOffset)/(UNC_INT)/(origSummonedMon);
!!UN:C(cmbMgr)/78528/(UNC_INT)/(origActiveSide);

!!SS(SPELL_EARTH_ELEMENTAL):E0/(origEff:y);


// Artifact upgrades
!?FU(tum_ManageArtifactUpgrades)&i^tum_emerald_on^;
!#VA(mon:x) (hero:x) (newUpg:x);

!!VR(newUpg):S(NO_MON);

; Exit if the targeted monster is not defined with any artifact upgrade
!!SN:T^tumr.art.upgrade.%(mon)^/?(artUpgradeStr:z);
!!FU&(artUpgradeStr)=^tumr.art.upgrade.%(mon)^:E;

!!SN:K(artUpgradeStr)/?(length:y);
!!FU&(length)=0:E;

; Check if the hero has artifact that provides custom upgrades
!!FU(tum_ConvertStrToInts):P(artUpgradeStr)/?(artUpgradeList:y)/?(artUpgradeListSize:y);

!!VR(lastArtUpgradeDefInd:y):S(artUpgradeListSize) :2 -1;

!!re i/0/(lastArtUpgradeDefInd);
  !!VR(upgradeArtInd:y):Si *2;
  !!SN:M(artUpgradeList)/(upgradeArtInd)/?(upgradeArt:y);

  !!HE(hero):A2/(upgradeArt)/?(has:y)/?(equipped:y);

  ; Change the upgrade target if equipped required artifact
  !!if&(equipped)>0;
    !!VR(upgradeMonInd:y):S(upgradeArtInd) +1;
    !!SN:M(artUpgradeList)/(upgradeMonInd)/?(newUpg);
  !!en;
!!en;

**********************************
**** Special Artifact Effects ****
**********************************
// Power of the Dragon Father now ignores the resistance to friendly spells
// Ring of Anti-magic now allows frienldy spells to be casted on Anti-magic spell targets
; Warning: It's reported that this hack doens't work on mass spells???

; Well, this artifacts sucks without some enhancements
!?FU(OnDwarfMagicResistance_Quit);
; Check if it is a friendly spell
!!MR:S?(spell:y);
!!SS(spell):O?(type:y);

!!if&(type)=1;
  ; Check if the stack is owned by a hero
  !!MR:N?(stack:y);

  !!BM(stack):I?(side:y);

  !!if&i^battle_hero_%(side)^>(NO_HERO);
    ; Check if the hero has Power of the Dragon Father
    !!HEi^battle_hero_%(side)^:A2/(ART_POWER_OF_THE_DRAGON_FATHER)/?(has:y)/?(equipped:y);

    !!if&(equipped)>0;
      !!MR:F0;
      !!FU:E;
    !!en;

    ; Check if the hero has Ring of Anti-magic
    !!HEi^battle_hero_%(side)^:A2/(ART_RING_OF_ANTI_MAGIC)/?(has)/?(equipped);

    !!if&(equipped)>0;
      !!BM(stack):G(SPELL_ANTI_MAGIC)/?(duration:y)/?(level:y);

      !!if&(duration)>0;
        !!MR:F0;
        !!FU:E;
      !!en;
    !!en;
  !!en;
!!en;

****************************************************************************************************
// Buckler of the Beelzebub (258), Sun Emperor Chainmail (235) and Bucket Helmet (241)
; Spell given and primary skills are defined in .cfg
; Set up monster flag when the stack stats are initialised
; This works perfectly with random heroes option. If Asmodeus is summoned, the stacks are only granted No Retaliation only if Asmodeus himself has Gloves
; General's order has been moved to the bottom of this script for compatibility
!?FU(tum_BattleStack_InitParams)&i^tum_emerald_on^;
!#VA(stack:x) (side:x);

; Exit if the stack is not leaded by a hero
!!FU&i^battle_hero_%(side)^<=(NO_HERO):E;

; Exit if arrow tower
!!BM(stack):T?(type:y);
!!FU&(type)=(MON_ARROW_TOWERS):E;

; Check if the stack's owner has any listed artifact
!!VR(hero:y):Si^battle_hero_%(side)^;

; No Retaliation
!!HE(hero):A2/(ART_BUCKLER_OF_THE_BEELZEBUB)/?(has:y)/?(equipped:y);
!!BM(stack)&(equipped)>0:Fd|(MON_FLAG_NO_RETALIATION);

; Fire Immunity
!!HE(hero):A2/(ART_SUN_EMPEROR_CHAINMAIL)/?(has)/?(equipped);
!!BM(stack)&(equipped)>0:Fd|(MON_FLAG_FIRE_IMMUNITY);

; No Melee Penalty
!!HE(hero):A2/(ART_BUCKET_HELMET)/?(has)/?(equipped);

!!if&(equipped)>0;
  !!BM(stack):F?(monFlags:y);
  !!VR(isShooter:y):S(monFlags) &(MON_FLAG_SHOOTER);
  !!BM(stack)&(isShooter):Fd|(MON_FLAG_NO_MELEE_PENALTY);
!!en;

; Addional patch - might not be needed if this is fixed: 
; http://wforum.heroes35.net/showthread.php?tid=4218&pid=139027#pid139027
!?FU(OnAfterTacticsPhase);
!!VR(arts[3]:y):C(ART_BUCKLER_OF_THE_BEELZEBUB)/(ART_SUN_EMPEROR_CHAINMAIL)/(ART_BUCKET_HELMET);
!!VR(flags[3]:y):C(MON_FLAG_NO_RETALIATION)/(MON_FLAG_FIRE_IMMUNITY)/(MON_FLAG_NO_MELEE_PENALTY);
!#VA(equipped[3]:y);

!!re (side:y)/(BATTLE_LEFT)/i^battle_hero_vs_hero^;
  !!VR(artCounter:y):S0;

  !!re j/0/(arts[SIZE])/1/-1;
    !!HEi^battle_hero_%(side)^:A2/(arts[j])/?(has:y)/?(equipped[j]);
    !!VR(artCounter)&(equipped[j]):+1;
  !!en;

  ; Skip if all the listed artifacts are not equipped
  !!co&(artCounter)=0;

  !!VR(startStack:y):S(side) *(BATTLE_DEFENDER_STACK_FIRST);
  !!VR(endStack:y):S(startStack) +20;

  !!re (stack:y)/(startStack)/(endStack);
    !!re j/0/(arts[SIZE])/1/-1;
      !!if&(equipped[j]);
        ; Special treatment for No Melee Penalty flag
        !!if&(flags[j])=(MON_FLAG_NO_MELEE_PENALTY);
          !!BM(stack):F?(monFlags:y);
          !!VR(isShooter:y):S(monFlags) &(MON_FLAG_SHOOTER);
          !!BM(stack)&(isShooter):Fd|(MON_FLAG_NO_MELEE_PENALTY);
        !!el;
          !!BM(stack):Fd|(flags[j]);
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

****************************************************************************************************
// Increase the spells of your troops - Mana Crystal (189), Flask of Mana (190) and Vial of Mana (191)
; This script is better than the feature in Emerald as it doesn't count effect from duplicated artifacts, following the native logic
!?FU(tum_BattleStack_InitParams)&i^tum_emerald_on^;
!#VA(stack:x) (side:x);

!!BM(stack):E?(spells:y);

!!if&(spells)>=1/i^battle_hero_%(side)^;
  !!VR(extraSpells:y):S0;

  !!HEi^battle_hero_%(side)^:A2/(ART_MANA_CRYSTAL)/?(has:y)/?(equipped:y);
  !!VR(extraSpells)&(equipped)>0:+1;
  !!HEi^battle_hero_%(side)^:A2/(ART_FLASK_OF_MANA)/?(has:y)/?(equipped:y);
  !!VR(extraSpells)&(equipped)>0:+2;
  !!HEi^battle_hero_%(side)^:A2/(ART_VIAL_OF_MANA)/?(has:y)/?(equipped:y);
  !!VR(extraSpells)&(equipped)>0:+3;

  !!if&(extraSpells)>0;
    !!VR(spells):+(extraSpells);
    !!BM(stack):E(spells);
  !!en;
!!en;

****************************************************************************************************
// Shield of the Dark Paladin (210), Shield of the Light Paladin (254) and Apocalypse Blade (232)
// Cast Armageddon at the start of the battle, repeat the spell once if any stack was elimated by the spell, max for 5 times
!?FU(tum_OnBeforeArtifactAutoSpells);
!!VR(side:y):Si^battle_current_side^;
!!VR(hero:y):Si^battle_hero_%i(battle_current_side)^;

!!FU(tum_ManageHeroPowerOfSide):P(side)/?(power:y);
!!VR(artPower:y):S(power) :5 +25;

; Shield of the Dark Paladin - Death Ripple
!!HE(hero):A2/(ART_SHIELD_OF_THE_DARK_PALADIN)/?(has:y)/?(equipped:y);

!!if&(equipped);
  !!FU(tum_CheckIfPossibleToCastArtSpell):P(SPELL_DEATH_RIPPLE)/(side)/?(result:y);
  !!FU(tum_CastArtifactSpell)&(result):P(ART_SHIELD_OF_THE_DARK_PALADIN)/(side)/(SPELL_DEATH_RIPPLE)/(NO_STACK)/(artPower);
!!en;

; Shield of the Light Paladin - Destroy Undead
!!HE(hero):A2/(ART_SHIELD_OF_THE_LIGHT_PALADIN)/?(has:y)/?(equipped:y);

!!if&(equipped);
  !!FU(tum_CheckIfPossibleToCastArtSpell):P(SPELL_DESTROY_UNDEAD)/(side)/?(result:y);
  !!FU(tum_CastArtifactSpell)&(result):P(ART_SHIELD_OF_THE_LIGHT_PALADIN)/(side)/(SPELL_DESTROY_UNDEAD)/(NO_STACK)/(artPower);
!!en;

; Apocalypse Blade - Armageddon
!!HE(hero):A2/(ART_APOCALYPSE_BLADE)/?(has:y)/?(equipped:y);

!!if&(equipped)>0;
  !!VR(aliveStackQty[15]:y):C0/0/0/0/0/0/0/0/0/0/0/0/0/0/0;

  !!re j/0/14;
    !!FU(tum_CheckIfPossibleToCastArtSpell):P(SPELL_ARMAGEDDON)/(side)/?(result:y);
    !!br&(result)<>(TRUE);

    !!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
      !!BMi:T?(type:y) N?(num:y);

      !!if&(type)>(NO_MON)/(num)>0;
        !!VR(aliveStackQty[j])+1;
      !!en;
    !!en;

    !!if&j=0;
      !!FU(tum_CastArtifactSpell):P(ART_APOCALYPSE_BLADE)/(side)/(SPELL_ARMAGEDDON)/(NO_STACK)/(artPower);
    !!el;
      !!VR(lastRound:y):Sj -1;
      !!FU(tum_CastArtifactSpell)&(aliveStackQty[j])<(aliveStackQty[lastRound])/(aliveStackQty[j])>0:P(ART_APOCALYPSE_BLADE)/(side)/(SPELL_ARMAGEDDON)/(NO_STACK)/(artPower);
    !!en;
  !!en;
!!en;

; Check if commander is dead if enabled
; Disable as we also need a way to deal with henchmen, which is stupid using this way
!!FU:E;

!!UN:P(WOG_OPT_DISABLE_COMMANDERS)/?(commanderOff:y);
!!FU&(commanderOff):E;

!!FU&i^battle_hero_%(side)^=(NO_HERO):E;

!!if&(side)=(BATTLE_LEFT);
  !!VR(pos:y):S88;
!!el;
  !!VR(pos):S98;
!!en;

!!BU:E(pos)/?(stack:y) D(pos)/?(deadStack:y);

!!if&(stack)=(NO_STACK)/(deadStack)>(NO_STACK);
  !!BM(deadStack):T?(type:y);
  !!VR(startMon:y):S(MON_COMMANDER_FIRST_A);
  !!VR(endMon:y):S(MON_COMMANDER_LAST_A);

  !!if&(side)=(BATTLE_RIGHT);
    !!VR(startMon):+9;
    !!VR(endMon):+9;
  !!en;

  !!if&(type)>=(startMon)/(type)<=(endMon);
    !!COi^battle_hero_%(side)^:D(TRUE);
  !!en;
!!en;

****************************************************************************************************
// Diplomat's Cloak (180)
// Re-enable Surrender and Retreat feature in siege (as defender)
// Allows your hero to retreat or surrender when battling neutral monsters - this is not yet implemented
// AI behaviour (to retreat with Diplomat's Cloak in siege) - not yet implemented
!?FU(tum_OnAfterSetRetreatSurrenderButtons);
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_ESI)/4/?(esi:y);
!!UN:C(esi)/78528/4/?(activeSide:y);

!!VR(side:y):S-1;

; For left side - allow retreat, surrender when battle against neutral creatures
; Disable for now. The logic is complicated to code :(
!!if&(activeSide)=(BATTLE_LEFT);
  !!if|i^wog_72_randHeroActive^;/i^battle_hero_1^<=(NO_HERO); [works on random heroes]
    !!VR(side):S(BATTLE_LEFT);
  !!en;
; For right side - allow retreat, surrender in siege battle
!!el&i^battle_hero_1^>(NO_HERO);
  !!UN:C(esi)/21448/4/?(townStruct:y);
  !!VR(side)&(townStruct):S(BATTLE_RIGHT);
!!en;

!!if&(side)>-1;
  !!HEi^battle_hero_%(side)^:A2/(ART_DIPLOMATS_CLOAK)/?(has:y)/?(equipped:y);

  !!if&(equipped)>0;
    !!FU(H3Dlg_GetCurrentDlg):P?(currDlg:y);
    !!FU(H3Dlg_SendCmdToItem):P(currDlg)/2001/6/4096 P(currDlg)/2002/6/4096;
  !!en;
!!en;

*?FU(OnBattleScreenMouseClick)&i^mouse_item^=2001/i^battle_hero_1^<=(NO_HERO)/999/i^mouse_action^=(MOUSE_LMB_RELEASED);
*!CM:R0;

****************************************************************************************************
// Ring of Negativity (201)
// 5% chance to stun the target (skip their turn and lose the chance to retaliate) when casting a Lightning Bolt or Chain Lightning. Max one target to be stunned per cast.
; Set up variable if Ring of Negativeity is equipped
!?FU(OnBeforeBattleAction)&i^tum_emerald_on^;
!!BG:H?(hero:y);

!!if&(hero)>(NO_HERO);
  !!BG:A?(action:y);

  !!if&(action)=(BATTLE_ACTION_HERO_CAST);
    !!BG:S?(spell:y);

    !!if|(spell)=(SPELL_LIGHTNING_BOLT)/(spell)=(SPELL_CHAIN_LIGHTNING);
      !!HE(hero):A2/(ART_RING_OF_NEGATIVITY)/?(has:y)/?(equipped:y);
      !!VRi^tum_%(ART_RING_OF_NEGATIVITY)_equipped^&(equipped)>0:S(TRUE);
    !!en;
  !!en;
!!en;

; Stun the target if lucky enough
!?FU(OnMagicBasicResistance)&i^tum_%(ART_RING_OF_NEGATIVITY)_equipped^;
!!MR:S?(spell:y);

!!if|(spell)=(SPELL_LIGHTNING_BOLT)/(spell)=(SPELL_CHAIN_LIGHTNING);
  !!MR:N?(targetStack:y);
  !!BM(targetStack):I?(side:y);

  !!if&(side)<>i^battle_acting_side^;
    !!BM(targetStack):F?(flags:y) R?(retals:y);
    !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);
    !!VR(isActed:y):S(flags) &(MON_FLAG_ACTED);

    !!if&(isAlive);
      !!if|(isActed)=(FALSE)/(retals)>0;
        !!VR(random:y):R0/0/99;

        !!if&(spell)=(SPELL_LIGHTNING_BOLT);
          !!VR(chance:y):S10;
        !!el&(spell)=(SPELL_CHAIN_LIGHTNING);
          !!VR(chance):S5;
        !!en;

        !!if&(random)<(chance);
          !!BM(targetStack):Fd|(MON_FLAG_ACTED) R0;
          !!VRi^tum_%(ART_RING_OF_NEGATIVITY)_equipped^:S(FALSE);
          ; Set up variable for battle log
          !!VRi^tum_%(ART_RING_OF_NEGATIVITY)_stunnedStackPlusOne^&i^battle_isVisible^:S(targetStack) +1;
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(OnBattleActionEnd);
; Reset variable
!!VRi^tum_%(ART_RING_OF_NEGATIVITY)_equipped^:S(FALSE);

; Manage battle log
; i^tum_%(ART_RING_OF_NEGATIVITY)_stunnedStackPlusOne^ has value only when i^battle_isVisible^ is TRUE
!!if&i^tum_%(ART_RING_OF_NEGATIVITY)_stunnedStackPlusOne^;
  !!VR(stack:y):Si^tum_%(ART_RING_OF_NEGATIVITY)_stunnedStackPlusOne^ -1;
  !!VRi^tum_%(ART_RING_OF_NEGATIVITY)_stunnedStackPlusOne^:S0;

  !!BM(stack):T?(type:y) N?(num:y);

  !!if&(num)>0;
    !!VR(isPlural:y):S(num) -1 B;
    !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
    !!SN:T^tumr.str.stun%(isPlural)^/?(battleLog:z)/^mon^/(monName);
    !!MM:S(battleLog);

    !!SN:P^SPELLSTUN^;
    !!FU(tum_PlayCustomAnimationOnStack):P(stack)/^Stun^;
  !!en;
!!en;

****************************************************************************************************
// Sacred War Hammer (224)
// 20% increase on damage if attacking Undead
// Remove Undead dead body if completely killed
!?FU(OnStackToStackDamage_Quit)&i^tum_emerald_on^;
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!BM(defStack):F?(monFlags:y);
!!VR(isUndead:y):S(monFlags) &(MON_FLAG_UNDEAD);

!!if&(isUndead);
  !!FU(tum_GetActualStackSide):P(atkStack)/?(side:y);

  !!if&i^battle_hero_%(side)^>(NO_HERO);
    !!HEi^battle_hero_%(side)^:A2/(ART_SACRED_WAR_HAMMER)/?(has:y)/?(equipped:y);

    !!if&(equipped)>0;
      !!VR(finalDmgNew:y):S(finalDmgConst) *6 :5 -(finalDmgConst) +(finalDmg);

      !!if&(finalDmgNew)>(finalDmg);
        !!VR(finalDmg):S(finalDmgNew);

        !!if&(isTheoretical);
          !!SN&i^battle_isVisible^:T^tumr.str.sacredWarHammer0^/?s^tum_extraBattleArtMouseHint^;
        !!el;
          !!VRi^sacredWarHammerAtkStack^:S(atkStack);
          !!VRi^sacredWarHammerDefStack^:S(defStack);
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_OnBattleStackKilled)&i^tum_emerald_on^/i^sacredWarHammerDefStack^=x1;
!#VA(stackId:x) (side:x);

!!if|i^sacredWarHammerAtkStack^/i^sacredWarHammerDefStack^;
  !!FU(tum_GetActualStackSide):Pi^sacredWarHammerAtkStack^/?(actSide:y);

  !!if&i^battle_hero_%(actSide)^>(NO_HERO);
    !!HEi^battle_hero_%(actSide)^:A2/(ART_SACRED_WAR_HAMMER)/?(has:y)/?(equipped:y);

    !!if&(equipped)>0;
      !!BM(stackId):F?(monFlags:y);
      !!VR(isUndead:y):S(monFlags) &(MON_FLAG_UNDEAD);

      !!if&(isUndead);
        !!BM(stackId):E0 Fd|(MON_FLAG_SACRIFICED);

        !!if&i^battle_isVisible^;
          !!BM(stackId):N?(num:y) T?(type:y);
          !!VR(isPlural:y):S(num) -1 B;
          !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
          !!SN:T^tumr.str.sacredWarHammer1^/?(battleLog:z)/^mon^/(monName);
          !!MM:S(battleLog);
        !!en;
      !!en;
    !!en;
  !!en;

  ; Restore variables
  !!VRi^sacredWarHammerAtkStack^:S0;
  !!VRi^sacredWarHammerDefStack^:S0;
!!en;

!?FU(OnSetupBattlefield);
!!VRi^sacredWarHammerAtkStack^:S0;
!!VRi^sacredWarHammerDefStack^:S0;

!?FU(OnBattleActionEnd);
!!VRi^sacredWarHammerAtkStack^:S0;
!!VRi^sacredWarHammerDefStack^:S0;

****************************************************************************************************
// Shield of the Ancients (226)
// 10% spell damage boost every turn (for both players)
!?FU(OnBattleRound)&i^battle_round^>=0/i^battle_isVisible^/i^tum_%(ART_SHIELD_OF_THE_ANCIENTS)_equipped^;
!!VR(counter:y):Si^battle_round^ +1;
!!VR(bonus:y):S(counter) *10;

!!SN:T^tumr.str.shieldOfTheAncients^/?(msg:z)/^bonus^/(bonus);
!!MM:S(msg);

!!SN:P^spell-auraofpower^;

; Memory hack to skip damage
!!UN:C5918491/4/?(patch1:y) C5918491/4/56809;
!!UN:C5918495/4/?(patch2:y) C5918495/4/2425393152;
!!UN:C5918499/1/?(patch3:y) C5918499/1/(OPCODE_NOP_1);
; Set up new animation
!!SN:B6837112/d/^SP_AURA.def^;

; Cast Armageddon (but with only animation)
!!UN:C(COMBAT_MANAGER)/4/?(cmbMgr:y);
!!UN:C(cmbMgr)/78572/(UNC_INT)/-1;
!!SN:E5918416/(CALLCONV_THISCALL)/(cmbMgr)/0/1;
!!UN:C(cmbMgr)/78572/(UNC_INT)/-1;

; Restore damage lines
!!UN:C5918491/4/(patch1);
!!UN:C5918495/4/(patch2);
!!UN:C5918499/1/(patch3);
; Restore animation
!!SN:B6837112/d/^C06SPF0.def^;

; Update the screen
*!SN:D;                                 [Silently crash, don't use it]

; Might be considered native implementation
!?FU(OnMagicBasicResistance)&i^battle_round^>=0/i^tum_%(ART_SHIELD_OF_THE_ANCIENTS)_equipped^;
!!MR:D?(basicDmg:y);
!!VR(counter:y):Si^battle_round^ +1;

!!VR(newDmg:y):S(basicDmg) :10 *(counter) +(basicDmg);
!!MR&(newDmg)>(basicDmg):D(newDmg);

; Alternative approach
*?FU(OnMagicCorrectedResistance)&i^battle_round^>=0/i^tum_%(ART_SHIELD_OF_THE_ANCIENTS)_equipped^;
*!MR:D?(basicDmg:y) F?(fixedDmg:y);
*!VR(counter:y):Si^battle_round^ +1;

*!VR(newDmg:y):S(basicDmg) :10 *(counter) +(fixedDmg);
*!MR&(newDmg)>(fixedDmg):F(newDmg);

****************************************************************************************************
// Sun Emperor Chainmail (235)
// Generate fire walls at the positions of stacks damaged by fire school spells
; If the hero casted a fire damaging spell, set up the array for spell ID and damaged stack ID
!?FU(OnBeforeBattleAction)&i^tum_emerald_on^;
!!BG:A?(action:y);

!!if&(action)=(BATTLE_ACTION_HERO_CAST);
  !!BG:S?(spell:y);
  !!SS(spell):S?(school:y);
  !!VR(isFireSpell:y):S(school) &2;

  !!if&(isFireSpell);
    !!SS(spell):F?(flags:y);
    !!VR(isDmgSpell:y):S(flags) &512;

    !!if&(isDmgSpell);
      !!HEi^battle_hero_%i(battle_acting_side)^:A2/(ART_CROWN_OF_THE_FIRE_KING)/?(has:y)/?(equipped:y);

      !!if&(equipped);
        !!FU(NewIntArray):P?i^tum_%(ART_CROWN_OF_THE_FIRE_KING)_list^/(M_TEMP);
        !!FU(Array_Push):Pi^tum_%(ART_CROWN_OF_THE_FIRE_KING)_list^/(spell); [0 slot is for casted spell]
      !!en;
    !!en;
  !!en;
!!en;

; Push the stack to the array if spell is the same as the casted fire spell
!?FU(OnMagicBasicResistance)&i^tum_%(ART_CROWN_OF_THE_FIRE_KING)_list^;
!!MR:S?(spell:y);
!!SN:Mi^tum_%(ART_CROWN_OF_THE_FIRE_KING)_list^/0/?(castedSpell:y);

!!if&(spell)=(castedSpell);
  !!MR:N?(stack:y);
  !!FU(Array_Push):Pi^tum_%(ART_CROWN_OF_THE_FIRE_KING)_list^/(stack);
!!en;

; Loop through all the damaged stacks and place fire walls
!?FU(OnBattleActionEnd)&i^tum_%(ART_CROWN_OF_THE_FIRE_KING)_list^;
; Get the hero's expertise
!!HEi^battle_hero_%i(battle_acting_side)^:Z?(heroStruct:y);
!!SN:E5133040/(CALLCONV_THISCALL)/(heroStruct)/(SPELL_FIRE_WALL)/0;
!!VR(level:y):Sv1;                      [spell level]

; Get the hero's power
!!FU(tum_ManageHeroPowerOfSide):Pi^battle_acting_side^/?(power:y);

!!VR(fireWallPlaced:y):S(FALSE); [flag for battle log]
; Loop through all the stack damaged with fire spell and cast fire wall on them
!!SN:Mi^tum_%(ART_CROWN_OF_THE_FIRE_KING)_list^/?(size:y);

!!re i/1/(size)/1/-1;
  !!SN:Mi^tum_%(ART_CROWN_OF_THE_FIRE_KING)_list^/i/?(stack:y);

  ; Check if the target is alive and can receive fire wall
  !!BM(stack):N?(num:y);

  !!if&(num)>0;
    !!FU(tum_Battle_CanStackReceiveSpell):P(stack)/(SPELL_FIRE_WALL)/i^battle_acting_side^/?(result:y);

    !!if&(result);
      !!BM(stack):P?(pos:y);
      !!BU:O(pos)/?(obstacle:y);
      !!FU(tum_PlaceMagicObstacle)&(obstacle)=0:P(SPELL_FIRE_WALL)/(pos)/(level)/(power);
      !!VR(fireWallPlaced):S(TRUE);
    !!en;
  !!en;
!!en;

!!if&i^battle_isVisible^/(fireWallPlaced);
  !!SN:T^tumr.str.crownOfTheFireKing^/?(battleLog:z);
  !!MM:S(battleLog);
!!en;

!!SN:Mi^tum_%(ART_CROWN_OF_THE_FIRE_KING)_list^;
!!VRi^tum_%(ART_CROWN_OF_THE_FIRE_KING)_list^:S0;

****************************************************************************************************
// Regenarative Necklace of Mana
; Regenerate 6% of mana every day. The percentage is increased by 3% for every level of Mysticism and specialty
!?FU(OnEveryDay)&i^timerOnce^/i^timerDay^>1/i^tum_emerald_on^;
!!re i/(HERO_FIRST)/(HERO_LAST_WOG);
  !!HEi:A2/(ART_REGENERATIVE_NECKLACE_OF_MANA)/?(has:y)/?(equipped:y);

  !!if&(equipped);
    !!HEi:I?(currMana:y)/1;
    !!FU(tum_Hero_GetFullSpellPoints):Pi/?(maxMana:y);
    
    ; If not full mana, calculate how much mana should be regenerated
    !!if&(currMana)<(maxMana);
      !!FU(tum_GetRegenarativeNecklaceOfManaRegen):Pi/?(totalRegenMana:y);
      !!VR(newMana:y):S(currMana) +(totalRegenMana) F(currMana)/(maxMana);

      !!if&i=(HERO_DEEMER);
        !!IF:M^%(currMana) %(totalRegenMana) %(newMana) here^;
      !!en;

      ; Set up new mana
      !!HEi:I(newMana)/1;
    !!en;
  !!en;
!!en;

!?FU(tum_GetRegenarativeNecklaceOfManaRegen);
!#VA(hero:x) (result:x);

!!FU(tum_Hero_GetFullSpellPoints):P(hero)/?(maxMana:y);

; Calcultate one share of mana
!!VR(regenMana:y):S(maxMana) *3 :100;
!!VR(counter:y):S2;
; Check specialty
!!HE(hero):X?(type:y)/?(subtype:y);
!!VR(counter)&(type)=0/(subtype)=(SKILL_MYSTICISM):+1;
; Check sec skill
!!HE(hero):S(SKILL_MYSTICISM)/?(level:y);
!!VR(counter):+(level);

!!if&(level)=(SKILL_EXPERT)/i^Advanced_Classes_Mod_Active^/i^H3_Mysticism_0_Hero%(hero)^;
  !!VR(counter):+1;
  !!VR(counter)&i^H3_Mysticism_1_Hero%(hero)^:+1;
!!en;

; Calculate new mana
!!VR(result):S(regenMana) *(counter);

****************************************************************************************************
// Field Martial's Ring (242)
// 20% increase on damage if the creature has gained morale in a turn
!?FU(OnStackToStackDamage_Quit)&i^tum_emerald_on^;
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

!!BM(atkStack):F?(monFlags:y);
!!VR(isMorale:y):S(monFlags) &(MON_FLAG_MORALE);

!!if&(isMorale);
  !!FU(tum_GetActualStackSide):P(atkStack)/?(side:y);

  !!if&i^battle_hero_%(side)^>(NO_HERO);
    !!HEi^battle_hero_%(side)^:A2/(ART_FIELD_MARTIALS_RING)/?(has:y)/?(equipped:y);

    !!if&(equipped)>0;
      !!VR(finalDmgNew:y):S(finalDmgConst) *6 :5 -(finalDmgConst) +(finalDmg);

      !!if&(finalDmgNew)>(finalDmg);
        !!VR(finalDmg):S(finalDmgNew);

        !!if&i^battle_isVisible^/(isTheoretical);
          !!SN:T^tumr.str.fieldMartialsRing^/?s^tum_extraBattleArtMouseHint^;
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

****************************************************************************************************
// Hourseshoe (243)
// x% chance to retaliate twice 

****************************************************************************************************
// Ring of the Snake Eyesight (253) 
; Casts Hypnotize on the enemy's unit with the least total HP
!?FU(tum_OnBeforeArtifactAutoSpells);
!!VR(side:y):Si^battle_current_side^;
!!VR(hero:y):Si^battle_hero_%i(battle_current_side)^;

!!HE(hero):A2/(ART_RING_OF_THE_SNAKE_EYESIGHT)/?(has:y)/?(equipped:y);

!!if&(equipped);
  !!VR(oppSide:y):S(side) X(TRUE);

  !!FU(NewIntArray):P?(validStacks:y) P?(totalHpList:y);
  !!VR(startInd:y):S(oppSide) *(BATTLE_STACKS_PER_SIDE);
  !!VR(endInd:y):S(startInd) +20;

  !!re i/(startInd)/(endInd);
    !!BMi:T?(type:y) N?(num:y);

    !!if&(type)>(NO_MON)/(num)>0;
      ; Check if the stack can be Hypnotized with max possible power
      !!FU(tum_CheckIfStackCanBeHypnotized):Pi/(side)/?(acceptSpell:y);

      !!if&(acceptSpell);
        ; Check if the stack is hypnotized
        !!BMi:G(SPELL_HYPNOTIZE)/?(duration:y)/?(level:y);

        !!if&(duration)<=0;
          ; Set up arrays for total HP and stack ID
          !!BMi:H?(hp:y) L?(lostHp:y);
          !!VR(totalHp:y):S(hp) *(num) -(lostHp);

          !!FU(Array_Push)&(totalHp)>0:P(totalHpList)/(totalHp) P(validStacks)/i;
        !!en;
      !!en;
    !!en;
  !!en;

  !!SN:M(totalHpList)/?(size:y);

  !!if&(size)>0;
    ; Get the stack with minimun total HP
    !!VR(minTotalHp:y):S(INT_MAX);
    !!VR(minTotalHpInd:y):S0;

    !!re i/0/(size)/1/-1;
      !!SN:M(totalHpList)/i/?(totalHp);

      !!if&(totalHp)<(minTotalHp);
        !!VR(minTotalHp):S(totalHp);
        !!VR(minTotalHpInd):Si;
      !!en;
    !!en;

    !!SN:M(validStacks)/(minTotalHpInd)/?(targetStack:y);

    ; Cast the spell
    !!FU(tum_CastArtifactSpell):P(ART_RING_OF_THE_SNAKE_EYESIGHT)/(side)/(SPELL_HYPNOTIZE)/(targetStack)/5;
  !!en;
!!en;

****************************************************************************************************
// Ring of Anti-magic (256)
; Casts Anti-magic on a friendly unit with the greatest total HP
; Any stack with Anti-magic can receive frienldy spells
!?FU(tum_OnBeforeArtifactAutoSpells);
!!VR(side:y):Si^battle_current_side^;
!!VR(hero:y):Si^battle_hero_%i(battle_current_side)^;

!!HE(hero):A2/(ART_RING_OF_ANTI_MAGIC)/?(has:y)/?(equipped:y);

!!if&(equipped);
  !!FU(NewIntArray):P?(validStacks:y) P?(totalHpList:y);
  !!VR(startInd:y):S(side) *(BATTLE_STACKS_PER_SIDE);
  !!VR(endInd:y):S(startInd) +20;

  !!re i/(startInd)/(endInd);
    !!BMi:T?(type:y) N?(num:y);

    !!if&(type)>(NO_MON)/(num)>0;
      ; Check if the stack can be buffed with Anti-magic
      !!FU(tum_Battle_CanStackReceiveSpell):Pi/(SPELL_ANTI_MAGIC)/(side)/?(canReceive:y);

      !!if&(canReceive);
        ; Check if the stack has Anti-Magic
        !!BMi:G(SPELL_ANTI_MAGIC)/?(duration:y)/?(level:y);

        !!if&(duration)<=0;
          ; Set up arrays for total HP and stack ID
          !!BMi:H?(hp:y) L?(lostHp:y);
          !!VR(totalHp:y):S(hp) *(num) -(lostHp);

          !!FU(Array_Push)&(totalHp)>0:P(totalHpList)/(totalHp) P(validStacks)/i;
        !!en;
      !!en;
    !!en;
  !!en;

  !!SN:M(totalHpList)/?(size:y);

  !!if&(size)>0;
    ; Get the stack with maximum total HP
    !!VR(maxTotalHp:y):S0;
    !!VR(maxTotalHpInd:y):S0;

    !!re i/0/(size)/1/-1;
      !!SN:M(totalHpList)/i/?(totalHp);

      !!if&(totalHp)>(maxTotalHp);
        !!VR(maxTotalHp):S(totalHp);
        !!VR(maxTotalHpInd):Si;
      !!en;
    !!en;

    !!SN:M(validStacks)/(maxTotalHpInd)/?(targetStack:y);

    ; Cast the spell
    !!FU(tum_CastArtifactSpell):P(ART_RING_OF_ANTI_MAGIC)/(side)/(SPELL_ANTI_MAGIC)/(targetStack)/50;
  !!en;
!!en;

; Allow friendly spell to be casted no stack with Anti-Magic
!?FU(tum_OnCheckStackReceiveSpell);
!#VA(hook:x);

; Check if it is a friendly spell
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/(UNC_INT)/?(ebp:y);
!!UN:C(ebp)/8/(UNC_INT)/?(spell:y);
!!SS(spell):O?(spellType:y);

!!if&(spellType)=1;
  ; Check if the target's owner has the Ring of Anti-Magic
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EDI)/(UNC_INT)/?(edi:y);
  !!UN:C(edi)/244/(UNC_INT)/?(side:y);

  !!if&i^battle_hero_%(side)^>(NO_HERO);
    !!HEi^battle_hero_%(side)^:A2/(ART_RING_OF_ANTI_MAGIC)/?(has:y)/?(equipped:y);

    ; If he/she has the ring, skip the whole thing about Anti-Magic returning 0
    !!if&(equipped)>0;
      !!SN:X?t/0;
      !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/(UNC_INT)/5932413;
    !!en;
  !!en;
!!en;

****************************************************************************************************
// Magic Cloak (261)
// Allows you to cast Frenzy and Teleport on the enemy's troops
; There seem to be no need to worry about the acceptance from stack exp. The immunity from hostile friendly spell works correctly
!?FU(OnBeforeBattleUniversal)&i^tum_emerald_on^;
!!FU(tum_ManageMagicCloakSpellTargetType):P0;

!?FU(OnBattleStackObtainsTurn)&i^tum_emerald_on^;
!#VA(stackSide:x) (stackInd:x);

!!VR(mode:y):S0;

!!if&i^battle_hero_%(stackSide)^;
  !!HEi^battle_hero_%(stackSide)^:A2/(ART_MAGIC_CLOAK)/?(has:y)/?(equipped:y);
  !!VR(mode)&(equipped)>0:S1;
!!en;

!!FU(tum_ManageMagicCloakSpellTargetType):P(mode);

!?FU(tum_ManageMagicCloakSpellTargetType)&i^tum_emerald_on^;
!#VA(mode:x);                           [0 for restore, 1 for set]

!!if&(mode)=0;
  !!SS(SPELL_ANTI_MAGIC):O1;
  !!SS(SPELL_FRENZY):O1;
  !!SS(SPELL_TELEPORT):O1;
  !!SS(SPELL_CLONE):O1;
!!el;
  !!SS(SPELL_ANTI_MAGIC):O0;
  !!SS(SPELL_FRENZY):O0;
  !!SS(SPELL_TELEPORT):O0;
  !!SS(SPELL_CLONE):O0;
!!en;

!?FU(OnAfterBattleUniversal)&i^tum_emerald_on^;
!!FU(tum_ManageMagicCloakSpellTargetType):P0;

****************************************************************************************************
// Atma Sword (264) and Atma Robe (265)
// Atma Sword ensures the first melee attack of your troops kills 10% of the attacked stack every round
// Atma Robe reduces 75% of damage for the first damaging spell casted on your creature every round
!?FU(OnSetupBattlefield)&i^tum_emerald_on^;
!!VRi^tum_%(ART_ATMA_SWORD)_equipped_0^:S(FALSE);
!!VRi^tum_%(ART_ATMA_SWORD)_equipped_1^:S(FALSE);
!!VRi^tum_%(ART_ATMA_ROBE)_equipped_0^:S(FALSE);
!!VRi^tum_%(ART_ATMA_ROBE)_equipped_1^:S(FALSE);

!!re i/(BATTLE_LEFT)/i^battle_hero_vs_hero^;
  !!HEi^battle_hero_%i^:A2/(ART_ATMA_SWORD)/?(has:y)/?(equipped:y);
  !!VRi^tum_%(ART_ATMA_SWORD)_equipped_%i^&(equipped):S(TRUE);

  !!HEi^battle_hero_%i^:A2/(ART_ATMA_ROBE)/?(has:y)/?(equipped:y);
  !!VRi^tum_%(ART_ATMA_ROBE)_equipped_%i^&(equipped):S(TRUE);
!!en;

; Reset Atma counter to 0 at the start of battle
; Important for battle replay
!!VRi^tum_%(ART_ATMA_SWORD)_counter_0^:S0;
!!VRi^tum_%(ART_ATMA_SWORD)_counter_1^:S0;
!!VRi^tum_%(ART_ATMA_ROBE)_counter_0^:S0;
!!VRi^tum_%(ART_ATMA_ROBE)_counter_1^:S0;

// Set up Atma counter
; Reduce Atma counter by 1 every other round
!?FU(OnBattleRound)&i^battle_round^>0/i^tum_emerald_on^;
!!VRi^tum_%(ART_ATMA_SWORD)_counter_0^:-1 F0/(INT_MAX);
!!VRi^tum_%(ART_ATMA_SWORD)_counter_1^:-1 F0/(INT_MAX);
!!VRi^tum_%(ART_ATMA_ROBE)_counter_0^:-1 F0/(INT_MAX);
!!VRi^tum_%(ART_ATMA_ROBE)_counter_1^:-1 F0/(INT_MAX);

// Atma Sword
!?FU(OnStackToStackDamage_Quit)&i^tum_emerald_on^;
!#VA(atkStack:x) (defStack:x) (finalDmgConst:x) (finalDmg:x) (basicDmg:x) (dmgBonus:x) (isDistant:x) (distanceArg:x) (isTheoretical:x);

; Exit if distant
!!FU&(isDistant):E;

!!FU(tum_GetActualStackSide):P(atkStack)/?(actSide:y);
!!FU&i^tum_%(ART_ATMA_SWORD)_equipped_%(actSide)^<=0:E;
!!FU&i^tum_%(ART_ATMA_SWORD)_counter_%(actSide)^>0:E;

!!FU&(atkStack)<>i^battle_current_stack^:E;
!!FU&(finalDmg)<=0:E;                   [final damge > 0 only (not blocked by my blocking scripts). Atma Sword attack can be blocked]

!!BM(defStack):N?(defNum:y) H?(hp:y) L?(lostHp:y);
!!VR(totlaHp:y):S(hp) *(defNum) -(lostHp);

; Check if Atma Sword's damage is greater than the full HP of one creature
!!VR(atmaDmg:y):S(totlaHp) *3 :20;      [15%]

!!if&(atmaDmg)>(hp)/(finalDmg)<(atmaDmg);
  !!if&(isTheoretical);
    !!if&i^battle_isVisible^;
      !!VR(bonusDmg:y):S(atmaDmg) -(finalDmg);
      !!SN:T^tumr.str.atmaSwordHint^/?s^tum_extraBattleArtMouseHint^/^bonusDmg^/(bonusDmg);
    !!en;
  !!el;
    !!VRi^tum_%(ART_ATMA_SWORD)_counter_%i(battle_acting_side)^:+1; [Cooldown: 1 turn]

    !!if&i^battle_isVisible^;
      !!BMi^battle_acting_stack^:N?(atkNum:y) T?(atkMon:y);
      !!VR(isPlural:y):S(atkNum) -1 B;
      !!SN:H^monname^/(atkMon)/(isPlural)/?(atkMonName:z);
      !!BM(defStack):T?(defMon:y);
      !!VR(isPlural):S(defNum) -1 B;
      !!SN:H^monname^/(defMon)/(isPlural)/?(defMonName:z);
      !!SN:T^tumr.str.atmaSword^/?(battleLog:z)/^atkMon^/(atkMonName)/^defMon^/(defMonName)/^rate^/15;
      !!MM:S(battleLog);
    !!en;
  !!en;

  !!VR(finalDmg):S(atmaDmg);
!!en;

// Atma Robe
; Trigger of real spell damage calculation - this is needed as we don't want to affect the theoretical damage in MR1
; why though? Because theoretical triggering affects counter?
!?FU(tum_OnAfterCalcSpellDamage)&i^battle_round^>=0;
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EDI)/4/?(stackStruct:y);
!!UN:C(stackStruct)/244/4/?(side:y) C(stackStruct)/248/4/?(stackOfSide:y);
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/?(fixedDmg:y) C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(spell:y);
!!VR(stack:y):S(side) *(BATTLE_STACKS_PER_SIDE) +(stackOfSide); 

!!if&i^tum_%(ART_ATMA_ROBE)_counter_%(side)^=0/i^tum_%(ART_ATMA_ROBE)_equipped_%(side)^;
  !!VR(newfixedDmg:y):S(fixedDmg) :2;

  !!if&(newfixedDmg)<(fixedDmg);
    !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/(newfixedDmg);

    !!VRi^tum_%(ART_ATMA_ROBE)_counter_%(side)^:+1; [Cooldown: 1 turn]

    !!if&i^battle_isVisible^;
      !!SN:H^spell^/(spell)/(SPELL_TEXT_NAME)/?(spellName:z);
      !!BM(stack):T?(type:y) N?(num:y);
      !!VR(isPlural:y):S(num) -1 B;
      !!SN:H^monname^/(type)/(isPlural)/?(monName:z);
      !!SN:T^tumr.str.atmaRobe^/?(battleLog:z)/^mon^/(monName)/^spell^/(spellName);
      !!MM:S(battleLog);
    !!en;
  !!en;
!!en;

****************************************************************************************************
// Cape of Silence (267)
// Bad implementation as here we haven't correct text on the screen when casting a forbiddon spell!
// Disable the cast of level 1 and Level 2 spells for both players
!?FU(OnSetupBattlefield)&i^tum_emerald_on^;
!!VRi^tum_%(ART_CAPE_OF_SILENCE)_equipped^:S(FALSE);

!!re i/(BATTLE_LEFT)/i^battle_hero_vs_hero^;
  !!HEi^battle_hero_%i^:A2/(ART_CAPE_OF_SILENCE)/?(has:y)/?(equipped:y);

  !!if&(equipped)>0;
    !!VRi^tum_%(ART_CAPE_OF_SILENCE)_equipped^:S(TRUE);
    !!br;
  !!en;
!!en;

!?FU(OnDwarfMagicResistance)&i^tum_emerald_on^/i^tum_%(ART_CAPE_OF_SILENCE)_equipped^;
; Exit if the targeted spell is not level 1 or 2
!!MR:S?(spell:y);
!!SS(spell):L?(level:y);
!!FU&(level)>2:E;

; Set spell immunity to 100 if the hero has the artifact that grants immunity to the spell
!!MR:F100;

****************************************************************************************************
// Garb of the Forest Lord (279)
// Gives Rampart creatures every week
!?FU(OnEveryDay)&i^timerWeekDay^=1/i^timerWeek^>1/i^tum_emerald_on^;
!!UN:P71/?(enhancedArtifactII:y);

!!re i/(HERO_FIRST)/(HERO_LAST_WOG);
  !!HEi:O?(owner:y);

  !!if&(owner)=i^timerOwner^;
    !!HEi:A2/(ART_GARB_OF_THE_FOREST_LORD)/?(has:y)/?(equipped:y);

    !!if&(equipped)>0;
      ; Compatibility with Enhanced Artifacts II
      !!if&(enhancedArtifactII);
        !!FU(WOG_71_UpgradeMonsterWithArtifact):Pi/(ART_GARB_OF_THE_FOREST_LORD)/(MON_CENTAUR) Pi/(ART_GARB_OF_THE_FOREST_LORD)/(MON_DWARF) 
        Pi/(ART_GARB_OF_THE_FOREST_LORD)/(MON_DENDROID_GUARD) Pi/(ART_GARB_OF_THE_FOREST_LORD)/(MON_UNICORN);
      !!en;

      ; Human
      !!if&i^timerIsHuman^;
        !!FU(NewIntArray):P8/(PIC_TYPE_MONSTER)/?(monsters:y);
        !#VA(monType[4]:y);
        !!VR(monType[0]):C(MON_WAR_UNICORN)/(MON_DENDROID_SOLDIER)/(MON_BATTLE_DWARF)/(MON_CENTAUR_CAPTAIN);

        ; Enhanced
        ; Upgrade the given creatures to 3rd upgrade if TUM Upgrade guild is built
        ; This bit will need to be updated once new_towns.era is put into use
        !!UN:P904/(TRUE) P905/(FALSE);
        !!HEi:P?(x:y)/?(y:y)/?(z:y);

        !!CA(x)/(y)/(z):U?(townId:y);
        !!UN:P905/?(hasError:y);

        !!if&(hasError)<>(TRUE)/i^tum_upgGuild_%(townId)^;
          !!VR(monType[0]):C(MON_LEGENDARY_UNICORN)/(MON_DENDROID_ELDER)/(MON_DWARF_DESTROYER)/(MON_CENTAUR_GENERAL);
        !!en;

        !!UN:P904/(FALSE) P905/(FALSE);

        !!VR(bit:y):S1;

        !!re k/0/(monType[SIZE])/1/-1;
          !!VR(monAmount:y):S(bit) *65536 +(monType[k]); Sd<<16 |(monType[k]);
          !!VR(ind:y):Sk*2+1;
          !!SN:M(monsters)/(ind)/(monAmount);
          !!VR(bit):Sd<<1;
        !!en;

        !!FU(PrepareMultiPicDialog):P(monsters);
        !!HEi:B0/?(heroName:z);
        !!SN:T^tumr.str.garbOfTheForestLord^/?(msg:z)/^heroName^/(heroName);
        !!IF:N1/(msg:z);

        ; give 1 war unicorn, 2 dendroid soldiers, 4 battle dwarves, 8 centaur captains - use HE:C in order to manage them altogether
        !!HEi:C(monType[0])/1/(monType[1])/2/(monType[2])/4/(monType[3])/8/-1/0/-1/0/-1/0;
      ; AI
      !!el;
        !!HEi:C2/(monType[0])/1/0; [offer AI war unicorn]
        !!HEi:C2/(monType[1])/2/0; [offer AI dendroid soldiers]
        !!HEi:C2/(monType[2])/4/0; [offer AI battle dwarves]
        !!HEi:C2/(monType[3])/8/0; [offer AI centaur captains]
      !!en;
    !!en;
  !!en;
!!en;

****************************************************************************************************
// Third Eye (280)
// Learn all the adventure spells learned by your enemy
// Enhanced Artifacts I compatibility
; Must be executed earlier than WoG Scripts and Era Scripts
!?FU(WOG_102_HandleArtifacts)&i^tum_emerald_on^;
!!HEv600:A2/(ART_THIRD_EYE)/?(has:y)/?(equipped:y);
; Emblem of Cognizance (must consider backpack artifacts option)
!!UN:P727/?(backpackArtifacts:y);

!!if&(backpackArtifacts);
  !!VRv616:+(has);
!!el;
  !!VRv616:+(equipped);
!!en;

!!if&(equipped);
  ; Stoic Watchman
  !!VRv617:+(equipped);
!!en;

; Bird of Perception
!?FU(WOG_102_GetBirdOfPerceptionQty);
!#VA(heroId:x) (result:x);

!!VR(result):S0;
!!HE(heroId):A2/(ART_BIRD_OF_PERCEPTION)/?(has:y)/?(equipped1:y);
!!HE(heroId):A2/(ART_THIRD_EYE)/?(has:y)/?(equipped2:y);
!!VR(result):S(equipped1) +(equipped2);
!!SN:Q;

// Eagle Eye I compatibility
; Must be executed earlier than WoG Scripts
!?FU(WOG_202_CalcCounterSpellChance)&i^tum_emerald_on^;
!#VA(side:x) (result:x);

!!HEi^battle_hero_%(side)^:A2/(ART_THIRD_EYE)/?(has:y)/?(equipped:y);

!!if&(equipped);
  !!HEi^battle_hero_%(side)^:S(SKILL_EAGLE_EYE)/?(skillLvl:y);

  !!if&(skillLvl)>(SKILL_NOT_LEARNED);
    !!VR(result):S(skillLvl) *10 +50;
    ; Skip the calculatio in the original function
    !!SN:Q;
  !!en;
!!en;

// Elemental Suppression compatibility
; Must be executed earlier than Era Scripts
!?FU(ES_776_Hero_GetSuppressionPower)&i^tum_emerald_on^;
!#VA(heroId:x) (result:x);

!!VR(result):S(NULL);
!!HE(heroId):A2/(ART_THIRD_EYE)/?(has:y)/?(equipped:y);

!!if&(equipped);
  !!VR(result):S3;
  ; Secondary skill
  !!HE(heroId):S(SKILL_EAGLE_EYE)/?(skillLvl:y);
  !!VR(result):+(skillLvl);
  ; Specialty
  !!HE(heroId):X?(spec:y)/?(specSkill:y);
  !!VR(result)&(spec)=0/(specSkill)=(SKILL_EAGLE_EYE):+1;
  ; Skip the calculatio in the original function
  !!SN:Q;
!!en;

// Main
!?FU(OnAfterBattleUniversal)&i^battle_hero_vs_hero^/(ERM_FLAG_IS_HUMAN);
!!re i/(BATTLE_LEFT)/(BATTLE_RIGHT);
  !!BA:Hi/?(hero:y);
  !!HE(hero):O?(owner:y);

  !!if&(owner)>(NO_OWNER);
    !!HE(hero):A2/(ART_THIRD_EYE)/?(has:y)/?(equipped:y);

    !!if&(equipped);
      !!HE(hero):S(SKILL_WISDOM)/?(wisdomLvl:y);
      !!VR(maxSpellLvl:y):S(wisdomLvl) +2;
      !!FU(NewIntArray):P?(spellNotLearned:y);

      ; Loop through all the adventure spells and see if there is anything the winnder not learned (and also can learn with the current Wisdom level)
      !!re j/(SPELL_FIRST_ADVENTURE)/(SPELL_LAST_ADVENTURE);
        !!SSj:L?(spellLvl:y);

        !!if&(spellLvl)<=(maxSpellLvl);
          !!HE(hero):M=j/1;
          !!FU(Array_Push)&-1:P(spellNotLearned)/j;
        !!en;
      !!en;

      !!SN:M(spellNotLearned)/?(size:y);

      ; If there is, check out if the defeated hero learned any of them
      !!if&(size)>0;
        !!VR(oppSide:y):Si X(TRUE);
        !!BA:H(oppSide)/?(oppHero:y);
        ; Set up array for IF:N - human player only
        !!OW:I(owner)/?(isAi:y);
        !!FU(NewIntArray)&(isAi)<>(TRUE):P?(spellPicsList:y);

        !!re j/0/(size)/1/-1;
          !!SN:M(spellNotLearned)/j/?(spell:y);
          !!HE(oppHero):M=(spell)/1;

          ; Give spell and set IF:N list
          !!if&1;
            !!HE(hero):M(spell)/(TRUE);
            !!FU(Array_Push)&(isAi)<>(TRUE):P(spellPicsList)/(PIC_TYPE_SPELL)/(spell);
          !!en;
        !!en;

        ; If the winner learned anything, show IF:N dialogue for human
        !!if&(isAi)<>(TRUE);
          !!SN:M(spellPicsList)/?(size:y);

          !!if&(size);
            !!FU(PrepareMultiPicDialog):P(spellPicsList);
            !!HE(hero):B0/?z2;
            !!HE(oppHero):B0/?z3;
            !!SN:T^tumr.str.mastersScroll^/?z4/^hero^/z2/^oppHero^/z3;
            !!IF:N(MSG_TYPE_MES)/z4;
          !!en;
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

// Reduce the spells of your opponent's troops by 1
; This should be executed as late as possible as some external script might give additional spells
; Ideally the reduction effect should take place after all the addtion effects
!?FU(tum_BattleStack_InitParams)&i^tum_emerald_on^;
!#VA(stack:x) (side:x);

!!BM(stack):E?(spells:y);

!!if&(spells)>=1;
  !!VR(oppSide:y):S(side) X(TRUE);

  !!if&i^battle_hero_%(oppSide)^>(NO_HERO);
    !!HEi^battle_hero_%(oppSide)^:A2/(ART_THIRD_EYE)/?(has:y)/?(equipped:y);
    !!BM(stack)&(equipped):Ed-1;
  !!en;
!!en;

****************************************************************************************************
// Armor of the Ancient Lizardman (281)
// Add 1 extra retaliation to all your troops
// When a stack is melee attacked by an enemy, all the allies adjacent to the enemy will hit back
// This action will cost 1 retaliation
!?FU(OnSetupBattlefield)&i^tum_emerald_on^;
!!VRi^tum_%(ART_ARMOR_OF_THE_ANCIENT_LIZARDMAN)_equipped_0^:S(FALSE);
!!VRi^tum_%(ART_ARMOR_OF_THE_ANCIENT_LIZARDMAN)_equipped_1^:S(FALSE);

!!re i/(BATTLE_LEFT)/i^battle_hero_vs_hero^;
  !!HEi^battle_hero_%i^:A2/(ART_ARMOR_OF_THE_ANCIENT_LIZARDMAN)/?(has:y)/?i^tum_%(ART_ARMOR_OF_THE_ANCIENT_LIZARDMAN)_equipped_%i^;
!!en;

; Add 1 extra retaliation to every unit
!?FU(OnBattleRound)&i^battle_round^<=0/i^tum_emerald_on^;
!!re i/(BATTLE_LEFT)/i^battle_hero_vs_hero^;
  !!co&i^tum_%(ART_ARMOR_OF_THE_ANCIENT_LIZARDMAN)_equipped_%i^<=0;

  !!if&i=(BATTLE_LEFT);
    !!VR(startStack:y):S(BATTLE_ATTACKER_STACK_FIRST);
  !!el;
    !!VR(startStack:y):S(BATTLE_DEFENDER_STACK_FIRST);
  !!en;

  !!VR(endStack:y):S(startStack) +20;

  !!re j/(startStack)/(endStack);
    !!BMj:R?(retals:y);
    !!BMj&(retals)>0:Rd1;
  !!en;
!!en;

!?FU(tum_OnAfterRetaliationSetUp)&i^tum_emerald_on^;
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/(UNC_INT)/?(stackStruct:y);
!!UN:C(stackStruct)/244/(UNC_INT)/?(side:y);

!!if&i^tum_%(ART_ARMOR_OF_THE_ANCIENT_LIZARDMAN)_equipped_%(side)^>0;
  !!UN:C(stackStruct)/1108/(UNC_INT)/d1;
!!en;

!?FU(OnBattleActionEnd)&i^battle_acting_stack^>(NO_STACK)/i^tum_targetStack^>(NO_STACK)/i^tum_emerald_on^;
; Here we don't care whether i^tum_targetStack^ is still alive, as the revenge would happen with or without it
; Check if it is a melee attack and also the attacker isn't killed
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_WALK_AND_ATTACK):E;

; Check if it is the target's owner has Armor of the Anccient Lizardman
!!BMi^tum_targetStack^:I?(targetSide:y);
!!FU&i^tum_%(ART_ARMOR_OF_THE_ANCIENT_LIZARDMAN)_equipped_%(targetSide)^=(FALSE):E;

; Check if it is the attacker and the target is at the same side (possible when Hypnotized)
!!BMi^battle_acting_stack^:I?(atkSide:y);
!!FU&(atkSide)=(targetSide):E;

; Check if the attacker can be retaliated
!!FU(tum_CheckIfStackCanBeRetaliated):Pi^battle_acting_stack^/(targetSide)/?(result:y);
!!FU&(result)<>(TRUE):E;

!!BMi^battle_acting_stack^:F?(atkFlags:y);

; Get the position of the attacker and the side
!!VR(atkSecPos:y):S-1;
!!BMi^battle_acting_stack^:P?(atkPos:y);
!!VR(isWide:y):S(atkFlags) &(MON_FLAG_WIDE);

!!if&(isWide);
  !!if&(atkSide)=(BATTLE_LEFT);
    !!VR(atkSecPos):S(atkPos) +1;
  !!el;
    !!VR(atkSecPos):S(atkPos) -1;
  !!en;
!!en;

!!VR(shownBattlelog:y)&i^battle_isVisible^:S(FALSE);

; Look for adjacent allies
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  ; Break if the attacker just got killed (by previous attacks from guardians)
  !!BMi^battle_acting_stack^:N?(atkNum:y);
  !!br&(atkNum)<=0;

  ; Skip the stack just got attacked
  !!co&i=i^tum_targetStack^;

  ; Skip if the stack is killed
  !!BMi:N?(guardNum:y);
  !!co&(guardNum)<=0;

  ; Skip War Machines
  !!BMi:T?(type:y);
  !!co&(type)>=(MON_CATAPULT)/(type)<=(MON_ARROW_TOWERS);

  ; Skip if the stack has no retaliations
  !!BMi:R?(retals:y);
  !!co&(retals)<=0;

  ; Check if the stack can move
  !!BMi:G(SPELL_BLIND)/?(blindTurns:y)/d G70/?(stoneTurns:y)/d G74/?(paralyzeTurns:y)/d;

  ; Check if it is the same side with the attacker (when Hypnotized)
  !!if&(blindTurns)=0/(stoneTurns)=0/(paralyzeTurns)=0;
    !!BMi:I?(side:y);
    !!co&(side)=(atkSide);

    ; Check if it is adjacent to the attacker
    !!VR(posToAtk:y):S-1;               [Position to attack]

    !!FU(tum_CheckIfStacksAreAdjacent):Pi^battle_acting_stack^/i/?(result:y)/?(adjacentPos1:y)/?(adjacentPos2:y);

    ; Get the direiction of attack if the guardian is adjacent to the attacker
    !!if&(result);
      *!FU(tum_MakeStackAttackPos):Pi/(adjacentPos1)/(FALSE);
      !!FU(tum_MakeStackMeleeAttackStack):Pi/i^battle_acting_stack^;

      ; Reduce one retaliation
      !!BMi:Rd-1;

      ; Show battle log
      !!if&i^battle_isVisible^/(shownBattlelog)<>(TRUE);
        !!BMi^battle_acting_stack^:T?(atkMon:y);
        !!VR(isPlural:y):S(atkNum) -1 B;
        !!SN:H^monname^/(atkMon)/(isPlural)/?(monName:z);
        !!SN:T^tumr.str.armorOfTheAncientLizardman^/?(battleLog:z)/^mon^/(monName);
        !!MM:S(battleLog);
        !!VR(shownBattlelog):S(TRUE);
      !!en;

      !!FU(tum_ExecutePhoenixResurrection):P;
    !!en;
  !!en;
!!en;

****************************************************************************************************
// Binoculars Part 1 (282)
// Hero is under Vision spell and gains +4 sight radius.
; The second part is located in the same place as Rook/Raven's Scouting radius function. I put them together to reduce the amount of calculation
; Must be executed earlier than WoG Scripts and Era Scripts

// Enhanced Artifacts I compatibility
!?FU(WOG_102_HandleArtifacts)&i^tum_emerald_on^;
!!if&v618<=0;
  !!HEv600:A2/(ART_BINOCULARS)/?(has:y)/?v618;
!!en;

// Enhanced Artifacts II compatibility
!?FU(WOG_71_CheckIfHeroHasArt)&i^tum_emerald_on^;
!#VA(hero:x) (art:x) (result:x);

!!if&(art)=(ART_PENDANT_OF_SECOND_SIGHT);
  !!HE(hero):A2/(ART_BINOCULARS)/?t/?(result);
  !!SN&(result)>0:Q;
!!en;

// Night Scouting compatibility
!?FU(ES_795_GetArtNightScoutingRadius);
!#VA(hero:x) (result:x);

!!HE(hero):A2/(ART_BINOCULARS)/?(has:y)/?(equipped:y);

!!if&(equipped)>0;
  !!VR(result):S2;
  !!SN:Q;
!!en;

// Main
// Hero has full Vision power
!?FU(tum_OnGetVisionPowerPre);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(heroStruct:y);
!!UN:C(heroStruct)/26/4/?(heroId:y);

!!HE(heroId):A2/(ART_BINOCULARS)/?(has:y)/?(equipped:y);

!!if&(equipped)>0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ECX)/4/3;
!!en;

!?FU(tum_OnGetVisionPower);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(heroStruct:y);
!!UN:C(heroStruct)/26/4/?(heroId:y);

!!HE(heroId):A2/(ART_BINOCULARS)/?(has:y)/?(equipped:y);

!!if&(equipped)>0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/3;
!!en;

****************************************************************************************************
// Sleepkeeper (283)
// Removes all the negative effects when troops defend. Gains 100% resistance to spells except for friendly ones when troops are defending.
; The stack must be led by a hero
!?FU(OnBeforeBattleAction)&i^battle_hero_%i(battle_acting_side)^>(NO_HERO);
; Exit if not defending
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_DEFEND):E;

; Exit if the stack is hypnotized
!!BMi^battle_acting_stack^:G(SPELL_HYPNOTIZE)/?(duration:y)/?(level:y);
!!FU&(duration)>0:E;

; Exit if not having Sleepkeeper
!!HEi^battle_hero_%i(battle_acting_side)^:A2/(ART_SLEEPKEEPER)/?(has:y)/?(equipped:y);
!!FU&(equipped)<=0:E;

!!VR(spellDispelled:y):S(FALSE);

!!if&i^tum_%(ART_SPHERE_OF_PERMANENCE)_equipped^<>(TRUE);
  !!re i/(SPELL_FIRST_ADVENTURE)/(SPELL_LAST_BATTLE);
    !!SSi:O?(spellType:y);
    !!co&(spellType)=1;

    !!BMi^battle_acting_stack^:Gi/?(duration:y)/?(level:y);

    !!if&(duration)>0;
      !!VR(spellDispelled):S(TRUE);
      !!FU(tum_RemoveSpellFromStack):Pi^battle_acting_stack^/i;
    !!en;
  !!en;
!!en;

!!if&i^battle_isVisible^;
  !!if|i^tum_%(ART_ORB_OF_VULNERABILITY)_equipped^<>(TRUE)/(spellDispelled);
    !!BMi^battle_acting_stack^:T?(type:y) N?(num:y);
    !!VR(isPlural:y):S(num) -1 B;
    !!SN:H^monname^/(type)/(isPlural)/?(monName:z);

    ; Resistance
    !!if&i^tum_%(ART_ORB_OF_VULNERABILITY)_equipped^<>(TRUE)/(spellDispelled)<>(TRUE);
      !!SN:T^tumr.str.sleepkeeper0^/?(msg:z)/^mon^/(monName);
    ; spell dispelled
    !!el&i^tum_%(ART_ORB_OF_VULNERABILITY)_equipped^/(spellDispelled);
      !!SN:P^Dispell^;
      !!BMi^battle_acting_stack^:V41;
      !!SN:T^tumr.str.sleepkeeper1^/?(msg)/^mon^/(monName);
    ; Both
    !!el;
      !!SN:P^Dispell^;
      !!BMi^battle_acting_stack^:V41;
      !!SN:T^tumr.str.sleepkeeper2^/?(msg)/^mon^/(monName);
    !!en;

    !!MM:S(msg);
  !!en;
!!en;

; Set resistance to non-friendly spells to full when troops are defending
!?FU(OnDwarfMagicResistance)&i^tum_%(ART_ORB_OF_VULNERABILITY)_equipped^<>(TRUE);
; Check if the resistance is not full
!!MR:F?(resistance:y);
!!FU&(resistance)>=100:E;

; Check if the stack is leading by a hero
!!MR:N?(stack:y);
!!BM(stack):I?(side:y);
!!FU&i^battle_hero_%(side)^=(NO_HERO):E;

; Check if the hero has Sleepkeeper
!!HEi^battle_hero_%(side)^:A2/(ART_SLEEPKEEPER)/?(has:y)/?(equipped:y);
!!FU&(equipped)<=0:E;

; Check if the stack is defending
!!BM(stack):F?(flags:y);
!!VR(isDefending:y):S(flags) &(MON_FLAG_DEFENDING);
!!FU&(isDefending)=0:E;

; Check if the spell is a non-friendly spell
!!MR:S?(spell:y);
!!SS(spell):O?(spellType:y);
!!FU&(spellType)=1:E;

; Set the resistance to full
!!MR:F100;

****************************************************************************************************
// Sword of Frost (284)
// Special effect when meeting up with Armageddons's Blade in melee battle, works for human only
!?FU(OnSetupBattlefield)&i^tum_emerald_on^/(ERM_FLAG_IS_HUMAN);
!!VRi^tum_%(ART_SWORD_OF_FROST)_secTurnActivated_0^:S(FALSE);
!!VRi^tum_%(ART_SWORD_OF_FROST)_secTurnActivated_1^:S(FALSE);

; Set up variable for checking whether both Armageddons's Blade and Sword of Frost are equipped by both heroes
!!VRi^tum_armageddonsAndFrost_counter^:S0;

!!if&i^battle_hero_vs_hero^;
  !!re i/(BATTLE_LEFT)/(BATTLE_RIGHT);
    !!HEi^battle_hero_%i^:A2/(ART_ARMAGEDDONS_BLADE)/?(has:y)/?(bladeEquipped:y);

    !!if&(bladeEquipped);
      !!VR(oppSide:y):Si X(TRUE);
      !!HEi^battle_hero_%(oppSide)^:A2/(ART_SWORD_OF_FROST)/?(has)/?(swordEquipped:y);

      !!if&(swordEquipped);
        !!VRi^tum_armageddonsAndFrost_counter^:S1;

        !!br;
      !!en;
    !!en;
  !!en;
!!en;

; If melee attack has been trigger in a battle, create a huge explosion to wipe out both hero armies
; No longer use OnAfterMelee as the game may crash on SN:E4472384/SN:D
*?FU(tum_OnAfterMelee)&i^tum_armageddonsAndFrost_counter^=1/(ERM_FLAG_IS_HUMAN);
*#VA(atkStack:x) (defStack:x);

!?FU(OnBattleActionEnd)&i^tum_armageddonsAndFrost_counter^=1/(ERM_FLAG_IS_HUMAN);
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_WALK_AND_ATTACK):E;

!!VRi^tum_armageddonsAndFrost_counter^:S2;

; Show message
!!SN:H^art^/(ART_ARMAGEDDONS_BLADE)/0/?(armageddonName:z);
!!SN:H^art^/(ART_SWORD_OF_FROST)/0/?(frostName:z);
!!SN:T^tumr.str.armageddonsAndFrost^/?(msg:z)/^art1^/(armageddonName)/^art2^/(frostName);
!!IF:Q1/(PIC_TYPE_ART)/(ART_ARMAGEDDONS_BLADE)/(PIC_TYPE_ART)/(ART_SWORD_OF_FROST)/(MSG_TYPE_MES)^%(msg)^;

; Blinding Flash and set clone/summoned flags so all the stacks can be destroyed easily
!!if&i^battle_isVisible^;
  !!BG:Q?(side:y);
  !!FU(NewIntArray):P?(affectedStacksList:y);
!!en;

!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!BMi:T?(type:y) N?(num:y);

  !!if&(type)>(NO_MON)/(num)>0;
    !!VR(flags:y):S(MON_FLAG_SUMMONED); (MON_FLAG_NO_COLORING) +(MON_FLAG_CLONE) +
    !!BMi:Fd|(flags) E0;

    !!if&i^battle_isVisible^;
      !!FU(tum_Battle_CanStackReceiveSpell):Pi/(SPELL_BLIND)/(side)/?(canReceive:y);
      !!FU(Array_Push):P(affectedStacksList)/i;
    !!en;
  !!en;
!!en;

!!if&i^battle_isVisible^;
  !!SN:P^blind^;
  !!FU(tum_PlayAnimationOnMultipleStacks):P(affectedStacksList)/6;

  ; Explosion
  !!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
    !!BMi:T?(type:y) N?(num:y);
    !!FU(Array_Push)&(type)>(NO_MON)/(num)>0:P(affectedStacksList)/i;
  !!en;

  !!SN:P^Fireblst^;
  !!FU(tum_PlayAnimationOnMultipleStacks):P(affectedStacksList)/9;
!!en;

; Armageddon
!!UN:C(COMBAT_MANAGER)/4/?(combatManager:y);
!!SN:E5898560/(CALLCONV_THISCALL)/(combatManager)/(SPELL_ARMAGEDDON)/0/2/-1/(SKILL_EXPERT)/99; [Expert, power]

; Make sure everything is killed
!!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
  !!BMi:T?(type:y) N?(num:y);

  !!if&(type)>(NO_MON)/(num)>0;
    ; Damage the stack
    !!BMiK2000000000;
    ; Kill the stack
    !!BMi:Z?(stackStruct:y);
    !!SN:E4472384/(CALLCONV_THISCALL)/(stackStruct)/0;
  !!en;
!!en;

; Take out Armageddons's Blade and Sword of Frost from both heroes
!!re i/(BATTLE_LEFT)/(BATTLE_RIGHT);
  !!HEi^battle_hero_%i^:A-(ART_ARMAGEDDONS_BLADE) A-(ART_SWORD_OF_FROST);
!!en;

; Update screen
; This is important for showing all the stacks dead
; No longer needed as now we use SN:E4472384, also SN:D may result in a crash
*!SN:D;
*!FU(tum_UpdateStackAnimation)&i^battle_isVisible^:P;

!?FU(OnAfterBattleUniversal)&i^tum_armageddonsAndFrost_counter^/(ERM_FLAG_IS_HUMAN);
; Place Fiery Fields on the map
!!if&i^tum_armageddonsAndFrost_counter^=2;
  !!UN:X?(size:y)/?(hasUnderground:y);
  !!VR(maxCoord:y):S(size) -1;

  ; Main
  !!re i/-3/4;
    !!re j/0/4/2;
      !!VR(x:y):Si^battle_x^ +i;
      !!VR(y:y):Si^battle_y^ +j;

      !!if&(x)>=0/(x)<=(maxCoord)/(y)>=0/(y)<=(maxCoord);
        !!UN:I(x)/(y)/i^battle_z^/(OBJ_FIERY_FIELDS)/0/(OBJ_FIERY_FIELDS)/0/-1/0;
      !!en;
    !!en;
  !!en;

  ; Edges
  ; Top and Bottom
  !!VR(offset[2]:y):C-1/5;

  !!re i/-2/3;
    !!re j/0/(offset[SIZE])/1/-1;
      !!VR(x):Si^battle_x^ +i;
      !!VR(y):Si^battle_y^ +(offset[j]);

      !!if&(x)>=0/(x)<=(maxCoord)/(y)>=0/(y)<=(maxCoord);
        !!UN:I(x)/(y)/i^battle_z^/(OBJ_FIERY_FIELDS)/0/(OBJ_FIERY_FIELDS)/0/-1/0;
      !!en;
    !!en;
  !!en;

  ; Left and Right
  !!VR(offset[2]:y):C-4/5;

  !!re i/0/(offset[SIZE])/1/-1;
    !!re j/1/3;
      !!VR(x):Si^battle_x^ +(offset[i]);
      !!VR(y):Si^battle_y^ +j;

      !!if&(x)>=0/(x)<=(maxCoord)/(y)>=0/(y)<=(maxCoord);
        !!UN:I(x)/(y)/i^battle_z^/(OBJ_FIERY_FIELDS)/0/(OBJ_FIERY_FIELDS)/0/-1/0;
      !!en;
    !!en;
  !!en;
!!en;

!!VRi^tum_armageddonsAndFrost_counter^:S0;

// Casts Paralyze for all the enemies at the start of battle (only when the enemy hero has no Sword of Frost)
!?FU(tum_OnBeforeArtifactAutoSpells)&i^tum_emerald_on^;
!!FU(tum_sof_FreezeAllEnemies):P2;

!?FU(OnBattleStackObtainsTurn)&i^battle_round^=1/i^tum_emerald_on^;
!!if&i^tum_%(ART_SWORD_OF_FROST)_secTurnActivated_%i(battle_current_side)^<>(TRUE);
  !!FU(tum_sof_FreezeAllEnemies):P1;
  !!VRi^tum_%(ART_SWORD_OF_FROST)_secTurnActivated_%i(battle_current_side)^:S(TRUE);
!!en;

!?FU(tum_sof_FreezeAllEnemies);
!#VA(duration:x);

!!BG:H?(hero:y);
!!VR(side:y):Si^battle_current_side^;

!!HE(hero):A2/(ART_SWORD_OF_FROST)/?(has:y)/?(equipped:y);

!!if&(equipped);
  !!VR(canCast:y):S(TRUE);
  !!VR(oppSide:y):S(side) X(TRUE);

  !!if&i^battle_hero_%(oppSide)^>(NO_HERO);
    !!HEi^battle_hero_%(oppSide)^:A2/(ART_SWORD_OF_FROST)/?(has:y)/?(equipped:y);
    !!VR(canCast)&(equipped):S(FALSE);
  !!en;

  !!if&(canCast);
    !!FU(NewIntArray)&i^battle_isVisible^:P?(affectedStacksList:y);
    ; Here we use Summon Boat as a dummy spell (level 4, Water school)
    !!SS(SPELL_SUMMON_BOAT):L?(origLevel:y) L4;

    ; Get the indexes for loop
    !!VR(oppSide:y):S(side) X(TRUE);

    !!if&(oppSide)=(BATTLE_LEFT);
      !!VR(startStack:y):S(BATTLE_ATTACKER_STACK_FIRST);
    !!el;
      !!VR(startStack):S(BATTLE_DEFENDER_STACK_FIRST);
    !!en;

    !!VR(endStack:y):S(startStack) +20;

    ; Check if each target can receive a level 4 water school spell
    !!re i/(startStack)/(endStack);
      !!co&i=i^battle_current_stack^;   [Skip current stack in case the current stack is the first acting and is hypnotized]

      !!BMi:T?(type:y) N?(num:y);
      !!co&(type)<=(NO_MON)/(num)<=0;

      !!BMi:G74/?(paralyzeDuration:y)/?(level:y);

      !!if&(paralyzeDuration)<(duration);
        !!FU(tum_Battle_CanStackBeAffectedBySpell):Pi/(SPELL_SUMMON_BOAT)/(side)/?(canReceive:y);

        ; Cast Paralyze
        !!if&(canReceive);
          !!BMi:M74/(duration)/(SKILL_NOT_LEARNED);
          !!FU(Array_Push)&i^battle_isVisible^:P(affectedStacksList)/i;
        !!en;
      !!en;
    !!en;

    ; Play sound and animation when there is at least a unit affected
    !!if&i^battle_isVisible^;
      !!SN:M(affectedStacksList)/?(size:y);

      !!if&(size)>0;
        !!SN:T^tumr.str.swordOfFrost^/?(battleLog:z);
        !!MM:S(battleLog);

        !!SN:P^firestrm^;

        ; Set up animation
        !!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(cmbMgr:y);
        !!UN:C(cmbMgr)/78572/(UNC_INT)/-1;
        ; Play the animation
        !!SN:B6837180/d/^blizzard.def^;
        !!FU(tum_PlayAnimationOnMultipleStacks):P(affectedStacksList)/9;
        !!SN:B6837180/d/^C04SPF0.def^;
        ; Reset changes
        !!UN:C(cmbMgr)/78572/(UNC_INT)/-1;
      !!en;
    !!en;

    ; Restore Summon Boat
    !!SS(SPELL_SUMMON_BOAT):L(origLevel);
  !!en;
!!en;

!?FU(OnAfterBattleUniversal);
!!VRi^tum_%(ART_SWORD_OF_FROST)_secTurnActivated_0^:S(FALSE);
!!VRi^tum_%(ART_SWORD_OF_FROST)_secTurnActivated_1^:S(FALSE);

// Alternative Approach
; This is disabled as it didn't work as expcted
; Casts Ice Blast (water level 4) and paralyze all the affected units
!?FU(tum_OnBeforeArtifactAutoSpells)&i^tum_emerald_on^;
!!FU:E;

!!VR(side:y):Si^battle_current_side^;
!!VR(hero:y):Si^battle_hero_%i(battle_current_side)^;

!!HE(hero):A2/(ART_SWORD_OF_FROST)/?(has:y)/?(equipped:y);

!!if&(equipped)>0;
  ; Check if it can turn armies to stone (possible only when the opposing hero doesn't have SoF)
  !!VR(canCastStone:y):S(TRUE);
  !!VR(oppSide:y):S(side) X(TRUE);

  !!if&i^battle_hero_%(oppSide)^>(NO_HERO);
    !!HEi^battle_hero_%(oppSide)^:A2/(ART_SWORD_OF_FROST)/?(has:y)/?(equipped:y);
    !!VR(canCastStone)&(equipped)>0:S(FALSE);
  !!en;

  ; Check if it is possible to cast Ice Blast (check the immunity to water school Armageddon of all units)
  !!SS(SPELL_ARMAGEDDON):S?(schoolBits:y) S4;

  !!re i/(BATTLE_STACK_FIRST)/(BATTLE_STACK_LAST);
    !!BMi:T?(type:y) N?(num:y);

    !!if&(type)>(NO_MON)/(num)>0;
      !!FU(tum_Battle_CanStackReceiveSpell):Pi/(SPELL_ARMAGEDDON)/(side)/?(canReceive:y);

      !!br&(canReceive);
    !!en;
  !!en;

  ; If there is at least a unit affected by water schoool Armageddon, set the damage of Armageddon to 300 and cast
  !!if&i<=(BATTLE_STACK_LAST);
    !!if&i^battle_isVisible^;
      ; Set up animation
      !!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(cmbMgr:y);
      !!UN:C(cmbMgr)/78572/(UNC_INT)/-1;
      !!SN:R^C06SPF0.def^/^iceBlast.def^;
      ; Disable battle log
      !!UN:C5920039/2/?(patch1:y) C5920039/2/12523 C5920041/4/?(patch2:y) C5920041/4/(OPCODE_NOP_4);
    !!en;

    !!VR(spellDmg:y):S300;
    !!SS(SPELL_ARMAGEDDON):E(SKILL_EXPERT)/?(spellEffect:y) E(SKILL_EXPERT)/(spellDmg) P?(spellPower:y) P0;
    !!FU(tum_CastArtifactSpell):P(ART_SWORD_OF_FROST)/(side)/(SPELL_ARMAGEDDON)/(NO_STACK)/1;
    !!SS(SPELL_ARMAGEDDON):E(SKILL_EXPERT)/(spellEffect) P(spellPower);

    !!if&i^battle_isVisible^;
      ; Reset changes
      !!SN:R^C06SPF0.def^/^^;
      !!UN:C(cmbMgr)/78572/(UNC_INT)/-1;[How to heck I cannot restore the animation of Armageddon to default???]
      !!UN:C5920039/2/(patch1) C5920041/4/(patch2);

      ; Show alternative battle log
      !!SN:T^tumr.str.iceBlast^/?(battleLog:z)/^damage^/(spellDmg);
      !!MM:S(battleLog);
    !!en;
  !!en;

  ; Restore the change in Armageddon
  !!SS(SPELL_ARMAGEDDON):S(schoolBits);

  ; Turns units to stone if they are not resisting level 4 Water shcool spell
  !!if&(canCastStone);
    ; Here we use Summon Boat as a dummy spell (level 4, Water school)
    !!SS(SPELL_SUMMON_BOAT):L?(origLevel:y) L4;

    ; Get the indexes for loop
    !!VR(oppSide:y):S(side) X(TRUE);

    !!if&(oppSide)=(BATTLE_LEFT);
      !!VR(startStack:y):S(BATTLE_ATTACKER_STACK_FIRST);
    !!el;
      !!VR(startStack):S(BATTLE_DEFENDER_STACK_FIRST);
    !!en;

    !!VR(endStack:y):S(startStack) +20;

    ; Check if each target can receive a level 4 water school spell
    !!re j/(startStack)/(endStack);
      !!FU(tum_Battle_CanStackReceiveSpell):Pj/(SPELL_SUMMON_BOAT)/(side)/?(canReceive:y);

      ; Cast Stone
      !!if&(canReceive);
        !!BMj:M70/2/(SKILL_NOT_LEARNED);
      !!en;
    !!en;

    ; Play sound and animation when there is at least a unit affected
    !!if&i^battle_isVisible^/j<=(endStack);
      !!SN:T^tumr.str.swordOfFrost^/?(battleLog:z);
      !!MM:S(battleLog);

      !!SN:P^firestrm^;
    !!en;

    ; Restore Summon Boat
    !!SS(SPELL_SUMMON_BOAT):L(origLevel);
  !!en;
!!en;

****************************************************************************************************
// Tri-Colour Scepter (285, 286, 287)
; Switch among 3 forms depending on the situation
; Tri-colour Scepter - Non-living: Allows Animated Dead and Resurrection to be casted on non-living creatures.
; Tri-colour Scepter - Living: Protect living creatures from Disease, Age, Poison, Drain Life and Death Stare.
; Tri-colour Scepter - Undead: Undead creatures are now affected by morale. They also don't reduce the morale of other creatures
!?FU(OnHeroScreenMouseClick)&i^mouse_action^=(MOUSE_RMB_PRESSED)/999/i^tum_emerald_on^;
!!VR(slot:y):S(NO_ART_SLOT);
!!VR(item:y):Si^mouse_item^;

!!if&(item)>=2/(item)<=14|(item)=20;
  !!VR(slot):S(item) -2;
!!en;

!!FU&(slot)=(NO_ART_SLOT):E;

!!HE(CURRENT_HERO):N?(hero:y);
!!FU(tum_SwitchArtifactStatus):P(hero)/(slot);

!?FU(OnHeroesMeetScreenMouseClick)&i^mouse_action^=(MOUSE_RMB_PRESSED)/999/i^tum_emerald_on^;
!!VR(hero:y):S(NO_HERO);
!!VR(item:y):Si^mouse_item^;

!!if&(item)>=27/(item)<=39|(item)=45;
  !!VR(slot:y):S(item) -27;
  !!CM:H?(hero)/?(otherHero:y);
!!el&(item)>=46/(item)<=58|(item)=64;
  !!VR(slot):S(item) -46;
  !!CM:H?(otherHero)/?(hero);
!!en;

!!FU&(hero)=(NO_HERO):E;

!!FU(tum_SwitchArtifactStatus):P(hero)/(slot);

!?FU(tum_SwitchArtifactStatus);
!#VA(hero:x) (slot:x);

!!HE(hero):A1/?(art:y)/(slot);

; Tri-coloured Scepter
!!if|(art)=(ART_TRI_COLOUR_SCEPTER_NON_LIVING)/(art)=(ART_TRI_COLOUR_SCEPTER_LIVING)/(art)=(ART_TRI_COLOUR_SCEPTER_UNDEAD);
  !!SN:H^art^/(art)/1/?(desc:z);
  !!SN:T^tumr.str.triColourScepter^/?(ask:z);
  !!VR(msg:z):S(desc) +(ask);

  !#VA(forms[3]:y);
  !!VR(forms[0]):S(art);

  !!if&(art)=(ART_TRI_COLOUR_SCEPTER_NON_LIVING);
    !!VR(forms[1]):S(ART_TRI_COLOUR_SCEPTER_LIVING);
    !!VR(forms[2]):S(ART_TRI_COLOUR_SCEPTER_UNDEAD);
  !!el&(art)=(ART_TRI_COLOUR_SCEPTER_LIVING);
    !!VR(forms[1]):S(ART_TRI_COLOUR_SCEPTER_NON_LIVING);
    !!VR(forms[2]):S(ART_TRI_COLOUR_SCEPTER_UNDEAD);
  !!el;
    !!VR(forms[1]):S(ART_TRI_COLOUR_SCEPTER_NON_LIVING);
    !!VR(forms[2]):S(ART_TRI_COLOUR_SCEPTER_LIVING);
  !!en;

  !!IF:Q2/(PIC_TYPE_ART)/(forms[1])/(PIC_TYPE_ART)/(forms[2])/(MSG_TYPE_CHOOSE_PIC_OR_CANCEL)/^%(msg)^;
  !!VR(choice:y):Sv2;

  !!CM:R0;

  ; If not canceled, switch the form
  !!if&(choice)>-1;
    !!FU(UnequipArtFromSlot):P(hero)/(slot);
    !!HE(hero):A1/(forms[choice])/(slot);
    !!SN:D;
  !!en;
!!en;

// Non-living
5A42B9
!?FU(tum_OnAnimateUndeadFlagCheckA);

  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_ESI)/4/?(stack:y);
  !!FU(tum_CheckIfStackCanBeRevivedByTriColourScepter):P(stack)/?(result:y);
  !!VR(result):S(TRUE);

  !!if&(result);
    !!SN:X?t/0;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/5915339; 5A42CB
  !!en;

5A434F
!?FU(tum_OnAnimateUndeadFlagCheckB);

  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBX)/4/?(stack:y);
  !!FU(tum_CheckIfStackCanBeRevivedByTriColourScepter):P(stack)/?(result:y);
  !!VR(result):S(TRUE);

  !!if&(result);
    !!SN:X?t/0;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/5915485;
  !!en;

5A4029
!?FU(tum_OnResurrectionAliveFlagCheckA);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_ESI)/4/?(stack:y);
  !!FU(tum_CheckIfStackCanBeRevivedByTriColourScepter):P(stack)/?(result:y);

  !!if&(result);
    !!SN:X?t/0;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/5914683; 5A403B
  !!en;

5A40C1
!?FU(tum_OnResurrectionAliveFlagCheckB);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBX)/4/?(stack:y);
  !!FU(tum_CheckIfStackCanBeRevivedByTriColourScepter):P(stack)/?(result:y);

  !!if&(result);
    !!SN:X?t/0;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/5914831;
  !!en;

!?FU(tum_CheckIfStackCanBeRevivedByTriColourScepter);
!#VA(stackStruct:x);
!#VA(result:x);

!!VR(result):S(FALSE);
!!UN:C(stackStruct)/244/(UNC_INT)/?(side:y);

!!if&i^battle_hero_%(side)^>(NO_HERO);
  !!HEi^battle_hero_%(side)^:A2/(ART_TRI_COLOUR_SCEPTER_NON_LIVING)/?(has:y)/?(equipped:y);

  !!if&(equipped)>0;
    !!UN:C(stackStruct)/248/(UNC_INT)/?(stackOfSide:y);
    !!VR(stackId:y):S(side) *(BATTLE_STACKS_PER_SIDE) +(stackOfSide);

    !!BM(stackId):F?(flags:y);
    !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);
    !!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);

    !!VR(result)&(isAlive)=(FALSE)/(isUndead)=(FALSE):S(TRUE);
  !!en;
!!en;

; A general fix - skip golem resistance check for reviving spells (for spell description mod)
!?FU(tum_OnBeforeGolemResistanceCheck);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/12/4/?(spell:y);

!!if|(spell)=(SPELL_ANIMATE_DEAD)/(spell)=(SPELL_RESURRECTION)/(spell)=(SPELL_SACRIFICE); [Sacrifice isn't working yet]
  !!SN:X?t/0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/5930051; 5930051
!!en;

; daemon's solution not working - not showing correct quantity of revival with spell description mod
*?FU(tum_OnGolemResistanceTypeCheck);
*#VA(hook:x);

*!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EDX)/4/?(spell:y);

*!if|(spell)=(SPELL_ANIMATE_DEAD)/(spell)=(SPELL_RESURRECTION)/(spell)=(SPELL_SACRIFICE); [Sacrifice isn't working yet]
  *!SN:X?t/0;
  *!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4501949;
*!en;

!?FU(OnDwarfMagicResistance)&i^tum_emerald_on^;
!!MR:S?(spell:y);

!!if|(spell)=(SPELL_ANIMATE_DEAD)/(spell)=(SPELL_RESURRECTION)/(spell)=(SPELL_SACRIFICE); [Sacrifice isn't working yet]
  !!MR:N?(stackId:y);
  !!BM(stackId):Z?(stackStruct:y);
  !!FU(tum_CheckIfStackCanBeRevivedByTriColourScepter):P(stackStruct)/?(result:y);

  !!MR&(result):F0;
!!en;

// Living
; Provide proection to Disease, Age, Poison, Drain life and Death Stare
; temporarily remove living flag
!?FU(tum_OnAfterHitSpells)&i^tum_emerald_on^;
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/8/4/?(targetStruct:y);
!!UN:C(targetStruct)/244/4/?(side:y);

!!if&i^battle_hero_%(side)^>(NO_HERO);
  !!HEi^battle_hero_%(side)^:A2/(ART_TRI_COLOUR_SCEPTER_LIVING)/?(has:y)/?(equipped:y);

  !!if&(equipped)>0;
    !!UN:C(targetStruct)/132/4/?(flags:y);
    !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);

    !!if&(isAlive);
      !!VR(flags):~(MON_FLAG_ALIVE);
      !!UN:C(targetStruct)/132/4/(flags);
      !!VRi^tum_%(ART_TRI_COLOUR_SCEPTER_LIVING)_stackStuct^:S(targetStruct);
      *!SN:X?t/0;
      *!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4457134; 4402AE
    !!en;
  !!en;
!!en;

; temporarily remove living flag
!?FU(tum_OnAfterAttackAbilities)&i^tum_emerald_on^;
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/8/4/?(targetStruct:y);
!!UN:C(targetStruct)/244/4/?(side:y);

!!if&i^battle_hero_%(side)^>(NO_HERO);
  !!HEi^battle_hero_%(side)^:A2/(ART_TRI_COLOUR_SCEPTER_LIVING)/?(has:y)/?(equipped:y);

  !!if&(equipped)>0;
    !!UN:C(targetStruct)/132/4/?(flags:y);
    !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);

    !!if&(isAlive);
      !!VR(flags):~(MON_FLAG_ALIVE);
      !!UN:C(targetStruct)/132/4/(flags);
      !!VRi^tum_%(ART_TRI_COLOUR_SCEPTER_LIVING)_stackStuct^:S(targetStruct);
      *!SN:X?t/0;
      *!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4461227; 4412AB
    !!en;
  !!en;
!!en;

; Restore living flag
!?FU(tum_OnPostAttackSpellsAndAbilities)&i^tum_%(ART_TRI_COLOUR_SCEPTER_LIVING)_stackStuct^;
!#VA(hook:x);

!!VR(targetStruct:y):Si^tum_%(ART_TRI_COLOUR_SCEPTER_LIVING)_stackStuct^;
!!VRi^tum_%(ART_TRI_COLOUR_SCEPTER_LIVING)_stackStuct^:S(NULL);

!!UN:C(targetStruct)/132/4/?(flags:y);
!!VR(flags):|(MON_FLAG_ALIVE);
!!UN:C(targetStruct)/132/4/(flags);

; This part is required for stack exp ability immunities
!?FU(OnDwarfMagicResistance)&i^tum_emerald_on^;
!#VA(hook:x);

!!MR:S?(spell:y);
!!FU&(spell)<>71/(spell)<>73/(spell)<>75:E;

!!MR:N?(stack:y);
!!BM(stack):I?(side:y);

!!if&i^battle_hero_%(side)^>(NO_HERO);
  !!HEi^battle_hero_%(side)^:A2/(ART_TRI_COLOUR_SCEPTER_LIVING)/?(has:y)/?(equipped:y);

  !!if&(equipped)>0;
    !!BM(stack):F?(flags:y);
    !!VR(isAlive:y):S(flags) &(MON_FLAG_ALIVE);

    !!MR&(isAlive)F100;
  !!en;
!!en;

// Undead
; Morale in battle
; Remoev No Morale flags from Undead
!?FU(tum_BattleStack_InitParams)&i^tum_emerald_on^;
!#VA(stackId:x) (side:x);

!!if&i^battle_hero_%(side)^>(NO_HERO);
  !!HEi^battle_hero_%(side)^:A2/(ART_TRI_COLOUR_SCEPTER_UNDEAD)/?(has:y)/?(equipped:y);

  !!if&(equipped)>0;
    !!BM(stackId):F?(flags:y);
    !!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);
    !!BM(stackId)&(isUndead):Fd~(MON_FLAG_NO_MORALE);
  !!en;
!!en;

; Morale value in battle
!?FU(tum_OnReduceMoraleDueToUndead_Battle);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EDI)/4/?(stackStruct:y);
!!UN:C(stackStruct)/132/4/?(flags:y);

!!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);
!!VR(isNoMorale:y):S(flags) &(MON_FLAG_NO_MORALE);

!!if&(isUndead)/(isNoMorale)=(FALSE);
  !!UN:C(stackStruct)/244/4/?(side:y);

  !!if&i^battle_hero_%(side)^>(NO_HERO);
    !!HEi^battle_hero_%(side)^:A2/(ART_TRI_COLOUR_SCEPTER_UNDEAD)/?(has:y)/?(equipped:y);

    !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/d2;
  !!en;
!!en;

; Morale value in non-battle
!?FU(tum_OnSkipMoraleCheckOnHeroScreen);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/12/4/?(heroStruct:y);
!!FU&(heroStruct)=(NULL):E;

!!UN:C(heroStruct)/26/4/?(heroId:y);

!!HE(heroId):A2/(ART_TRI_COLOUR_SCEPTER_UNDEAD)/?(has:y)/?(equipped:y);
!!FU&(equipped)<=0:E;

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/?(eax:y) C(hook)/(STRUCT_HOOK_CONTEXT_EDX)/4/?(edx:y);
!!VR(ptr:y):S(edx) *4 +(eax) +16;
!!UN:C(ptr)/4/?(flags:y);
!!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);

!!if&(isUndead);
  !!VRi^tum_%(ART_TRI_COLOUR_SCEPTER_UNDEAD)_value^:S(TRUE);
  !!SN:X?t/0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4501008; 44AE10
!!en;

!?FU(tum_OnReduceMoraleDueToUndead)&i^tum_%(ART_TRI_COLOUR_SCEPTER_UNDEAD)_value^;
!#VA(hook:x);

!!VRi^tum_%(ART_TRI_COLOUR_SCEPTER_UNDEAD)_value^:S(FALSE);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/d2;

; Morale of Undead cannot be lower than 0
!?FU(tum_OnConcludeMoraleResult)&i^tum_%(ART_TRI_COLOUR_SCEPTER_UNDEAD)_value^;
!#VA(hook:x);

!!VRi^tum_%(ART_TRI_COLOUR_SCEPTER_UNDEAD)_value^:S(FALSE);

!!FU:E;

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(morale:y);
!!VR(morale):F0/(INT_MAX);           [Morale cannot be lower than 0]
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/(morale);

; Morale Description
!?FU(tum_OnSetMonNotAffectedByMorale_Desc);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/20/4/?(heroStruct:y);
!!FU&(heroStruct)=(NULL):E;

!!UN:C(heroStruct)/26/4/?(heroId:y);

!!HE(heroId):A2/(ART_TRI_COLOUR_SCEPTER_UNDEAD)/?(has:y)/?(equipped:y);
!!FU&(equipped)<=0:E;

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/?(eax:y) C(hook)/(STRUCT_HOOK_CONTEXT_EDX)/4/?(edx:y);
!!VR(ptr:y):S(edx) +(eax) +16;
!!UN:C(ptr)/4/?(flags:y);
!!VR(isUndead:y):S(flags) &(MON_FLAG_UNDEAD);

!!if&(isUndead);
  !!VRi^tum_%(ART_TRI_COLOUR_SCEPTER_UNDEAD)_desc^:S(TRUE);
  !!SN:X?t/0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4503271;
!!en;

!?FU(tum_OnReduceMoraleDueToUndead_Desc)&i^tum_%(ART_TRI_COLOUR_SCEPTER_UNDEAD)_desc^; 44BA20
!#VA(hook:x);

!!VRi^tum_%(ART_TRI_COLOUR_SCEPTER_UNDEAD)_desc^:S(FALSE);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/40/4/d2;

!!VR(ptr:y):S(ebp) -92;

!!SN:T^tumr.str.triColourScepterUndead^/?(desc:z);
!!SN:K(desc)/?(size:y);
!!SN:E4305568/(CALLCONV_THISCALL)/(ptr)/?(desc)/(size);

!!SN:X?t/0;
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4504127; 44BD49

!?FU(tum_OnConcludeMoraleResult_Desc)&i^tum_%(ART_TRI_COLOUR_SCEPTER_UNDEAD)_desc^; 44BD46
!#VA(hook:x);

!!VRi^tum_%(ART_TRI_COLOUR_SCEPTER_UNDEAD)_desc^:S(FALSE);

!!FU:E;

; Set simialr desc like Spirit of Oppression. Couldn't figure out
*!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(morale:y);

*!if&(morale)<0;
  *!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/d1;

  *!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
  *!VR(ptr:y):S(ebp) -96;

  *!SN:Ti^tum_artStrList^
*!en;

*?FU(tum_OnPostCreateMoraleDec)&i^tum_%(ART_TRI_COLOUR_SCEPTER)_undead^;
*#VA(hook:x);

*!VRi^tum_%(ART_TRI_COLOUR_SCEPTER)_undead^:S(FALSE);

*!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(eax:y);
*!UN:C(eax)/4/?(textPtr:y);
*!SN:B(eax)/d/?z2;
*!IF:M^%z2^;

****************************************************************************************************
// General's order (245)
// General's Order must be executed later than Tri-Colour Scepter to be compatible
; Set up monster flag when the stack stats are initialised
!?FU(tum_BattleStack_InitParams)&i^tum_emerald_on^;
!#VA(stack:x) (side:x);

; Exit if the stack is not leaded by a hero
!!FU&i^battle_hero_%(side)^<=(NO_HERO):E;

; Exit if arrow tower
!!BM(stack):T?(type:y);
!!FU&(type)=(MON_ARROW_TOWERS):E;

; Check if the stack's owner has Baron's Gloves, General's Order and Crown of the Fire King
!!VR(hero:y):Si^battle_hero_%(side)^;

; No Morale
!!HE(hero):A2/(ART_GENERALS_ORDER)/?(has:y)/?(equipped:y);
!!BM(stack)&(equipped)>0:Fd|(MON_FLAG_NO_MORALE);

*******************************************
**** Set up text for special artifacts ****
*******************************************
!?FU(OnAfterErmInstructions);
; Exit if no artifact has been defined
!!SN:T^tumr.art.special.any^/?(specialArtStr:z);
!!FU&(specialArtStr)=^tumr.art.special.any^:E;

!!SN:K(specialArtStr)/?(length:y);
!!FU&(length)=0:E;

; Set new artifact levels for them to be enabled/disabled
!!FU(tum_ConvertStrToInts):P(specialArtStr)/?(specialArtList:y)/?(specialArtQty:y);

!!re i/0/(specialArtQty)/1/-1;
  !!SN:M(specialArtList)/i/?(art:y);

  !!SN:H^art^/(art)/1/?(desc:z);
  !!VR(desc):+^%T(tumr.str.mythicRareArt)^;
  !!SN:H^art^/(art)/1/(desc);
!!en;

*****************************************************************
**** Enable special artifacts for overpowered creature banks ****
*****************************************************************
; Allow special artifacts to be generated in some CBs
; Ultimate Dragon Utopia
!?OB(OBJ_NEW_WOG_OBJECTS)/115;
!!FU(tum_SetSpecialArtsAvailability):P(TRUE)/0;

!$OB(OBJ_NEW_WOG_OBJECTS)/115;
!!FU(tum_SetSpecialArtsAvailability):P(FALSE);

; Fire Dragon Castle
!?OB(OBJ_NEW_WOG_OBJECTS)/147;
!!FU(tum_SetSpecialArtsAvailability):P(TRUE)/1;

!$OB(OBJ_NEW_WOG_OBJECTS)/147;
!!FU(tum_SetSpecialArtsAvailability):P(FALSE);

; Ice Dragon Castle
!?OB(OBJ_NEW_WOG_OBJECTS)/148;
!!FU(tum_SetSpecialArtsAvailability):P(TRUE)/2;

!$OB(OBJ_NEW_WOG_OBJECTS)/148;
!!FU(tum_SetSpecialArtsAvailability):P(FALSE);

; Compatibility with Battle Save
!?FU(OnAfterLoadGame);
!!FU(tum_SetSpecialArtsAvailability):P(FALSE);

!?FU(tum_SetSpecialArtsAvailability)&i^tum_emerald_on^;
!#VA(isEnabling:x);                     [Whether is's enabling or disabling artifacts]
!#VA(cbType:x);                         [Optional. For Enabling only]

!!if&(isEnabling);
  !!VR(level:y):S(ART_LEVEL_RELIC);
!!el;
  !!VR(level):S(ART_LEVEL_SPECIAL);
!!en;

; Exit if no artifact defined
!!SN:T^tumr.art.special.any^/?(specialArtStr:z);
!!FU&(specialArtStr)=^tumr.art.special.any^:E;

!!SN:K(specialArtStr)/?(length:y);
!!FU&(length)=0:E;

!!UN:P197/?(dragonBloodBanned:y);
!!UN:P224/?(armageddonsBladeBanned:y);

; Set new artifact levels for them to be enabled/disabled
!!FU(tum_ConvertStrToInts):P(specialArtStr)/?(specialArtList:y)/?(specialArtQty:y);

!!re i/0/(specialArtQty)/1/-1;
  !!SN:M(specialArtList)/i/?(art:y);

  ; Skip if artifacts banned
  !!co&(art)=(ART_VIAL_OF_DRAGON_BLOOD)/(dragonBloodBanned);
  !!co&(art)=(ART_ARMAGEDDONS_BLADE)/(armageddonsBladeBanned);

  ; Skip Prismatic Eye of the God Dragon if the CB is Ultimate Dragon Utopia and it enabling
  !!co&(art)=(ART_PRISMATIC_EYE_OF_THE_GOD_DRAGON)/(cbType)=0/(isEnabling);

  ; Special treatment for Tri-colour Scepter, we skip here first
  !!co|(art)=(ART_TRI_COLOUR_SCEPTER_NON_LIVING)/(art)=(ART_TRI_COLOUR_SCEPTER_LIVING)/(art)=(ART_TRI_COLOUR_SCEPTER_UNDEAD);

  !!FU(tum_SetArtifactProperties):P(art)/(isEnabling)/(level);
!!en;

; Special treatment for Tri-colour Scepter
; Disable all the sceptters if it is disabling
!!if&(isEnabling);
  ; Set up array for Tri-Colour Scepter
  !!VR(triColourSecpters[3]:y):C(ART_TRI_COLOUR_SCEPTER_NON_LIVING)/(ART_TRI_COLOUR_SCEPTER_LIVING)/(ART_TRI_COLOUR_SCEPTER_UNDEAD);
  !!VR(random:y):R0/0/2;
  !!VR(art):S(triColourSecpters[random]);
  !!FU(tum_SetArtifactProperties):P(art)/(isEnabling)/(level);
!!el;
  !!FU(tum_SetArtifactProperties):P(ART_TRI_COLOUR_SCEPTER_NON_LIVING)/(isEnabling)/(ART_LEVEL_SPECIAL);
  !!FU(tum_SetArtifactProperties):P(ART_TRI_COLOUR_SCEPTER_LIVING)/(isEnabling)/(ART_LEVEL_SPECIAL);
  !!FU(tum_SetArtifactProperties):P(ART_TRI_COLOUR_SCEPTER_UNDEAD)/(isEnabling)/(ART_LEVEL_SPECIAL);
!!en;

!?FU(tum_SetArtifactProperties);
!#VA(art:x) (isEnabling:x) (level:x);

!!VR(isDisabled:y):S(isEnabling) X(TRUE);
!!UN:A(art)/(isDisabled);
!!UN:A(art)/3/(level);

************************************************************************
**** Bad Fix: Fix casting taking super high priority in AI decision ****
************************************************************************
; This crap should be fixed in Amethyst

; Monsters wih casting ability have high priority in casting, which doesn't make sense at all
; This script blocks casting with a chance
; This script currently works for TUM Reborn only (maybe it can be extended later)

; Warning: it turns out the script doesn't work well as Amethyst spell casting happens before FU(OnBeforeBattleStackTurn), but it still has some effects for some reason.

; Remove spells for monster casting Slayer or Frenzy for AI

!?FU(tum_BattleStack_InitParams)&i^tum_reborn_on^;
!#VA(stack:x) (side:x);

!!if&i^battle_ai_%(side)^;
  !!BM(stack):E?(spells:y);

  !!if&(spells);
    !!BM(stack):T?(type:y);
    !!FU(tum_GetMonLessUsefulSpell):P(type)/?(spell:y);

    !!if|(spell)=(SPELL_SLAYER)/(spell)=(SPELL_FRENZY)/(spell)=(SPELL_CURE);
      !!BM(stack):E0;
    !!en;
  !!en;
!!en;

!?FU(OnBattleStackObtainsTurn)&i^tum_tacticsIsEnded^/i^tum_reborn_on^/i^battle_ai_%i(battle_current_side)^;
!!BMi^battle_current_stack^:E?(spells:y);

!!if&(spells);
  !!BMi^battle_current_stack^:T?(type:y);
  !!FU(tum_GetMonLessUsefulSpell):P(type)/?(spell:y);

  !!if&(spell);
    ; 1/5 chance to have spells (even lower chance to cast)
    !!VR(random:y):R0/0/4;

    !!if&(random)<>0;
      !!BMi^battle_current_stack^:E0;
      !!VRi^tum_aiStackSpells^:S(spells);
    !!en;
  !!en;
!!en;

!?FU(OnBeforeBattleAction)&i^tum_tacticsIsEnded^/i^tum_reborn_on^;
!!BG:Q?(castingSide:y);
!!FU&i^battle_ai_%(castingSide)^<>(TRUE):E;

; If the spells were removed, restore the spells
; Here we assume if spells were removed, there is no chance it is a monster casting event
!!if&i^tum_aiStackSpells^;
  !!BMi^battle_current_stack^:Ei^tum_aiStackSpells^;
  !!VRi^tum_aiStackSpells^:S0;

  !!FU:E;
!!en;

; If it was a monster casting event, check if the target is ideal
; The script looks for better spell target depending on whether the spell to cast is Cure
; For other spells: look for alt target if the spell has been buffed
; For Cure: Look for other spell if the target is full HP and has no debuff
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_MONSTER_CAST):E;

!!BG:E?(targetStack:y);
!!FU|(targetStack)<(BATTLE_STACK_FIRST)/(targetStack)>(BATTLE_STACK_LAST):E;

!!BMi^battle_current_stack^:T?(type:y);
!!FU(tum_GetMonLessUsefulSpell):P(type)/?(spell:y);

!!if&(spell);
  !!VR(mustChangeTarget:y):S(FALSE);

  ; If the spell is a spell gives a buff
  !!if&(spell)<>(SPELL_CURE);
    !!BM(targetStack):G(spell)/?(duration:y)/?(level:y);
    !!VR(mustChangeTarget)&(duration)>0:S(TRUE);
  ; If the spell is Cure
  !!el;
    ; Check if the stack has lost some HP
    !!BM(targetStack):L?(lostHp:y);

    ; If full HP, check if the stack has got some debuff
    !!if&(lostHp)=0;
      !!re i/(SPELL_FIRST_BATTLE)/(SPELL_LAST_BATTLE);
        !!BM(targetStack):Gi/?(duration)/?(level);

        !!if&(duration)>0;
          !!SSi:O?(spellType:y);

          !!br&(spellType)=-1;
        !!en;
      !!en;

      !!VR(mustChangeTarget)&i>(SPELL_LAST_BATTLE):S(TRUE);
    !!en;
  !!en;

  ; If the current target for monster spell is not ideal, look for a new one
  !!if&(mustChangeTarget);
    !!BM(targetStack):I?(side:y);

    !!VR(firstStack:y):S(side) *(BATTLE_STACKS_PER_SIDE);
    !!VR(lastStack:y):S(firstStack) +20;

    !!re i/(firstStack)/(lastStack);
      !!BMi:T?(type:y) N?(num:y);

      !!if&(type)>(NO_MON)/(num)>0;
        !!VR(result:y):S(FALSE);

        !!if&(spell)<>(SPELL_CURE);
          !!BMi:G(spell)/?(duration)/?(level);
          !!VR(result)&(duration)<=0:S(TRUE);
        !!el;
          !!BMi:L?(lostHp:y);
          !!VR(result)&(lostHp)>0:S(TRUE);
        !!en;

        !!if&(result);
          !!FU(tum_Battle_CanStackReceiveSpell):Pi/(spell)/(castingSide)/?(canReceive:y);

          !!if&(canReceive);
            !!BG:Ei;
            !!BMi:P?(pos:y);
            !!BG:D(pos);

            !!br;
          !!en;
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(tum_GetMonLessUsefulSpell);
!#VA(mon:x) (result:x);

!!VR(result):S(FALSE);

; Castle
!!VR(result)&(mon)=(MON_HIGH_PRIEST):S(SPELL_PRAYER);
; Rampart
!!VR(result)&(mon)=(MON_DRYAD):S(SPELL_CURE); ** would be changed later in TUM Reborn
!!VR(result)&(mon)=(MON_OAK_DRYAD):S(SPELL_CURE); ** would be changed later in TUM Reborn
; Stronghold
!!VR(result)&(mon)=(MON_ELDER_OGRE):S(SPELL_FRENZY);
; Fortress
!!VR(result)&(mon)=(MON_GNOLL_SHAMAN):S(SPELL_SLAYER);
; Conflux
!!VR(result)&(mon)=(MON_FAIRY):S(SPELL_BLESS);
!!VR(result)&(mon)=(MON_HURRICANE_ELEMENTAL):S(SPELL_AIR_SHIELD);
!!VR(result)&(mon)=(MON_LIFE_ELEMENTAL):S(SPELL_BLESS);
!!VR(result)&(mon)=(MON_PLASMA_ELEMENTAL):S(SPELL_FIRE_SHIELD);
!!VR(result)&(mon)=(MON_MINERAL_ELEMENTAL):S(SPELL_STONE_SKIN);
; Neutral
!!VR(result)&(mon)=(MON_SATYR):S(SPELL_MIRTH);
!!VR(result)&(mon)=(MON_LEPRECHAUN):S(SPELL_FORTUNE);
!!VR(result)&(mon)=(MON_MERMAID):S(SPELL_FORTUNE);

!!VR(result)&(mon)=(MON_SLITHZERIKAI):S(SPELL_CURE); [Plague Doctor]
